<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java基础</title>
    <url>/posts/f7ede91d/</url>
    <content><![CDATA[<p><strong>概述：</strong>Java中<strong>部分</strong>的基础语法的随笔记录</p>
<span id="more"></span>

<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>跨平台</li>
<li>面向对象</li>
<li>支持多线程</li>
</ul>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p><strong>byte：</strong>8位有符号整数，int类型空间的四分之一，大型数组中节约空间，默认为0（127&#x2F;int）</p>
<p><strong>short：</strong>16位有符号整数，int类型空间的二分之一，大型数组中节约空间，默认为0(32767&#x2F;int)</p>
<p><strong>int：</strong>32位有符号整数，整形变量默认为int型，默认为0</p>
<p><strong>long：</strong> 64位有符号整数，默认值为<strong>0L</strong></p>
<p><strong>float：</strong>32位单精度浮点数，大型浮点数组中节约空间，默认为<strong>0.0f</strong></p>
<p><strong>double：</strong>64位双精度浮点数，浮点数变量默认为double型，默认为<strong>0.0d</strong></p>
<p><strong>boolean：</strong>一位，true&#x2F;false， 默认为false</p>
<p><strong>char：</strong>16位Unicode字符，最小值为\u0000（0），最大值为\uffff（65535）</p>
<p><strong>注</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i = 10;</span><br><span class="line">byte b = i;   --error，类型转换为强制转换</span><br><span class="line"></span><br><span class="line">int i = 130;</span><br><span class="line">byte b = (int)i;   --warnig,数值溢出，-126</span><br></pre></td></tr></table></figure>

<p>溢出规则：最大值加一，为最小值；反之</p>
<hr>
<p><strong>值传递：</strong>操作的是栈内存。对于基本数据类型（实参传到形参，形参不会改变实参—-C++）</p>
<p><strong>引用传递：</strong>操作的是堆内存。对于引用数据类型（对象的调用）</p>
<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p><strong>+&#x3D;：</strong>隐式操作，将结果类型（最后赋值的变量）提升为结果类型（被赋值的数值）。</p>
<p>​		如：两整型相加，如 <code>byte</code>、<code>short</code> 或者 <code>int</code>，首先会将它们提升到 int 类型，然后在执行加法操作。 </p>
<p><strong>+：</strong>任何数据类型与字符串，都是拼接操作</p>
<p><strong>三目运算：</strong>三个数值中，类型最大的为准</p>
<h4 id="String-引用类型"><a href="#String-引用类型" class="headerlink" title="String(引用类型)"></a>String(引用类型)</h4><p><strong>基本数据类型转换为String类型：</strong></p>
<ul>
<li>String.valueOf(变量类型  变量)</li>
</ul>
<p>1）String.valueOf([boolean] b) : 将 boolean 变量 b 转换成字符串<br>2）String.valueOf(char c)</p>
<p>3）String.valueOf(double d)<br>4）String.valueOf(float f)<br>5）String.valueOf(int i) </p>
<p>6）String.valueOf(long l) String.valueOf(char[] data) : 将 char 数组 data 转换成字符串<br>7）String.valueOf(char[] data, int offset, int count) :<br>                将 char 数组 data 中 由 data[offset] 开始取 count 个元素 转换成字符串 String.valueOf(Object obj) : 将 obj 对象转换成 字符串, 等于 obj.toString() </p>
<p><strong>String类型转基本数据类型：</strong></p>
<p>（1）byte : Byte.parseByte(String s) : 将 s 转换成 byte </p>
<p>（2）Byte.parseByte(String s, int radix) : 以 radix 为基底 将 s 转换为 byte ，比如说 Byte.parseByte(“11”, 16) 会得到 17 </p>
<p>（3）double : Double.parseDouble(String s) : 将 s 转换成 double </p>
<p>（4）float : Double.parseFloat(String s) : 将 s 转换成 float </p>
<p>（5）int : Integer.parseInt(String s) : 将 s 转换成 int </p>
<p>（6）long : Long.parseLong(String s)</p>
<p>特殊：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char: </span><br><span class="line">String str = “abssd”；</span><br><span class="line">char[] ch = str.toCharArray();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean:</span><br><span class="line">String s=&quot;888&quot;;</span><br><span class="line">//String s=&quot;true&quot;; //这个输出就是true</span><br><span class="line">Boolean b =new Boolean(s);</span><br><span class="line">b.parseBoolean(s);</span><br><span class="line">System.out.println(b.parseBoolean(s)）；//false</span><br><span class="line"></span><br><span class="line">java.lang.Boolean.parseBoolean(String s) 解析字符串参数作为一个布尔值。返回的布尔型参数的值为true，如果字符串参数不为null，是相等的，忽略大小写字符串“true”。</span><br></pre></td></tr></table></figure>



<h4 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h4><p>int —-&gt; Integer —-&gt; Integer.MAX_VALUE&#x2F;Integer.toBinaryString()(二进制符号位，0正，1负)</p>
<p>byte —-&gt; Byte</p>
<p>short —-&gt; Short </p>
<p>float —-&gt; Float</p>
<p>double —-&gt; Double</p>
<p>boolean —-&gt; Boolean</p>
<p>char —-&gt; Character</p>
<p>long —-&gt; Long</p>
<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><p><strong>增强for循环：</strong></p>
<p>foreach(元素类型type  元素变量value  ：遍历对象obj)</p>
<p>注：一般结合泛型使用</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><strong>初始化：</strong>静态初始化不允许二次赋值；动态初始化<code>int[] arr = new int[ARR_NUM]</code></p>
<ul>
<li><p>属性length</p>
</li>
<li><p>Arrays工具类</p>
<ul>
<li><p>Arrays.copyOfRange(T[ ] original,int from,int to)</p>
<p>将一个原始的[数组]original，从下标from开始复制，复制到上标to，生成一个新的数组。</p>
</li>
<li><p>Arrays.toString(nums) 				&#x2F;&#x2F;转字符串，输出时用和（带有【】）</p>
</li>
<li><p>Arrays.copyOf(nums， length)  &#x2F;&#x2F;复制，扩容自动填0 ，返回一个新数组</p>
</li>
<li><p>Arrays.sort(nums)						&#x2F;&#x2F;升序（快速排序）</p>
</li>
<li><p>System.arraycopy(arr1,index1,  arr2, index2, length)  &#x2F;&#x2F;arr1-&gt;arr2数组合并</p>
</li>
</ul>
</li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承后子类需要注意的是：</p>
<ul>
<li><code>Java</code> 只会隐式的调用无参构造函数，<ul>
<li>如果父类没有无参构造函数，那么子类中就必须显示的调用 <code>super</code>关键字来调用已有的有参构造函数来初始化父类。</li>
</ul>
</li>
<li><code>super.</code> 什么时候不能省略呢？<ul>
<li>子类也想使用一下父类的被覆盖的方法</li>
<li>子类中出现和父类一样的属性或者方法，此时，你要想去调用父类的那个属性或者方法</li>
</ul>
</li>
<li>若是父类的方法没有声明异常，则子类继承方法后，也不能声明异常。</li>
</ul>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><ul>
<li>final修饰的类无法继承</li>
<li>final修饰的方法无法覆盖</li>
<li>final修饰的变量只能赋值一次</li>
<li>final修饰的引用只能指向一次</li>
<li>final修饰的实例变量必须手动初始化，不可默认</li>
<li>public static final int PI &#x3D; 3.1415;</li>
</ul>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul>
<li><p>类定义： abstract  class  A {}</p>
</li>
<li><p>方法定义(没有方法体)：pubilc  abstract void doSome();</p>
</li>
<li><p>抽象类的子类特点：</p>
<ul>
<li>子类想要继承抽象类，就必须实现抽象类中的所有的抽象方法</li>
<li>子类不想实现父类的抽象方法，那么子类必须为抽象类。</li>
</ul>
</li>
</ul>
<blockquote>
<p>没有方法体的方法是抽象方法？<br>    答：不对。public native int hashCode(); &#x2F;&#x2F;Object类中c++写的动态链接库程序，JVM本地程序</p>
</blockquote>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li>定义：interface A {}</li>
<li>支持多继承</li>
<li>只有常量和抽象方法（<strong>注意没有方法体</strong>）<ul>
<li>public static(可省略)</li>
<li>public static final(可省略)</li>
</ul>
</li>
<li>子类需要实现相应的抽象方法</li>
<li>同时继承和实现接口<ul>
<li>class A extends B implements C</li>
</ul>
</li>
<li>支持多态（父类型引用指向子类型）</li>
</ul>
<h3 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h3><table>
<thead>
<tr>
<th></th>
<th>本类</th>
<th>同包</th>
<th>子类</th>
<th>任意</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>default</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>private</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>1、内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。<br>2、内部类并没有令人迷惑的<code>“is-a”</code>关系，他就是一个独立的实体。<br>3、内部类提供了更好的封装，除了该外围类，其他类都不能访问。<br>4、创建内部类对象的时刻并不依赖于外围类对象的创建。</p>
<p>具体来说，内部类信息（属性、方法）可以和外部类重名；内部类是具有类的基本特征的独立实体；可以利用访问修饰符隐藏内部类的实施细节，提供了更好的封装；静态内部类使用时可直接使用，不需先创造外部类。 </p>
<hr>
<p><strong>成员内部类：</strong>【成员内部类被认为成外部类的成员信息存在 】</p>
<ul>
<li>可以是任何的访问修饰符。</li>
<li>内部类的内部不能有静态信息。</li>
<li>内部类也是类，可以继承，可重写，可以重载，<code>this</code> 和 <code>super</code> 可以使用。</li>
<li>内部类可以直接使用外部类的任何信息</li>
<li>其它类如何访问内部类：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Outer outer = new Outer();</span><br><span class="line">//创造内部类对象</span><br><span class="line">Outer.Inner inner = outer.new Inner();</span><br><span class="line">inner.innerShow();</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>静态内部类：</strong>【和成员内部类对比理解（区别异同）】</p>
<ul>
<li>内部可以包含任意的信息。</li>
<li>静态内部类的方法只能访问外部类的static关联的信息。</li>
<li>利用 <code>外部类.内部类 引用 = new 外部类.内部类(); </code>然后利用 <code>引用.成员信息(属性、方法)</code> 调用。</li>
<li>访问内部类的静态信息，直接 <code>外部类.内部类.静态信息</code> 就可以了。</li>
<li>静态内部类可以独立存在，不依赖于其他外围类。</li>
</ul>
<hr>
<p><strong>局部内部类：</strong>【局部内部类有很多局限，应注意作用域】</p>
<ul>
<li>类前不能有访问修饰符。</li>
<li>仅在此方法内使用。</li>
<li>无法创造静态信息。</li>
<li>可以直接访问方法内的局部变量和参数，但是不能更改。</li>
<li>可以随意的访问外部类的任何信息。</li>
</ul>
<hr>
<p><strong>匿名内部类（</strong>★★★）：</p>
<ul>
<li>匿名内部类总是默认实现某个接口或继承某个抽象类。</li>
<li>不能有构造方法，只能有一个实例。</li>
<li>不能定义在任何静态成员、静态方法。</li>
<li>不能被 <code>public</code>,<code>protected</code>,<code>private</code>,<code>static</code> 修饰。</li>
<li>匿名内部类为局部的，所以局部内部类的所有限制都对其有效。</li>
</ul>
<h3 id="日期处理"><a href="#日期处理" class="headerlink" title="日期处理"></a>日期处理</h3><p>java.util.Date</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Date nowTime = new Date();</span><br><span class="line">System.out.println(nowTime);//Thu Mar 05 10:10:23 CST 2022</span><br></pre></td></tr></table></figure>

<p>格式化日期（字母不可改，但字符可以）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss SSS&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">newTime</span> <span class="operator">=</span> sdf.format(nowTime);<span class="comment">//2022-02-23 12:12:13 123</span></span><br></pre></td></tr></table></figure>

<p>字符串转日期</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String ti = &quot;2022-02-23 12:12:13&quot;;</span><br><span class="line">SimpleDateFormat sdf02 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;)</span><br><span class="line">Date dateTi = sdf02.parse(ti);</span><br></pre></td></tr></table></figure>

<hr>
<p>获取自1970.1.1 00:00:00 到现在的总毫秒数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">long nowTi = System.currentTimeMillis();</span><br></pre></td></tr></table></figure>



<h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p>结果不超过2个的用Boolean类型</p>
<p>结果超过2个的，且结果可枚举出来的用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum 枚举类型名&#123;</span><br><span class="line">	枚举值01， 枚举值02， ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">枚举类型名.枚举值01</span><br></pre></td></tr></table></figure>



<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125; <span class="keyword">catch</span>(FileNotFoundException | ArithmeticException e) &#123;</span><br><span class="line">	e.printStackTrace();<span class="comment">//异常堆栈信息</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//流的关闭</span></span><br><span class="line">    <span class="comment">//一定会执行的区域</span></span><br><span class="line">    <span class="comment">//先执行try， 再执行finally， 最后执行return</span></span><br><span class="line">    <span class="comment">//特殊情况，推出JVM时不执行：System.exit(0);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//catch后面可以写多个异常，用|(or)链接</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//特殊情况</span><br><span class="line">public static m() &#123;</span><br><span class="line">	int i = 200;</span><br><span class="line">	try &#123;</span><br><span class="line">		return i;</span><br><span class="line">	&#125; catch() &#123;</span><br><span class="line">		</span><br><span class="line">	&#125; finally &#123;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;//返回值为100，但执行顺序是先执行try， 再执行finally， 最后执行return。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//自定义异常</span><br><span class="line">class A extends Exception &#123;&#125;        //编译时异常</span><br><span class="line">class B extends RunTimeException &#123;&#125; //运行时异常</span><br></pre></td></tr></table></figure>



<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ul>
<li>集合不存储基本数据类型</li>
<li>只存储一个对象的引用</li>
<li>具体见JavaSE-集合基础</li>
</ul>
<h2 id="实体对象"><a href="#实体对象" class="headerlink" title="实体对象"></a>实体对象</h2><p>定义：只封装实体属性，不做任何业务处理</p>
<p>标准的JavaBean规范：</p>
<ul>
<li>封装型，setter和getter</li>
<li>提供无参构造</li>
<li>实现序列化接口</li>
</ul>
<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><ul>
<li>Lambda表达式一定要配合函数式接口一起使用</li>
<li>@FunctionalInterface注解修饰了接口，那这个接口就是函数式接口，<strong>只能有一个抽象方法</strong></li>
<li>可以继承Object类的方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">接口 接口名 = (参数列表)-&gt;&#123;函数体&#125;;</span><br><span class="line"></span><br><span class="line">当某方法或类定义需要传入一个抽象类的实例时，可以直接用等式右边重写方法后传入</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(5,1,3,4,5,0,9,7,0,1,5);</span><br><span class="line">list.forEach(element-&gt; System.out.println(element));</span><br></pre></td></tr></table></figure>





<h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><ul>
<li><p>主要用于文件和目录的创建、查找和删除等操作</p>
</li>
<li><p>构造函数</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public File(String pathname) ：通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。</span><br><span class="line"></span><br><span class="line">public File(String parent, String child) ：从父路径名字符串和子路径名字符串创建新的 File实例。</span><br><span class="line"></span><br><span class="line">public File(File parent, String child) ：从父抽象路径名和子路径名字符串创建新的 File实例</span><br></pre></td></tr></table></figure>

<ul>
<li>常用方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String getAbsolutePath() ：返回此File的绝对路径名字符串。</span><br><span class="line"></span><br><span class="line">public String getPath() ：将此File转换为路径名字符串。</span><br><span class="line"></span><br><span class="line">public String getName() ：返回由此File表示的文件或目录的名称。</span><br><span class="line"></span><br><span class="line">public long length() ：返回由此File表示的文件的长度。</span><br></pre></td></tr></table></figure>

<ul>
<li>判断</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean exists() ：此File表示的文件或目录是否实际存在。</span><br><span class="line">public boolean isDirectory() ：此File表示的是否为目录。</span><br><span class="line">public boolean isFile() ：此File表示的是否为文件。</span><br></pre></td></tr></table></figure>

<ul>
<li>创建&amp;删除</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean createNewFile() ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。</span><br><span class="line">public boolean delete() ：删除由此File表示的文件或目录。</span><br><span class="line">public boolean mkdir() ：创建由此File表示的目录。</span><br><span class="line">public boolean mkdirs() ：创建由此File表示的目录，包括任何必需但不存在的父目录。</span><br></pre></td></tr></table></figure>

<ul>
<li>遍历</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。</span><br><span class="line"></span><br><span class="line">public File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。</span><br></pre></td></tr></table></figure>

<ul>
<li>一个案例（Lambda）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void printDir3(File dir) &#123;</span><br><span class="line">  	// lambda的改写</span><br><span class="line">    File[] files = dir.listFiles(f -&gt;&#123; </span><br><span class="line">      	return f.getName().endsWith(&quot;.java&quot;) || f.isDirectory(); </span><br><span class="line">    &#125;);</span><br><span class="line">  	</span><br><span class="line">	// 循环打印</span><br><span class="line">    for (File file : files) &#123;</span><br><span class="line">        if (file.isFile()) &#123;</span><br><span class="line">            System.out.println(&quot;文件名:&quot; + file.getAbsolutePath());</span><br><span class="line">      	&#125; else &#123;</span><br><span class="line">        	printDir3(file);</span><br><span class="line">      	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h3 id="一个基本概念"><a href="#一个基本概念" class="headerlink" title="一个基本概念"></a>一个基本概念</h3><p>1.位（bit）：是计算机内部数据储存的最小单位。</p>
<p>2.字节（byte）：是计算机中数据处理的基本单位，习惯上用大写B来表示,1B（byte,字节）&#x3D;8bit（位）</p>
<p>3.字符（char）：是指计算机中使用的字母、数字、字和符号。依据字符不同的编码格式，每个字符单位对应的字节数是不一样的。</p>
<h3 id="基本流"><a href="#基本流" class="headerlink" title="基本流"></a>基本流</h3><ol>
<li>字符流<ul>
<li>以字符为单位传输数据</li>
<li>一般情况下，字符流都维护着一个缓冲区，默认大小8KB</li>
</ul>
</li>
<li>字节流<ul>
<li>以字节为单位传输数据</li>
<li>没有自己维护缓冲区，直接操作文件—但可以自定义缓存区</li>
</ul>
</li>
</ol>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h4 id="处理字符文件，如文本文件"><a href="#处理字符文件，如文本文件" class="headerlink" title="处理字符文件，如文本文件"></a><strong>处理字符文件，如文本文件</strong></h4><table>
<thead>
<tr>
<th></th>
<th>FileWriter</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>字符输出流</td>
</tr>
<tr>
<td>Buffer</td>
<td>缓冲区大小默认是8kb</td>
</tr>
<tr>
<td>构造</td>
<td>FileWriter(File file) 使用File对象来构造FileWriter<br/>FileWriter(File file, boolean append) append为true时，往末尾追加<br/>FileWriter(String fileName) 使用文件路径名来创建FileWriter对象<br/>FileWriter(String fileName, boolean append) append为true时，往末尾追加</td>
</tr>
<tr>
<td>方法</td>
<td>void flush() 刷新流。<br/>String getEncoding() 返回此流使用的字符编码的名称。<br/>void write(char[] cbuf, int off, int len) 写入字符数组的一部分。<br/>void write(int c) 写一个字符<br/>void write(String str, int off, int len) 写一个字符串的一部分。<br/>void close() 关闭流</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th>FileReader</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>字符输入流</td>
</tr>
<tr>
<td>Buffer</td>
<td>没有自带的缓冲区，当读取完毕后，会返回-1</td>
</tr>
<tr>
<td>构造</td>
<td>FileReader(String fileName) 创建一个新的 FileReader ，给定要读取的文件的名称。<br/>FileReader(File file) 创建一个新的 FileReader ，给出 File 读取。</td>
</tr>
<tr>
<td>方法</td>
<td>void close() 关闭流并释放与之相关联的任何系统资源。<br/>String getEncoding() 返回此流使用的字符编码的名称。<br/>int read() 读一个字符<br/>int read(char[] cbuf, int offset, int length) 将字符读入数组的一部分。<br/>boolean ready() 告诉这个流是否准备好被读取。</td>
</tr>
</tbody></table>
<h4 id="处理字节文件，流的底层实现类"><a href="#处理字节文件，流的底层实现类" class="headerlink" title="处理字节文件，流的底层实现类"></a><strong>处理字节文件，流的底层实现类</strong></h4><table>
<thead>
<tr>
<th></th>
<th>FileOutputStream</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>字节输出流</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>构造</td>
<td>FileOutputStream(File file) 使用File对象来构造FileWriter<br/>FileOutputStream(File file, boolean append) append为true时，往末尾追加<br/>FileOutputStream(String fileName) 使用文件路径名来创建FileWriter对象<br/>FileOutputStream(String fileName, boolean append) append为true时，往末尾追加</td>
</tr>
<tr>
<td>方法</td>
<td>void write(byte[] b, int off, int len) 将 len 字节从位于偏移量 off 的指定字节<br/>数组写入此文件输出流。<br/>void write(int b) 将指定的字节写入此文件输出流。<br/>void write(byte[] b) 将 b.length 个字节从指定的字节数组写入此文件输出流。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th>FileInputStream</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>字节输入流</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>构造</td>
<td>FileInputStream(File file) 通过打开与实际文件的连接创建一个 FileInputStream ，该文件由文件系统中的 File 对象 file 命名。<br/>FileInputStream(String name) 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name 命名。</td>
</tr>
<tr>
<td>方法</td>
<td>int read(byte[] b) 从该输入流读取最多 b.length 个字节的数据为字节数组。<br/>int read(byte[] b, int off, int len) 从该输入流读取最多 len 字节的数据为字节数组。<br/>long skip(long n) 跳过并从输入流中丢弃 n 字节的数据。<br/>int read() 从该输入流读取一个字节的数据。</td>
</tr>
</tbody></table>
<h4 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h4><ul>
<li><p>对象流：有的时候，我们可能需要将内存中的对象持久化到硬盘上，或者将硬盘中的对象信息读到内存中，这个时候我们需要使用对象输入输出流。</p>
</li>
<li><p>序列化： 是将对象转换成一个字节序列的过程，是一个写操作,做永久保存</p>
</li>
<li><p>反序列化: 将字节序列转换成对象的过程 ，是一个读操作</p>
</li>
<li><p>说明</p>
<blockquote>
<ol>
<li>对象如果要支持序列化，需要实现Serializable标志接口</li>
<li>对象的静态属性不会被序列化</li>
<li>transient修饰的成员属性不会被序列化</li>
<li>serialVersionUID序列化版本号，在序列化前会根据类中的属性和方法来计算出一个版本号，随着对象一起序列化，在反序列化之前也会根据类中的属性和方法来计算一个版本号，根据前后两个版本号进行比对，如果对比结果一致，则反序列化成功，结果不一致，反序列化会失败</li>
<li>如果自己提供了版本号，java就不会计算版本号，进行版本号的比对</li>
<li>集合和映射对象都不能直接序列化，如果要序列化，需遍历集合中的元素依次进行序列化</li>
<li>如果要序列化多个对象（在一个文件中）<ul>
<li>方法1：<br>  在序列化结束时，需多写一个null值，在反序列化时，读取到null结束，可以避免EOFException</li>
<li>方法2：<br>  可以将多个对象存储在数组中，对数组进行序列化，达到序列化多个对象的目的（见第6点）</li>
</ul>
</li>
</ol>
</blockquote>
</li>
<li><p>实现类</p>
<ul>
<li>ObjectOutputStream<ul>
<li>构造： ObjectOutputStream(OutputStream out) 创建一个写入指定的OutputStream的ObjectOutputStream。</li>
<li>方法：void writeObject(Object obj) 将指定的对象写入ObjectOutputStream</li>
</ul>
</li>
<li>ObjectInputStream<ul>
<li>构造：ObjectInputStream(InputStream in) 创建从指定的InputStream读取的ObjectInputStream。</li>
<li>方法：Object readObject() 从ObjectInputStream读取一个对象。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>缓冲流 &amp; 转换流 &amp; 打印流 &amp; 系统流 略</p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>原子性是指<strong>操作是不可分的</strong>，要么全部一起执行，要么不执行。在java中，其表现在对于共享变量的某些操作，是不可分的，必须连续的完成。比如a++，对于共享变量a的操作，实际上会执行3个步骤：</p>
<p>1.读取变量a的值，假如a&#x3D;1<br>2.a的值+1，为2<br>3.将2值赋值给变量a，此时a的值应该为2</p>
<p>这三个操作中任意一个操作，a的值如果被其他线程篡改了，那么都会出现我们不希望出现的结果。所以必须保证这3个操作是原子性的，在操作a++的过程中，其他线程不会改变a的值，如果在上面的过程中出现其他线程修改了a的值，在满足原子性的原则下，上面的操作应该失败。</p>
<p>java中实现原子操作的方法大致有2种：<strong>锁机制</strong>、<strong>无锁CAS机制</strong></p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p>
<p><strong>进程具有的特征：</strong></p>
<ul>
<li><strong>动态性</strong>：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的</li>
<li><strong>并发性</strong>：任何进程都可以同其他进行一起并发执行</li>
<li><strong>独立性</strong>：进程是系统进行资源分配和调度的一个独立单位</li>
<li><strong>结构性</strong>：进程由程序，数据和进程控制块三部分组成</li>
</ul>
]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven阶段二</title>
    <url>/posts/897ba3f0/</url>
    <content><![CDATA[<p>概述：Maven在IDEA中使用</p>
<span id="more"></span>

<p><strong>Maven在IDEA中的版本兼容型</strong>:</p>
<p>查找发布时间在IDEA版本之前的  <a href="http://maven.apache.org/docs/history.html">Link01</a></p>
<p>下载指定版本MAVEN<a href="https://archive.apache.org/dist/maven/maven-3/">Link02</a></p>
<h1 id="创建父工程"><a href="#创建父工程" class="headerlink" title="创建父工程"></a>创建父工程</h1><p>创建一个Project —-&gt; 选择Maven —-&gt; 配置名字和坐标 —-&gt; 注意Maven版本问题</p>
<p>配置Maven信息：setting —-&gt; build —-&gt; Maven</p>
<h1 id="创建Java模块工程"><a href="#创建Java模块工程" class="headerlink" title="创建Java模块工程"></a>创建Java模块工程</h1><p>右键父工程标题new  —-&gt; module  —-&gt; 配置名字  —-&gt; 在main目录下写Java源代码  —-&gt;在test目录下写Java测试代码  —-&gt; 直接在testJava中直接运行（最右边上有Maven，进行命令行操作）</p>
<h1 id="创建web模块工程"><a href="#创建web模块工程" class="headerlink" title="创建web模块工程"></a>创建web模块工程</h1><p>右键父工程标题new  —-&gt; module  —-&gt; 配置名字  —-&gt;在pom.xml文件中添加<code>&lt;packaging&gt;war&lt;/packaging&gt;</code></p>
<p>File  —-&gt;  project Structure —-&gt;  Facets —-&gt; 添加该子工程（模块）</p>
<p>在Deployment Descriptors中修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\Maven_workspace\space\父工程名\子工程名\src\main\webapp\WEB-INF\web.xml</span><br></pre></td></tr></table></figure>

<p>在Web Resource Directories中修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\Maven_workspace\space\父工程名\子工程名\src\main\webapp</span><br></pre></td></tr></table></figure>



<h1 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h1><h2 id="工程导入"><a href="#工程导入" class="headerlink" title="工程导入"></a>工程导入</h2><p>从GitHub中参与项目时</p>
<p>（待补充）</p>
<h2 id="来自工程目录"><a href="#来自工程目录" class="headerlink" title="来自工程目录"></a>来自工程目录</h2><p>本地有相应的目录但没有导入进IDEA中</p>
<ul>
<li>导入后都需要配置本地的Maven</li>
<li>Java<ul>
<li>Project Structure —-&gt; Modules —-&gt; 添加 —-&gt; Import module from external model —-&gt; Maven</li>
</ul>
</li>
<li>Web<ul>
<li>Project Structure —-&gt; Modules —-&gt; 添加 —-&gt; Import module from external model —-&gt; Maven</li>
<li>Facets —-&gt; 添加 —-&gt; 在Deployment Descriptors中修改 —-&gt; 在Web Resource Directories中修改</li>
</ul>
</li>
</ul>
<h1 id="部分核心概念"><a href="#部分核心概念" class="headerlink" title="部分核心概念"></a>部分核心概念</h1><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>为了让构建过程自动化完成，Maven 设定了三个生命周期，生命周期中的每一个环节对应构建过程中的一个操作。</p>
<h3 id="三个生命周期"><a href="#三个生命周期" class="headerlink" title="三个生命周期"></a>三个生命周期</h3><table>
<thead>
<tr>
<th>生命周期名称</th>
<th>作用</th>
<th>各个环节</th>
</tr>
</thead>
<tbody><tr>
<td>Clean</td>
<td>清理操作相关</td>
<td>pre-clean clean post-clean</td>
</tr>
<tr>
<td>Site</td>
<td>生成站点相关</td>
<td>pre-site site post-site deploy-site</td>
</tr>
<tr>
<td>Default</td>
<td>主要构建过程</td>
<td>validate generate-sources process-sources generate-resources process-resources 复制并处理资源文件，至目标目录，准备打包。 compile 编译项目 main 目录下的源代码。 process-classes generate-test-sources process-test-sources generate-test-resources process-test-resources 复制并处理资源文件，至目标测试目录。 test-compile 编译测试源代码。 process-test-classes test 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。 prepare-package package 接受编译好的代码，打包成可发布的格式，如JAR。 pre-integration-test integration-test post-integration-test verify install将包安装至本地仓库，以让其它项目依赖。 deploy将最终的包复制到远程的仓库，以让其它开发人员共享；或者部署到服务器上运行（需借助插件，例如：cargo）。</td>
</tr>
</tbody></table>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>前面三个生命周期彼此是独立的。</li>
<li>在任何一个生命周期内部，执行任何一个具体环节的操作，都是从本周期最初的位置开始执行，直到指定的地方。（本节记住这句话就行了，其他的都不需要记）</li>
</ul>
<p>Maven 之所以这么设计其实就是为了提高构建过程的自动化程度：让使用者只关心最终要干的即可，过程中的各个环节是自动执行的。</p>
<h2 id="插件和目标"><a href="#插件和目标" class="headerlink" title="插件和目标"></a>插件和目标</h2><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>Maven 的核心程序仅仅负责宏观调度，不做具体工作。具体工作都是由 Maven 插件完成的。例如：编译就是由 maven-compiler-plugin-3.1.jar 插件来执行的。</p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>一个插件可以对应多个目标，而每一个目标都和生命周期中的某一个环节对应。</p>
<p>Default 生命周期中有 compile 和 test-compile 两个和编译相关的环节，这两个环节对应 compile 和 test-compile 两个目标，而这两个目标都是由 maven-compiler-plugin-3.1.jar 插件来执行的。</p>
<h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><ul>
<li>本地仓库：在当前电脑上，为电脑上所有 Maven 工程服务</li>
<li>远程仓库：需要联网<ul>
<li>局域网：我们自己搭建的 Maven 私服，例如使用 Nexus 技术。</li>
<li>Internet<ul>
<li>中央仓库</li>
<li>镜像仓库：内容和中央仓库保持一致，但是能够分担中央仓库的负载，同时让用户能够就近访问提高下载速度，例如：Nexus aliyun</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>建议：不要中央仓库和阿里云镜像混用，否则 jar 包来源不纯，彼此冲突。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux(CentOS)基础</title>
    <url>/posts/53d0684b/</url>
    <content><![CDATA[<p><strong>概述：</strong>Linux-CentOS基础操作</p>
<span id="more"></span>

<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>人们规定1970-1-1是UNIX诞生的日期</p>
<h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><h3 id="Bridged-桥接"><a href="#Bridged-桥接" class="headerlink" title="Bridged-桥接"></a>Bridged-桥接</h3><p>主机网卡与虚拟机虚拟的网卡利用虚拟网桥进行通信。</p>
<blockquote>
<p>类似于把物理主机虚拟为一个交换机， 虚拟机和物理主机一起连接到这个交换机上（网卡是交换模式，即相互访问而互不干扰）</p>
<p>同一网段</p>
</blockquote>
<p>特点： </p>
<p>1· 容易和局域网中的其他主机ip地址冲突</p>
<p>2· ip资源紧张不建议使用该模式</p>
<h3 id="NAT-地址转换"><a href="#NAT-地址转换" class="headerlink" title="NAT- 地址转换"></a>NAT- 地址转换</h3><p>解决上述的ip问题， 但局域网中的其他主机无法访问</p>
<h3 id="Host-Only"><a href="#Host-Only" class="headerlink" title="Host-Only"></a>Host-Only</h3><p>只与主机相互通讯，虚拟机为独立的系统</p>
<h3 id="常用网络设置命令"><a href="#常用网络设置命令" class="headerlink" title="常用网络设置命令"></a>常用网络设置命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">reboot #重启主机</span><br><span class="line"></span><br><span class="line">systemctl restart network.service #重启网卡</span><br><span class="line"></span><br><span class="line">ip addr ifconfig #查看IP地址</span><br><span class="line"></span><br><span class="line">ping #检测网络是否通畅</span><br><span class="line"></span><br><span class="line">ctrl+c #结束ping命令</span><br><span class="line"></span><br><span class="line">clear,clear+l #清屏</span><br></pre></td></tr></table></figure>



<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>根目录(利用 &#x2F; 表示)：Linux系统的起点（所有的数据都在此目录下)</p>
<p><strong>文件名颜色的含义</strong>:<br>默认色代表普通文件。例：install.log<br>绿色代表可执行文件。例：rc.news<br>红色代表tar包文件。    例：vim-7.1.tar.bz2<br>蓝色代表目录文件。   例：aa<br>水红代表图象文件。   例：Sunset.jpg<br>青色代表链接文件。   例：rc4.d  （此类文件相当于快捷方式）<br>黄色代表设备文件。   例：fd0</p>
<h2 id="基础命令操作"><a href="#基础命令操作" class="headerlink" title="基础命令操作"></a>基础命令操作</h2><p><strong>唤出快捷键</strong>：</p>
<p>虚拟控制台切换(Ctrl+Alt+Fn组合键)<br>ctrl+alt+F1:图形桌面<br>ctrl+alt+F2~F6:字符控制台</p>
<p><strong>命令行</strong> ：</p>
<p>提示行：[root@localhost ~]#<br>[当前登录的用户@主机名 当前所在的位置] #</p>
<ul>
<li><p>以#结尾：超级管理员root</p>
</li>
<li><p>以$结尾：普通用户</p>
</li>
</ul>
<p><strong>切换用户</strong>（CentOS）：<br>su [用户名]<br>su - [用户名]</p>
<p><strong>基础命令</strong> ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">command [-option][parameter1,parameter...]</span><br><span class="line">命令【选项】【参数】</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">-option是命令的选项，分为长选项和短选项， - 是短选项, -- 是长选项，例</span><br><span class="line">如： -S,-h,--size,--help</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd [目标·的位置]</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">/ 切换到根目录</span><br><span class="line">.. 回到上一级目录</span><br><span class="line">. 当前目录</span><br><span class="line">- 显示并打开到上一次操作的目录</span><br><span class="line">~ 当前用户的宿主目录（eg:# cd ~用户名 进入某个用户的家目录）</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls [目录]</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">-a(all) 显示所有文件和目录，包括隐藏文件，隐藏文件是文件名</span><br><span class="line">以 &quot;.&quot; 开始的文件</span><br><span class="line">-l (long ) 显示详细信息</span><br><span class="line">-R（recursive） 递归显示当前目录下所有目录</span><br><span class="line">-r (reverse) 逆序排序</span><br><span class="line">-t（time） 按修改时间排序（降序）</span><br><span class="line">ll 相当于 ls –l</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pwd</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">-L 显示链接路径，当前路径，默认使用的是这个</span><br><span class="line">-P 物理路径</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat [filename]</span><br><span class="line">cat &gt;[filename]</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">-A 显示所有内容，包括隐藏的字符</span><br><span class="line">-n 显示行号</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">less [filename]</span><br><span class="line">more [filename]</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">空格或b:显示下一页，enter键 显示下一行，q或Q退出</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">head [filename]</span><br><span class="line">tail [filename]</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">-n 指定行数</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch </span><br><span class="line">---------------------------------------------------------</span><br><span class="line">touch  a.txt  b.txt  </span><br><span class="line">touch &#123;a.txt，b.txt&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir [directories_name]</span><br><span class="line">rmdir [directories_name]</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">-p -p 父目录不存在情况下先生成父目录 （parents）</span><br><span class="line">-p 递归删除子目录</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp</span><br><span class="line">cp 1.txt 2.txt 3.txt /home/wushun/test2/</span><br><span class="line">cp test2 -r test3</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">-r -R recursive 递归处理，复制目录</span><br><span class="line">-p 保留文件属性 （原文件的时间不变）</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将文件test.log重命名为test1.txt</span></span><br><span class="line">mv test.log test1.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将test1.txt文件移到目录test3中</span></span><br><span class="line">mv test1.txt test3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将文件log1.txt,log2.txt,log3.txt移动到目录test3中。</span></span><br><span class="line">mv log1.txt log2.txt log3.txt test3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将文件file1改名为file2，如果file2已经存在，则询问是否覆盖</span></span><br><span class="line">mv -i log1.txt log2.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将文件file1改名为file2，即使file2存在，也是直接覆盖掉</span></span><br><span class="line">mv -f log3.txt log2.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果目录dir2不存在，将目录dir1改名为dir2；否则，将dir1移动到dir2中。</span></span><br><span class="line">mv dir1 dir2</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">常用</span></span><br><span class="line">rm -rf [filname]</span><br></pre></td></tr></table></figure>

<h2 id="VIM基本操作"><a href="#VIM基本操作" class="headerlink" title="VIM基本操作"></a>VIM基本操作</h2><p><strong>命令模式</strong> ：esc键退出</p>
<p><strong>输入模式</strong> ： 输入命令i、附加命令a、打开命令o、修改命令c、取代命令r或替换命令s</p>
<p><strong>编辑模式（末行模式）</strong>： “：”键即可进</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">set</span> <span class="keyword">nu</span> 				设置行号</span><br><span class="line">:<span class="keyword">set</span> nonu 				取消行号</span><br><span class="line">ggG 					到第一行到最后一行</span><br><span class="line">nG 						到第n行</span><br><span class="line">:n 						到第n行</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">:<span class="keyword">w</span> 						保存修改</span><br><span class="line">new_filename			另存为指定文件</span><br><span class="line">:<span class="keyword">w</span> &gt;&gt; <span class="keyword">a</span>.txt 			内容追加到<span class="keyword">a</span>.txt文件中 文件需存在</span><br><span class="line">:<span class="keyword">wq</span> 					保存修改并退出</span><br><span class="line">shift+zz（ZZ） 			快捷键，保存修改并退出</span><br><span class="line">:q! 					不保存修改退出</span><br><span class="line">:wq!					保存修改并退出（文件所有者可忽略文件的只读属性）</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">yy、Y 					复制当前行</span><br><span class="line">nyy、nY 					复制当前行以下n行</span><br><span class="line">dd 						 剪切当前行</span><br><span class="line">ndd 					 剪切当前行以下n行</span><br><span class="line"><span class="keyword">p</span>、<span class="keyword">P</span>     			    粘贴在当前光标所在行下 或行上</span><br></pre></td></tr></table></figure>



<h2 id="文档归档与解压缩"><a href="#文档归档与解压缩" class="headerlink" title="文档归档与解压缩"></a>文档归档与解压缩</h2><h3 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gzip[参数][文件或者目录]</span><br><span class="line"></span><br><span class="line">多出&quot;.gz&quot;的扩展名。</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">-c 将压缩数据输出到标准输出中，保留源文件</span><br><span class="line">-d 对压缩文件进行解压缩。</span><br><span class="line">-r 递归压缩指定目录下以及子目录下的所有文件。</span><br><span class="line">-v 对于每个压缩和解压缩的文件，显示相应的文件名和压缩比。</span><br><span class="line">-n(n表示数字)</span><br><span class="line">	用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比</span><br><span class="line">最高。默认压缩比是 -6。</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">#不保留原文件的压缩</span><br><span class="line">gzip 1.txt</span><br><span class="line">#保留原文件的压缩</span><br><span class="line">gzip -c 1.txt&gt;1.txt.gz</span><br><span class="line">#不保留源文件的解压</span><br><span class="line">gunzip 1.txt.gz</span><br><span class="line">gzip -d 345.txt.gz</span><br><span class="line">#保留源文件的解压</span><br><span class="line">gunzip -c 1.txt.gz&gt;4.txt</span><br></pre></td></tr></table></figure>

<h3 id="bzip"><a href="#bzip" class="headerlink" title="bzip"></a>bzip</h3><p>略</p>
<h3 id="tar-打包"><a href="#tar-打包" class="headerlink" title="tar-打包"></a>tar-打包</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar[参数][文件或者目录]</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">-c 建立一个压缩文件的参数指令（create），后缀是.tar</span><br><span class="line">-x 解开一个压缩文件的参数指令（extract）</span><br><span class="line">-z 以gzip命令压缩/解压缩</span><br><span class="line">-j 以bzip2命令压缩/解压缩</span><br><span class="line">-v 压缩的过程中显示文件（verbose）</span><br><span class="line">-f 指定文件名,必选项</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">#打包</span><br><span class="line">tar -cf test.tar 1.txt 2.txt 3.txt</span><br><span class="line">#解包，f参数必须放在后面</span><br><span class="line">tar -xzf test.tar</span><br><span class="line">#解压缩并解包</span><br><span class="line">tar -zcvf test.tar.gz *.txt</span><br><span class="line">tar -zxvf test.tar.gz</span><br><span class="line">#解压至指定路径，路径需存在</span><br><span class="line">tar -zxvf test.tar.gz test </span><br></pre></td></tr></table></figure>



<h2 id="重定向与管道"><a href="#重定向与管道" class="headerlink" title="重定向与管道"></a>重定向与管道</h2><h3 id="gt-gt-gt"><a href="#gt-gt-gt" class="headerlink" title="(&gt;, &gt;&gt;)"></a>(&gt;, &gt;&gt;)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 覆盖重定向</span><br><span class="line">&gt;&gt; 追加重定向</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title="(  |  )"></a>(  |  )</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">显示/etc/passwd文件内容的8到12行</span></span><br><span class="line">head -n 12 /et/passwd | tail -n 5</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">显示/etc/passwd文件内容的8到12内容,打印行号</span></span><br><span class="line">head -n 12 /et/passwd | tail -n 5 | cat -n</span><br></pre></td></tr></table></figure>



<h2 id="文本查找与搜索"><a href="#文本查找与搜索" class="headerlink" title="文本查找与搜索"></a>文本查找与搜索</h2><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>过滤文本文件内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-n 输出行数</span><br><span class="line">-w 精确匹配</span><br><span class="line">-i 忽略大小写</span><br><span class="line">-v 反向选择</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看/etc/password 包含‘root’的信息</span></span><br><span class="line">grep root /etc/password</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看/etc/services 这个文件是是否包含 <span class="string">&#x27;init&#x27;</span>这个字符串，并输出行号</span></span><br><span class="line">grep init -n /etc/services</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输出不包含root的行</span></span><br><span class="line">grep  -v root /etc/passwd </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">忽略大小写</span></span><br><span class="line">grep -i man /etc/man_db.conf</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">^word 以字符串word开头</span></span><br><span class="line">grep ^root /etc/password</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">–word$ 以字符串word结尾</span></span><br><span class="line">grep bash$ /etc/password</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">过滤掉注释</span> </span><br><span class="line">grep -v ^# /etc/inittab</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">过滤文件信息</span> </span><br><span class="line">ll /etc | grep yum</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">里的|是一个管道符，意思就是把我们前面命令的结果当做后面命令的输入</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">显示配置文件中的有效配置(去除空行与注释行)</span></span><br><span class="line">grep ^# /etc/default/useradd | grep -v ^$</span><br></pre></td></tr></table></figure>

<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find [目录][条件1...]</span><br><span class="line"></span><br><span class="line">-type(f,d,l) 按类型 f:文本文件，d:目录，l:快捷方式</span><br><span class="line">-name 按名称</span><br><span class="line">-size(k、M、G) 按文件的大小来查找</span><br><span class="line">-user 按用户名来查找</span><br><span class="line">-mtime 按修改时间,都是过去的时间，单位是天</span><br><span class="line"></span><br><span class="line">#高级操作</span><br><span class="line">– find [范围] [条件] -exec 处理命令 &#123;&#125; \;</span><br><span class="line"></span><br><span class="line"> -exec：额外操作的开始，传递参数一次传递一个</span><br><span class="line">– &#123;&#125;：代表find查询的每一个结果</span><br><span class="line">– \; : 额外操作的结束</span><br><span class="line"></span><br><span class="line">#查找student用的所有文件及目录，并拷贝到/opt目录下</span><br><span class="line">find / -user student -exec cp &#123;&#125; /opt \;</span><br><span class="line">#查找boot目录中大于10M的文件，并拷贝到/optm</span><br><span class="line">find /boot/ -size  +10M  -exec  cp  &#123;&#125;   /opt   \;</span><br></pre></td></tr></table></figure>



<h2 id="RPM"><a href="#RPM" class="headerlink" title="RPM"></a>RPM</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ol>
<li><p>软件包   </p>
<p>&#x2F;dev&#x2F;sr0   #实际名字</p>
<p>&#x2F;dev&#x2F;cdrom  #快捷方式</p>
</li>
<li><p>mount命令进行挂载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">建立挂载目录/dvd</span><br><span class="line">mount  /dev/cdrom   /dvd</span><br><span class="line">umount /dvd </span><br><span class="line"></span><br><span class="line">专门挂载目录/mnt</span><br><span class="line">mount /dev/cdrom /mnt</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">命令格式：rpm -q[子选项] [软件名称]</span><br><span class="line">命令选项：</span><br><span class="line">-a： 列出已安装的所有软件包</span><br><span class="line">-i： 查看指定软件的详细信息</span><br><span class="line">-l： 查看指定软件的文件安装清单</span><br><span class="line">-p： 用于查询未安装的包</span><br><span class="line">-f： 查询指定的文件是由那个程序包安装生成的</span><br><span class="line"></span><br><span class="line"># 常用</span><br><span class="line">rpm -q vsftpd</span><br><span class="line"></span><br><span class="line"># 已安装</span><br><span class="line">rpm -qa | grep vim</span><br><span class="line">rpm -ql firefox  #显示软件的安装清单</span><br><span class="line">rpm -qi firefox  #显示软件的信息</span><br><span class="line"></span><br><span class="line"># 文件属于哪个软件</span><br><span class="line">rpm -qf /etc/passwd</span><br></pre></td></tr></table></figure>



<h3 id="常见的软件包"><a href="#常见的软件包" class="headerlink" title="常见的软件包"></a>常见的软件包</h3><p>源码包:</p>
<p>​	通常以.tar.gz,tar.bz2格式的压缩包提供包含程序的原始代码文件</p>
<p>deb软件包:</p>
<p>​	扩展名为.deb，适用于debian系列的linux</p>
<p>rpm软件包( 区别于Windows的分散安装):</p>
<p>​	扩展名为.rpm，适用于RedHat系列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">软件名-版本信息.操作系统.硬件架构.rpm</span><br><span class="line">firefox-52.7.0-1.el7.centos.x86_64.rpm</span><br></pre></td></tr></table></figure>

<h3 id="安装和卸载-rpm软件包"><a href="#安装和卸载-rpm软件包" class="headerlink" title="安装和卸载-rpm软件包"></a>安装和卸载-rpm软件包</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：rpm -i RPM包文件...</span><br><span class="line">辅助选项：</span><br><span class="line">-v： 显示细节信息</span><br><span class="line">-h： 以#号显示安装进度</span><br><span class="line">--force： 强制安装、覆盖安装</span><br><span class="line">--test： 测试安装，不做真实安装动作</span><br><span class="line"></span><br><span class="line">格式：rpm -e 软件包</span><br><span class="line">常用选项：</span><br><span class="line">--alimatches 卸载匹配所有指定名称的软件包的所有版本</span><br><span class="line">--nodeps 忽略依赖关系</span><br><span class="line">--test 测试卸载，不做真实卸载动作</span><br></pre></td></tr></table></figure>



<h2 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h2><p>解决依赖关系问题</p>
<p>服务端：</p>
<p>​	显示光盘的内容，挂载光驱设备</p>
<p>客户端：</p>
<p>​	书写客户端配置文件，指定服务器位置 &#x2F;etc&#x2F;yum.repos.d&#x2F;*.repo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">配置固定格式：</span><br><span class="line">[仓库名称] ：自定义名称，具有唯一性</span><br><span class="line">配置项=值</span><br><span class="line">示例1：</span><br><span class="line">baseurl=file:///file</span><br><span class="line">[iweb028]name=hahaxixi</span><br><span class="line">baseurl=file:///mnt</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0 #不检测红帽签名</span><br><span class="line"></span><br><span class="line">示例2：</span><br><span class="line">[iweb028]name=centos7</span><br><span class="line">baseurl=file:///mnt</span><br><span class="line">enabled=1gpg</span><br><span class="line">check=1</span><br><span class="line">gpgkey=file:///mnt/RPM-GPG-KEY-CentOS-7</span><br><span class="line"></span><br><span class="line">验证是否配置成功</span><br><span class="line">[root@localhost ~]# yum repolist #列出仓库的信息 </span><br></pre></td></tr></table></figure>

<p>流程：</p>
<pre><code>yum命令--&gt;/etc/yum.repos.d/*.repo--&gt;得到服务器的baseurl=file:///file
</code></pre>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">安装 yum install</span><br><span class="line">常用选项：</span><br><span class="line">-y： 自动安装 ，无需确认</span><br><span class="line">yum -y install  gcc</span><br><span class="line"></span><br><span class="line">卸载yum remove</span><br><span class="line">yum remove mariadb-server</span><br><span class="line"></span><br><span class="line">查询 yum list</span><br><span class="line">yum list bash</span><br><span class="line">yum search ftp   #模糊查询包含ftp即可</span><br><span class="line"></span><br><span class="line">清空yum的缓存</span><br><span class="line"> yum clean all </span><br><span class="line"> </span><br><span class="line">在你不知道具体包名时</span><br><span class="line">yum provides 想安装的软件名称 是由那个软件包提供，再安装这软件包即可</span><br></pre></td></tr></table></figure>



<h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><h3 id="用户账户"><a href="#用户账户" class="headerlink" title="用户账户"></a>用户账户</h3><p>唯一标识：UID(编号从0开始，默认最大值60000)，例如：zhangsan（UID1200）</p>
<ul>
<li>管理员root的UID:永远为0</li>
<li>普通用户的UID:默认从1000开始</li>
</ul>
<h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建： 命令useradd</span><br><span class="line">	– 格式：useradd [选项]... 用户名</span><br><span class="line">	•常用命令选项</span><br><span class="line">	-u： 指定 UID 标记号</span><br><span class="line">	-d： 指定宿主目录（家目录），缺省为 /home/用户名</span><br><span class="line">	-G： 指定所属的附加组,前提要存在</span><br><span class="line">	-s： 指定用户的登录解释器</span><br><span class="line"></span><br><span class="line">useradd -u 1400 iweb028</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改： 命令格式：usermod [选项]... 用户名</span><br><span class="line">	常用命令选项：</span><br><span class="line">	-l： 更改用户帐号的登录名称</span><br><span class="line">	-u： 用户id</span><br><span class="line">	-d： 家目录路径</span><br><span class="line">	-s： 登录解释器</span><br><span class="line">	-G： 附加组 //重置附加组</span><br><span class="line">	</span><br><span class="line">usermod -u 1600 abc3</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">设置密码：passwd [选项]... 用户名</span><br><span class="line">	</span><br><span class="line">passwd abc3</span><br><span class="line">echo 123  |  passwd --stdin abc3 #非交互式设置密码</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">删除： 格式：userdel [-r] 用户名</span><br><span class="line">添加 -r 选项，宿主目录/用户邮件也一并删除</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查询id： id 用户名</span><br></pre></td></tr></table></figure>



<h3 id="组账户"><a href="#组账户" class="headerlink" title="组账户"></a>组账户</h3><p>统一管理用户账户</p>
<ul>
<li>唯一标识：GID（编号从0开始，默认最大值60000），例如：sg(1500)</li>
<li>原则：linux一个用户必须至少属于一个组</li>
</ul>
<p>分类： </p>
<ul>
<li>基本组：由系统创建，与用户同名的组</li>
<li>附加组(从属组)：由管理员创建，由管理员管理组的成员</li>
</ul>
<h4 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">新建：groupadd iweb</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">管理：gpasswd [选项]... 组名</span><br><span class="line">-a： 添加组成员，每次只能加一个,追加组成员</span><br><span class="line">-d： 删除组成员，每次只能删一个</span><br><span class="line">-M： 定义组成员用户列表，可设置多个，会覆盖掉原有的组成员</span><br><span class="line">-A： 定义组管理员列表</span><br><span class="line"></span><br><span class="line">#将nb用户添加到stugrp</span><br><span class="line">gpasswd -a nb stugrp</span><br><span class="line">#批量添加组成员，会覆盖原来的成员</span><br><span class="line">gpasswd -M ‘jack,kenji’ stugrp  #定义组成员列表</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">删除： groupdel stugrp</span><br></pre></td></tr></table></figure>



<h3 id="本地账户的数据文件"><a href="#本地账户的数据文件" class="headerlink" title="本地账户的数据文件"></a>本地账户的数据文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/passwd #存放用户基本信息配置文件</span><br><span class="line">/etc/shadow #用户的密码信息</span><br><span class="line">/etc/group #存放用户组信息配置文件</span><br><span class="line">/etc/gshadow #组管理信息，组密码信息</span><br></pre></td></tr></table></figure>

<p>其中：基本信息配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# head -1 /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">用户名:密码占位符：uid：基本组gid:用户描述信息：家目录：解释器</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@192 bak]# grep abc3 /etc/shadow</span><br><span class="line">abc3:$6$BP6SlU52$NsojEjJUfkaBGkv9Cvr1mEAfW8ASrKWYaIlvwDPwRMl0PC</span><br><span class="line">ecvcLYoZVo0HoipFW2vlNxV2GiV1kUow3fdJ5QD1:18891:0:99999:7:::</span><br><span class="line">#18891 上一次修改密码的时间：自1970-1-1到达上一次修改密码的时间，所经历的天数</span><br><span class="line"></span><br><span class="line">字段1：用户帐号的名称</span><br><span class="line">字段2：加密后的密码字符串</span><br><span class="line">字段3：上次修改密码的时间</span><br><span class="line">字段4：密码的最短有效天数，默认0</span><br><span class="line">字段5：密码的最长有效天数，默认99999</span><br><span class="line">字段6：密码过期前的警告天数，默认7</span><br><span class="line">字段7：密码过期后多少天禁用此用户账号</span><br><span class="line">字段8：帐号失效时间，默认值为空</span><br><span class="line">字段9：保留字段（未使用）</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# grep stugrp /etc/group</span><br><span class="line">stugrp:x:1504:nsd06</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# grep stugrp /etc/gshadow</span><br><span class="line">stugrp:!:root:</span><br><span class="line">组名:密码加密字符串:组的管理员列表:组成员列表</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>linux-centOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven阶段一</title>
    <url>/posts/b2fb8d59/</url>
    <content><![CDATA[<p><strong>概述：</strong>Maven的基础</p>
 <span id="more"></span>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>直接在官网下载zip包</p>
<p>放在C盘的dev文件类（文件名没有中文和空格）</p>
<p>其中Maven的核心配置文件是：conf&#x2F;settings.xml</p>
<h2 id="配置本地仓库"><a href="#配置本地仓库" class="headerlink" title="配置本地仓库"></a>配置本地仓库</h2><p>找到本地仓库的注释：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- localRepository</span><br><span class="line">   | The path to the local repository maven will use to store artifacts.</span><br><span class="line">   |</span><br><span class="line">   | Default: $&#123;user.home&#125;/.m2/repository</span><br><span class="line">  &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</span><br><span class="line">  --&gt;</span><br></pre></td></tr></table></figure>

<p>然后设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;localRepository&gt;本机地址，不选C盘&lt;/localRepository&gt;</span><br></pre></td></tr></table></figure>



<h2 id="配置阿里云仓库"><a href="#配置阿里云仓库" class="headerlink" title="配置阿里云仓库"></a>配置阿里云仓库</h2><p>找到mirrors标签，注释（<code>&lt;!---&gt;</code>）原有的标签，然后添加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>        </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 注意在标签的内部</p>
<h2 id="配置Maven工程的基础JDK版本"><a href="#配置Maven工程的基础JDK版本" class="headerlink" title="配置Maven工程的基础JDK版本"></a>配置Maven工程的基础JDK版本</h2><p>找到profiles标签，然后添加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span>    </span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span>    </span><br><span class="line">	<span class="tag">&lt;<span class="name">activation</span>&gt;</span>    </span><br><span class="line">		<span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span>    </span><br><span class="line">		<span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span>    </span><br><span class="line">	<span class="tag">&lt;/<span class="name">activation</span>&gt;</span>    </span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span>    </span><br><span class="line">		<span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span>    </span><br><span class="line">		<span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span>    </span><br><span class="line">		<span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span>    </span><br><span class="line">	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>前提是配置好了Java环境</p>
<ul>
<li>配置MAVEN_HOME</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\dev\apache-maven-3.8.6</span><br></pre></td></tr></table></figure>

<ul>
<li>配置path</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%MAVEN_HOME%\bin</span><br></pre></td></tr></table></figure>

<ul>
<li>cmd检查</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn -v</span><br></pre></td></tr></table></figure>



<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="坐标："><a href="#坐标：" class="headerlink" title="坐标："></a><strong>坐标：</strong></h2><ul>
<li>groupId:组织ID<ul>
<li>通常是域名倒叙+项目名称</li>
</ul>
</li>
<li>artifactId:项目或者项目的模块ID<ul>
<li>Maven的工程名称</li>
</ul>
</li>
<li>version:版本号</li>
</ul>
<h2 id="坐标与本地仓库的存储路径关系："><a href="#坐标与本地仓库的存储路径关系：" class="headerlink" title="坐标与本地仓库的存储路径关系："></a><strong>坐标与本地仓库的存储路径关系：</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;servlet-api&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.0&lt;/version&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Maven本地仓库的根目录\javax\servlet\servlet-api\2.0\servlet-api-2.0.jar</span><br></pre></td></tr></table></figure>

<h2 id="三个目录："><a href="#三个目录：" class="headerlink" title="三个目录："></a><strong>三个目录：</strong></h2><ul>
<li>Maven的核心程序：<code>C:\dev\apache-maven-3.8.6</code></li>
<li>Maven本地仓库：<code>E:\maven-repository</code></li>
<li>本地工作空间：<code>D:\Maven_workspace</code></li>
</ul>
<h2 id="命令运行过程："><a href="#命令运行过程：" class="headerlink" title="命令运行过程："></a><strong>命令运行过程：</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">主命令 插件:目标</span><br></pre></td></tr></table></figure>

<p><code>mvn help:system</code></p>
<blockquote>
<ol>
<li>运行 mvn help:system 之后</li>
<li>系统会去环境变量 PATH 对应的所有目录中寻找 mvn 命令，然后在 D:\installsoft\maven\apache-maven-<br>3.6.2\bin 中找到了可执行的 mvn 文件</li>
<li>运行 mvn 文件，也就是执行 mvn 命令</li>
<li>通常一些软件启动的时候，会有一个启动配置文件， maven 也有， mvn 命令启动的时候会去 ~&#x2F;.m2 目录寻找配置文<br>件 settings.xml ，这个文件是 mvn 命令启动配置文件，可以对 maven 进行一些启动设置（如本地插件缓存放在什么<br>位置等等），若 ~&#x2F;.m2 目录中找不到 settings.xml 文件，那么会去 M2_HOME&#x2F;conf 目录找这个配置文件，然后<br>运行 maven 程序</li>
<li>mvn 命令后面跟了一个参数： help:sytem ，这个是什么意思呢？这个表示运行 help 插件，然后给 help 插件发<br>送 system 命令</li>
<li>maven 查看本地缓存目录（默认为 ~&#x2F;.m2 目录）寻找是否有 help 插件，如果本地没有继续下面的步骤</li>
<li>maven 会去默认的一个站点（ apache 为 maven 提供的一个网站 [repo.maven.apache.org] ，这个叫中央仓库）下载 help 插<br>件到 ~&#x2F;.m2 目录</li>
<li>运行 help 插件，然后给 help 插件发送 system 指令， help 插件收到 system 指令之后，输出了本地环境变量的信息，如<br>果系统找不到指定的插件或者给插件发送无法识别的命令，都会报错</li>
</ol>
</blockquote>
<p>注意：maven的主要逻辑运行主要靠插件提供，方便扩展</p>
<h2 id="工程中的配置文件pom-xml"><a href="#工程中的配置文件pom-xml" class="headerlink" title="工程中的配置文件pom.xml"></a><strong>工程中的配置文件pom.xml</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">标签含义：</span><br><span class="line">&lt;project 工程根标签</span><br><span class="line">&lt;modelVersion 固定的，pom.xml标签格式</span><br><span class="line"></span><br><span class="line">&lt;groupId 坐标信息</span><br><span class="line">&lt;artifactId</span><br><span class="line">&lt;version</span><br><span class="line">&lt;packaging 打包方式为jar包（java），war包（web），pom（管理其他工程的工程）</span><br><span class="line"></span><br><span class="line">&lt;properties 定义属性值</span><br><span class="line">	&lt;project.build.sourceEncoding 字符集</span><br><span class="line">	</span><br><span class="line">&lt;dependencies 依赖信息配置</span><br><span class="line">	&lt;scope 依赖的生效范围</span><br></pre></td></tr></table></figure>

<h2 id="POM"><a href="#POM" class="headerlink" title="POM"></a>POM</h2><p>全称：Project Object Model 项目对象模型 </p>
<p>模型化思想</p>
<p>对应的配置文件就是pom.xml</p>
<h2 id="约定的目录结构"><a href="#约定的目录结构" class="headerlink" title="约定的目录结构"></a>约定的目录结构</h2><p><img src="https://s2.loli.net/2022/06/24/Jyk62ApmRtYb3Ke.png" alt="目录结构"></p>
<h2 id="依赖查询网址"><a href="#依赖查询网址" class="headerlink" title="依赖查询网址"></a>依赖查询网址</h2><p><a href="https://mvnrepository.com/">Link</a></p>
<h1 id="命令行操作"><a href="#命令行操作" class="headerlink" title="命令行操作"></a>命令行操作</h1><h2 id="生成Java工程"><a href="#生成Java工程" class="headerlink" title="生成Java工程"></a>生成Java工程</h2><h3 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一"></a>步骤一</h3><p>在E盘创建一个工作空间<code>Maven_workspace\space01</code>，打开cmd</p>
<p>运行命令<code>mvn archetype:generate</code>，会先下载相应的包</p>
<p>下载完后，根据提示完成配置</p>
<hr>
<p>::: tip :::</p>
<p>Choose a number:7:默认</p>
<p>groupId:    <code>com.modishuriken.maven</code></p>
<p>artifactId:  <code>pro01-maven-java</code></p>
<p>version:默认即可</p>
<p>package:默认</p>
<p>Confirm:确定</p>
<hr>
<p>找到自己工程下的配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\Maven_workspace\space\pro01-maven-java\pom.xml</span><br></pre></td></tr></table></figure>

<p>更改dependencies中的junit的版本为4.12—-主要是在Java测试程序中使用注解</p>
<h3 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二"></a>步骤二</h3><p>添加Java代码</p>
<p>添加Java测试代码</p>
<h3 id="步骤三"><a href="#步骤三" class="headerlink" title="步骤三"></a>步骤三</h3><p>执行Maven的构建命令</p>
<p>运行构建相关的命令时，必须进入到pom.xml 所在的目录下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn clean &lt;!--删除target目录--&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn compile &lt;!--主程序编译--&gt;</span><br><span class="line">mvn test-compile &lt;!--测试程序编译--&gt;</span><br><span class="line"></span><br><span class="line">target/classes &lt;!--目录结构--&gt;</span><br><span class="line">target/test-classes &lt;!--测试目录结构--&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn test &lt;!--测试Java程序调用命令--&gt;</span><br><span class="line"></span><br><span class="line">测试结果日志</span><br><span class="line">D:\Maven_workspace\space\pro01-maven-java\target\surefire-reports</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn package  &lt;!--打包命令--&gt;</span><br><span class="line"></span><br><span class="line">在target目录下的jar包</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn install &lt;!--安装到本地仓库中--&gt;</span><br></pre></td></tr></table></figure>



<h2 id="生成web工程"><a href="#生成web工程" class="headerlink" title="生成web工程"></a>生成web工程</h2><p>目录结构：</p>
<p><img src="https://s2.loli.net/2022/06/24/CSrM5EegX6H8uYI.png" alt="web目录结果"></p>
<h3 id="步骤一-1"><a href="#步骤一-1" class="headerlink" title="步骤一"></a>步骤一</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn archetype:generate -DarchetypeGroupId=org.apache.maven.archetype -DarchetypeArtifaceId=maven-archetype-webapp -DarchetypeVersion=1.4</span><br></pre></td></tr></table></figure>

<p>::: tip</p>
<p>和Java的步骤相似</p>
<h3 id="步骤二-1"><a href="#步骤二-1" class="headerlink" title="步骤二"></a>步骤二</h3><p>创建servlet类</p>
<p>配置web.xml文件</p>
<p>编译</p>
<ul>
<li>配置依赖servlet-api.jar包</li>
<li>在pom.xml 中的依赖标签中</li>
<li>pom.xml 文件目录下进行cmd，输入<code>mvn compile</code></li>
</ul>
<h3 id="步骤三-1"><a href="#步骤三-1" class="headerlink" title="步骤三"></a>步骤三</h3><p>把target目录下的war包解压到tomcat下</p>
<p>运行tomcat</p>
<h2 id="web工程依赖Java工程"><a href="#web工程依赖Java工程" class="headerlink" title="web工程依赖Java工程"></a>web工程依赖Java工程</h2><ul>
<li>配置依赖本地的jar包</li>
<li>在pom.xml 中的依赖标签中</li>
</ul>
<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><h3 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h3><p>认识标签<code>&lt;scope&gt;</code></p>
<p>可选值：compile&#x2F;test&#x2F;provided&#x2F;system&#x2F;runtime&#x2F;import</p>
<table>
<thead>
<tr>
<th></th>
<th>mian</th>
<th>test</th>
<th>开发过程</th>
<th>部署到服务器</th>
</tr>
</thead>
<tbody><tr>
<td>compile</td>
<td>有效</td>
<td>有效</td>
<td>有效</td>
<td>有效</td>
</tr>
<tr>
<td>test</td>
<td>×</td>
<td>有效</td>
<td>有效</td>
<td>×</td>
</tr>
<tr>
<td>provided<br>服务器已经提供的</td>
<td>有效</td>
<td>有效</td>
<td>有效</td>
<td>×</td>
</tr>
</tbody></table>
<h3 id="依赖的传递"><a href="#依赖的传递" class="headerlink" title="依赖的传递"></a>依赖的传递</h3><p>可传递的compile</p>
<p>不可传递的test、provided</p>
<h3 id="依赖的排除"><a href="#依赖的排除" class="headerlink" title="依赖的排除"></a>依赖的排除</h3><p>含义：阻断依赖的传递</p>
<p>意义：版本冲突问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;pro01-maven-java&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">	&lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">	&lt;!-- 使用excludes标签配置依赖的排除	--&gt;</span><br><span class="line">	&lt;exclusions&gt;</span><br><span class="line">		&lt;!-- 在exclude标签中配置一个具体的排除 --&gt;</span><br><span class="line">		&lt;exclusion&gt;</span><br><span class="line">			&lt;!-- 指定要排除的依赖的坐标（不需要写version） --&gt;</span><br><span class="line">			&lt;groupId&gt;commons-logging&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</span><br><span class="line">		&lt;/exclusion&gt;</span><br><span class="line">	&lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>Maven工程之间的继承：</p>
<ul>
<li><p><strong>实质：</strong>工程中pom.xml配置的继承</p>
</li>
<li><p>管理子工程中的依赖版本问题</p>
</li>
<li><p>父工程创建同Java工程创建</p>
<ul>
<li>修改pom.xml中的<code>&lt;packaging&gt;</code>标签为pom</li>
<li>在父工程的根目录下，cmd 调用<code>mvn archetype:generate</code>来创建模块工程</li>
<li>父工程的pom.xml中多出的<code>&lt;modules&gt;</code> —–也是<strong>聚合</strong>的配置</li>
</ul>
</li>
<li><p>父工程中统一管理依赖信息（管理，不代表子工程有相应的依赖）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Spring Cloud--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Hoxton.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>父工程配置好版本号后，子工程不用在写。若子工程写了，那么覆盖掉父工程版本。</p>
</li>
<li><p>自定义属性标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在properties标签中</span><br><span class="line">&lt;标签名&gt;标签值&lt;/标签名&gt;</span><br><span class="line"></span><br><span class="line">引用：$&#123;标签名&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>总聚合工程（父工程）的pom.xml中的<code>&lt;modules&gt;</code> —-聚合的配置</p>
<p>意义：方便安装（顺序）</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE 集合基础</title>
    <url>/posts/ee75c781/</url>
    <content><![CDATA[<p>概述：集合基础</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|----Collection接口：单列集合，用来存储一个一个的对象</span><br><span class="line">     |----List接口：存储有序的、可重复的数据。  --&gt;“动态”数组</span><br><span class="line">           |----ArrayList：作为List接口的主要实现类，线程不安全的，效率高;底层采用Object[] elementData数组存储</span><br><span class="line">           |----LinkedList：对于频繁的插入删除操作，使用此类效率比ArrayList效率高底层采用双向链表存储</span><br><span class="line">           |----Vector：作为List的古老实现类，线程安全的，效率低;底层采用Object[]数组存储</span><br><span class="line">           </span><br><span class="line">     |----Set接口：存储无序的、不可重复的数据   --&gt;数学概念上的“集合”</span><br><span class="line">           |----HashSet：作为Set接口主要实现类;线程不安全;可以存null值(底层hashmap=哈希表)</span><br><span class="line">           		|----LinkedHashSet：作为HashSet的子类;遍历其内部数据时，可以按照添加顺序遍历;对于频繁的遍历操作，LinkedHashSet效率高于HashSet.</span><br><span class="line">           |----TreeSet：可以按照添加对象的指定属性，进行排序。(底层treemap=二叉树;上层SortedSet)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">|----Map:双列数据，存储key-value对的数据   ---类似于高中的函数：y = f(x)</span><br><span class="line">     |----HashMap:作为Map的主要实现类；线程不安全的，效率高；存储null的key和value</span><br><span class="line">          |----LinkedHashMap:保证在遍历map元素时，可以照添加的顺序实现遍历。</span><br><span class="line">                    原因：在原的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。对于频繁的遍历操作，此类执行效率高于HashMap。</span><br><span class="line">     |----TreeMap:保证照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序，底层使用红黑树(上层SortedMap)</span><br><span class="line">     |----Hashtable:作为古老的实现类；线程安全的，效率低；不能存储null的key和value</span><br><span class="line">          |----Properties:常用来处理配置文件。key和value都是String类型</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="Collection-lt-interface-gt"><a href="#Collection-lt-interface-gt" class="headerlink" title="Collection&lt;interface&gt;"></a>Collection<code>&lt;interface&gt;</code></h1><ul>
<li>从JDK 5.0增加了泛型以后，Java集合可以记住容器中对象的数据类型。</li>
<li>常用方法参见<a href="https://docs.oracle.com/javase/8/docs/api/index.html">Overview (Java Platform SE 8 )</a> 官方API文档</li>
<li>在使用泛型的时候，注意重写equals方法</li>
</ul>
<h1 id="Iterator-lt-interface-gt"><a href="#Iterator-lt-interface-gt" class="headerlink" title="Iterator&lt;interface&gt;"></a>Iterator<code>&lt;interface&gt;</code></h1><ul>
<li>迭代器模式：提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。<ul>
<li>从集合对象的iterator方法中获取迭代器对象Iterator</li>
</ul>
</li>
<li>集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。</li>
<li>常用方法<code>hasNext() &amp; next() &amp; remove()</code><ul>
<li>如果**还未调用next()**或在**上一次调用 next 方法之后已经调用了 remove 方法**，再调用remove都会报IllegalStateException。</li>
<li>内部定义了remove(),可以在遍历的时候，删除集合中的元素。此方法不同于集合直接调用remove()</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line"><span class="comment">//删除集合中&quot;Tom&quot;</span></span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;Tom&quot;</span>.equals(obj))&#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="List-lt-interface-gt"><a href="#List-lt-interface-gt" class="headerlink" title="List&lt;interface&gt;"></a>List<code>&lt;interface&gt;</code></h2><ul>
<li>数组的常用替代</li>
<li>元素有序、且可重复<ul>
<li>每个元素都有其对应的顺序索引</li>
<li>有序：存储顺序，不是排序</li>
</ul>
</li>
<li>相对Collection接口增加的方法（具体参见API文档）</li>
</ul>
<table>
<thead>
<tr>
<th>function</th>
<th>describe</th>
</tr>
</thead>
<tbody><tr>
<td>void add(int index, Object ele)</td>
<td>在index位置插入ele元素</td>
</tr>
<tr>
<td>boolean addAll(int index, Collection eles)</td>
<td>从index位置开始将eles中的所有元素添加进来</td>
</tr>
<tr>
<td>Object get(int index)</td>
<td>获取指定index位置的元素</td>
</tr>
<tr>
<td>int indexOf(Object obj)</td>
<td>返回obj在集合中首次出现的位置</td>
</tr>
<tr>
<td>int lastIndexOf(Object obj)</td>
<td>返回obj在当前集合中末次出现的位置</td>
</tr>
<tr>
<td>Object remove(int index)</td>
<td>移除指定index位置（0是第一个元素）的元素，并返回此元素</td>
</tr>
<tr>
<td>Object set(int index, Object ele)</td>
<td>设置指定index位置的元素为ele</td>
</tr>
<tr>
<td>List subList(int fromIndex, int toIndex)</td>
<td>返回从fromIndex到toIndex位置的子集合</td>
</tr>
</tbody></table>
<h3 id="ArrayList-lt-Class-gt"><a href="#ArrayList-lt-Class-gt" class="headerlink" title="ArrayList&lt;Class&gt;"></a>ArrayList<code>&lt;Class&gt;</code></h3><p>三个构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ArrayList()构造一个初始容量为 10 的空列表</span></span><br><span class="line">List&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//ArrayList(int initialCapacity)构造一个具有指定初始容量的空列表。</span></span><br><span class="line">List&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ArrayList(Collection&lt;? extends E&gt; c)构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的</span></span><br><span class="line">List&lt;String&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list2);</span><br></pre></td></tr></table></figure>

<ul>
<li>JDK 1.8：ArrayList像懒汉式，一开始创建一个长度为0的数组，当添加第一个元素时再创建一个始容量为10的数组</li>
<li>Arrays.asList（…）方法返回的List集合，既不是 ArrayList实例，也不是Vector实例。Arrays.asList（…）返回值是一个固定长度的List集合</li>
</ul>
<h3 id="LinkedList-lt-Class-gt"><a href="#LinkedList-lt-Class-gt" class="headerlink" title="LinkedList&lt;Class&gt;"></a>LinkedList<code>&lt;Class&gt;</code></h3><ul>
<li>对于频繁的插入和删除元素操作，建议使用LinkedList类，效率更高</li>
<li>新增方法：<br>void addFirst(Object obj)，在链表头部插入一个元素<br>void addLast(Object obj)，在链表尾部添加一个元素<br>Object getFirst()，获取第一个元素<br>Object getlast)()，获取最后一个元素<br>Object removeFirst()，删除头，获取元素并删除<br>Object removeLast()删除尾</li>
<li>双向链表</li>
<li>非线程安全</li>
</ul>
<h3 id="Vector-lt-Class-gt"><a href="#Vector-lt-Class-gt" class="headerlink" title="Vector&lt;Class&gt;"></a>Vector<code>&lt;Class&gt;</code></h3><ul>
<li>线程安全</li>
<li>JDK 8.0中通过Vector()构造器创建对象时，底层都创建了长度为10的数组</li>
<li>扩容方面，默认扩容为原来的数组长度的2倍</li>
</ul>
<h2 id="Set-lt-interface-gt"><a href="#Set-lt-interface-gt" class="headerlink" title="Set&lt;interface&gt;"></a>Set<code>&lt;interface&gt;</code></h2><ul>
<li>是Collection的子接口，set接口没有提供额外的方法</li>
<li>无序不重复</li>
<li>引用数据类型需要重写equals方法</li>
</ul>
<h3 id="HashSet-lt-Class-gt"><a href="#HashSet-lt-Class-gt" class="headerlink" title="HashSet&lt;Class&gt;"></a>HashSet<code>&lt;Class&gt;</code></h3><ul>
<li>哈希表实现；底层是数组，初始为16，超过容量的0.75，将扩大原来的两倍</li>
<li>元素无序。</li>
<li>添加、删除操作时间复杂度都是O(1)</li>
<li>非线程安全</li>
<li>元素可以为null</li>
<li>相等的标准：<strong>两个对象通过hashCode()方法比较相等，并且两个对象的equals()方法返回值也相等</strong></li>
<li></li>
<li>元素添加过程： (先比较hashCode值，后比较equals)<ol>
<li>首先调用元素a所在类的hashCode()方法</li>
<li>如果此位置上没有其他元素，则元素a添加成功</li>
<li>如果此位置上有其他元素b，则比较元素a与元素b的hash值<ul>
<li>如果hash值不相同，则元素a添加成功。 —&gt;JDK 8.0 :原来的元素在数组中，指向元素a。（尾插法）</li>
<li>如果hash值相同，进而需要调用元素a所在类的equals()方法<ol>
<li>equals()返回true,元素a添加失败</li>
<li>equals()返回false,则元素a添加成功   —&gt;尾插法</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="LinkedHashSet-lt-Class-gt"><a href="#LinkedHashSet-lt-Class-gt" class="headerlink" title="LinkedHashSet&lt;Class&gt;"></a>LinkedHashSet<code>&lt;Class&gt;</code></h4><ul>
<li><p>是一个哈希表和链表的结合，且是一个双向链表</p>
</li>
<li><p>根据元素的hashCode值来决定元素的存储位置但它同时使用双向链表 维护元素的次序</p>
</li>
<li><p>插入是有序的，时间复杂度是O(1)：<strong>有序不重复</strong></p>
</li>
</ul>
<h3 id="TreeSet-lt-Class-gt"><a href="#TreeSet-lt-Class-gt" class="headerlink" title="TreeSet&lt;Class&gt;"></a>TreeSet<code>&lt;Class&gt;</code></h3><ul>
<li>是一个树结构(红黑树)</li>
<li>元素是有序的</li>
<li>添加、删除操作时间复杂度为O(log(n))</li>
<li>额外的方法</li>
</ul>
<blockquote>
<p>Comparator comparator():如果TreeSet采用了定制顺序，则该方法返回定制排序所使用的Comparator，如果TreeSet采用自然排序，则返回null；</p>
<p>Object first():返回集合中的第一个元素；</p>
<p>Object last():返回集合中的最后一个元素；</p>
<p>Object lower(Object e)：返回指定元素之前的元素。</p>
<p>Object higher(Object e)：返回指定元素之后的元素。</p>
<p>SortedSet subSet（Object fromElement，Object toElement）：返回此Set的子集合，含头不含尾；</p>
<p>SortedSet headSet(Object toElement)：返回此Set的子集，由小于toElement的元素组成；</p>
<p>SortedSet tailSet(Object fromElement)：返回此Set的子集，由大于fromElement的元素组成;</p>
</blockquote>
<ul>
<li>添加&amp;排序</li>
</ul>
<blockquote>
<p>1.向TreeSet中添加的数据，要求是相同类的对象。<br>2.两种排序方式：自然排序（实现Comparable接口） 和定制排序（Comparator）<br>    1)自然排序中，比较两个对象是否相同的标准为：compareTo()返回0，不再是equals()方法<br>    2)定制排序中，比较两个对象是否相同的标准为：compare()返回0，不再是equals()方法</p>
</blockquote>
<p>​		自然排序：<strong>实现Comparable接口</strong>		（按升序（默认情况）排列）</p>
<p>​						   —-&gt;自定义类(Person)中实现Comparable接口，并重写接口中的compareTo方法</p>
<p>​		定制排序：<strong>传入参数Comparator接口</strong></p>
<p>​						   —-&gt;将实现Comparator接口的实例作为形参传递给TreeSet的构造器</p>
<h1 id="Map-lt-interface-gt"><a href="#Map-lt-interface-gt" class="headerlink" title="Map&lt;interface&gt;"></a>Map<code>&lt;interface&gt;</code></h1><ul>
<li><p>Map与Collection并列存在。用于保存具有一一映射关系的数据:key-value</p>
</li>
<li><p><strong>存储结构</strong>：</p>
<ul>
<li>使用Set存储所的key —&gt; key所在的类要重写equals()和hashCode() </li>
<li>使用Collection存储所的value —&gt;value所在的类要重写equals()</li>
<li>一个键值对：key-value构成了一个Entry对象。<ul>
<li>无序的、不可重复的，使用Set存储所的entry</li>
</ul>
</li>
</ul>
</li>
<li><p>Map接口的常用方法</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中</span><br><span class="line"></span><br><span class="line">void putAll(Map m):将m中的所有key-value对存放到当前map中</span><br><span class="line"></span><br><span class="line">Object remove(Object key)：移除指定key的key-value对，并返回value</span><br><span class="line"></span><br><span class="line">void clear()：清空当前map中的所有数据</span><br><span class="line"></span><br><span class="line">Object get(Object key)：获取指定key对应的value</span><br><span class="line"></span><br><span class="line">boolean containsKey(Object key)：是否包含指定的key</span><br><span class="line"></span><br><span class="line">boolean containsValue(Object value)：是否包含指定的value</span><br><span class="line"></span><br><span class="line">int size()：返回map中key-value对的个数</span><br><span class="line"></span><br><span class="line">boolean isEmpty()：判断当前map是否为空</span><br><span class="line"></span><br><span class="line">boolean equals(Object obj)：判断当前map和参数对象obj是否相等</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历（没有提供迭代器，根据key或者value的存储结构，返回有迭代器的集合进行遍历）</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set keySet()：		返回所有key构成的Set集合</span><br><span class="line">Collection values()：返回所有value构成的Collection集合</span><br><span class="line">Set entrySet()：		返回所有key-value对构成的Set集合</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="HashMap-lt-class-gt"><a href="#HashMap-lt-class-gt" class="headerlink" title="HashMap&lt;class&gt;"></a>HashMap<code>&lt;class&gt;</code></h2><ul>
<li><p>new HashMap():底层没有创建一个长度为16的数组。放入值后才有</p>
</li>
<li><p>dk 8底层的数组是：Node[] —-&gt; hash\key\value\next</p>
</li>
<li><p>存储规则：</p>
<ol>
<li>调用key1所在类的hashCode()计算key1哈希值</li>
<li>如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功</li>
<li>如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，调用key1所在类的equals(key2)方法<ul>
<li>如果equals()返回false:此时key1-value1添加成功</li>
<li>如果equals()返回true:使用value1<strong>替换</strong>value2。</li>
</ul>
</li>
</ol>
</li>
<li><p>扩容：</p>
<ul>
<li>扩容为原来容量的2倍，并将原有的数据复制过来。</li>
<li>扩容之后，原数组中的数据必须重新计算其在新数组中的位置，并放进去（可能重新排序），这就是 resize。</li>
<li>加载因子：0.75</li>
<li>数组的长度大于64，且链表的长度超过8，链表会自动转换为红黑树<ul>
<li><strong>解释：</strong>当HashMapl中的其中一个链的对象个数如果达到了8个，此时如果 capacity没有达到64，那么HashMap会先扩容解决，如果已经达到了64，那么这个链会变成树，结点类型由Node变成 Tree Node类型。当然，如果当映射关系被移除后，下次resize方法时判断树的结点个数低于6个，也会把树再转为链表。</li>
</ul>
</li>
</ul>
</li>
<li><p>属性：       bucket：在这个数组中可以存放元素的位置我们称之为“桶”  —-&gt;散列桶</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DEFAULT_INITIAL_CAPACITY : 	HashMap的默认容量，16</span><br><span class="line">   DEFAULT_LOAD_FACTOR：		HashMap的默认加载因子：0.75</span><br><span class="line">   threshold：					扩容的临界值，= 容量*填充因子：16 * 0.75 =&gt; 12</span><br><span class="line">   TREEIFY_THRESHOLD：			Bucket中链表长度大于该默认值，转化为红黑树:JDK 8.0引入</span><br><span class="line">   MIN_TREEIFY_CAPACITY：		桶中的Node被树化时最小的hash表容量:64</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="LinkedHashMap-lt-class-gt"><a href="#LinkedHashMap-lt-class-gt" class="headerlink" title="LinkedHashMap&lt;class&gt;"></a>LinkedHashMap<code>&lt;class&gt;</code></h3><ul>
<li>LinkedHashMap继承于HashMap</li>
<li>LinkedHashMap内部提供了Entry，替换HashMap中的Node.</li>
<li>迭代顺序与Key-value对的插入顺序一致</li>
</ul>
<h2 id="TreeMap-lt-class-gt"><a href="#TreeMap-lt-class-gt" class="headerlink" title="TreeMap&lt;class&gt;"></a>TreeMap<code>&lt;class&gt;</code></h2><ul>
<li>排序<ul>
<li>自然排序： TreeMap的所有的Key必须实现Comparable接口，而且所有的Key应该是同一个类的对象，否则将会抛出ClasssCastEXception()</li>
<li>定制排序：创建 TreeMap时，传入一个 Comparator对象，该对象负责对TreeMap中的所有key进行排序。此时不需要Map的Key实现Comparable接口</li>
</ul>
</li>
</ul>
<h2 id="使用Properties读取配置文件"><a href="#使用Properties读取配置文件" class="headerlink" title="使用Properties读取配置文件"></a>使用Properties读取配置文件</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Properties：用来读取配置文件</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="comment">//读取配置文件方式一：此时的文件默认在当前的module下</span></span><br><span class="line"><span class="comment">//        FileInputStream fis1 = new FileInputStream(new File(&quot;jdbc1.properties&quot;));</span></span><br><span class="line"><span class="comment">//        pro.load(fis1);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取配置文件方式二：使用ClassLoader</span></span><br><span class="line">    <span class="comment">//配置文件默认识别为：当前module的src下</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoaderTest.class.getClassLoader();<span class="comment">//获取系统类加载器</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">fis2</span> <span class="operator">=</span> classLoader.getResourceAsStream(<span class="string">&quot;jdbc1.properties&quot;</span>);</span><br><span class="line">    pro.load(fis2);</span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;user=&quot;</span>+user+<span class="string">&quot;,password=&quot;</span>+password);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="Collections-lt-util-gt"><a href="#Collections-lt-util-gt" class="headerlink" title="Collections&lt;util&gt;"></a>Collections<code>&lt;util&gt;</code></h1><ol>
<li>排序</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reverse(List)：反转 List 中元素的顺序</span><br><span class="line">shuffle(List)：对 List 集合元素进行随机排序</span><br><span class="line">sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序</span><br><span class="line">sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</span><br><span class="line">swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查找&amp;替换</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素</span><br><span class="line">Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素</span><br><span class="line">Object min(Collection)</span><br><span class="line">Object min(Collection，Comparator)</span><br><span class="line">int frequency(Collection，Object)：返回指定集合中指定元素的出现次数</span><br><span class="line">void copy(List dest,List src)：将src中的内容复制到dest中</span><br><span class="line">boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值</span><br></pre></td></tr></table></figure>



<h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p><a href="https://blog.csdn.net/weixin_44630656/article/details/113456512">Link01</a></p>
]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle1</title>
    <url>/posts/f145fed6/</url>
    <content><![CDATA[<p><strong>概述：</strong>Oracle数据库的基础安装和用户使用的注意事项</p>
<span id="more"></span>

<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>Oracle Database 11g Express Edition</p>
<h2 id="安装注意事项"><a href="#安装注意事项" class="headerlink" title="安装注意事项"></a>安装注意事项</h2><ol>
<li>指定数据库口令： 用于SYS和SYSTEM数据库账户的密码设置，所以要记住。</li>
<li>网页客服端端口，会与tomcat的8080端口冲突</li>
<li>如果安装失败，先停掉侦听服务，再停掉Service服务，然后运行安装包，进行卸载</li>
</ol>
<h2 id="用户说明"><a href="#用户说明" class="headerlink" title="用户说明"></a>用户说明</h2><ol>
<li><p>Sys：超级用户，最高限权，具有sysdba角色，<strong>建立数据库</strong></p>
<blockquote>
<p>登录语句：sql&gt; conn sys&#x2F;sys as sysdba;</p>
</blockquote>
</li>
<li><p>System：管理员，具有sysoper角色</p>
<blockquote>
<p>登录语句：sql&gt; conn system&#x2F;manager;</p>
</blockquote>
</li>
<li><p>scott：普通用户，默认未解锁</p>
</li>
</ol>
<h2 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建</span><br><span class="line">sql&gt; create user 用户名 identified by 密码;</span><br><span class="line"></span><br><span class="line">修改</span><br><span class="line">sql&gt; alter user 用户名 identified by 密码;</span><br></pre></td></tr></table></figure>



<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>注意：oralce对权限管理比较严谨，普通用户之间也是默认不能互相访问的，需要互相授权。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sql&gt; grant create session to 用户名;		授予用户创建session的权限，即登陆权限。</span><br><span class="line">sql&gt; alter user 用户名 quota unlimited on USERS;	授予用户使用表空间的权限。</span><br><span class="line">sql&gt; grant create table to 用户名;			授予创建表的权限。</span><br><span class="line">sql&gt; grant drop any table to 用户名;		授予删除任意表的权限</span><br><span class="line">sql&gt; grant insert any table to 用户名;		授予向任意表中插入行的权限</span><br><span class="line">sql&gt; grant update any table to 用户名;		修改任意表中行的权限</span><br><span class="line"></span><br><span class="line">sql&gt; grant select on emp  to 用户名;		授予用户查看指定表的权限</span><br><span class="line">sql&gt; conn 用户名/密码;</span><br><span class="line">sql&gt; select * from scott.emp;				用户可以查看用户scott中的表emp;</span><br><span class="line">sql&gt; revoke select on emp from 用户名;		收回用户的查询权限</span><br><span class="line">sql&gt; revoke all on emp from 用户名;		收回用户的所有权限</span><br><span class="line"></span><br><span class="line">或者管理员登陆</span><br><span class="line">GRANT SELECT,DELETE,UPDATE,INSERT ON scott.emp TO wangcao ;</span><br><span class="line">GRANT ALL PRIVILEGES ON scott.emp to wangcao;</span><br></pre></td></tr></table></figure>

<h3 id="权限分类"><a href="#权限分类" class="headerlink" title="权限分类"></a>权限分类</h3><p>三类：系统权限、角色、对象权限</p>
<ul>
<li><p>系统权限：在11g中系统权限有200个,比如create table，UNLIMITED TABLESPACE等</p>
<blockquote>
<p>查询当前用户拥有的系统权限：select * from user_sys_privs; </p>
</blockquote>
</li>
<li><p>角色：一类权限的分组，不是很严格的系统可以授予开发用户CONNECT、RESOURCE角色权限</p>
<blockquote>
<p>DBA:该角色具有数据库所有的权限。<br>CONNECT:该角色具有连接数据库的权限，和create session的权限一样。<br>RESOURCE:该角色是应用程序开发角色，具有如下权限:</p>
<p>​					select * from dba_sys_privs where GRANTEE&#x3D;’RESOURCE’; </p>
</blockquote>
<blockquote>
<p>查询当前用户的角色：SELECT * FROM USER_ROLE_PRIVS; </p>
</blockquote>
</li>
<li><p>对象权限：其它拥有用户的对象的权限，包括：<br>SELECT,DELETE,UPDATE,ALTER,INSERT,INDEX,REFERENCES,FLASHBACK,DEBUG,QUERY REWRITE,</p>
<p>ON COMMIT REFRESH；</p>
<p>不包括：<strong>drop</strong></p>
<blockquote>
<p>查询当前用户拥有的对象权限：SELECT * FROM USER_TAB_PRIVS;</p>
<p>​														select * from session_privs;</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>博客建立</title>
    <url>/posts/78ed23a3/</url>
    <content><![CDATA[<p><strong>概述：</strong>基于于hexo和GitHub的个人博客</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">常用命令</span><br><span class="line">hexo clean</span><br><span class="line">|</span><br><span class="line">hexo g -d || hexo d -g</span><br><span class="line">| </span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><ol>
<li>准备安装包</li>
<li>next到默认编辑器，我先有notepad3，所以选择它为默认编辑器（有全局path）</li>
<li>next到<code>Let Git decide</code>，可以默认，也可以选mian</li>
<li>一直next到实验项，有<code>NEW</code>字样的，都不选</li>
<li>安装结束</li>
</ol>
<h3 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h3><ol>
<li>安装一直next即可，注意换安装路径</li>
<li>设置环境变量</li>
<li>打开安装目录，新建<code>node_global</code>和<code>node_cache</code> 两个文件夹</li>
<li>输入“cmd”，点击“以管理员身份运行”</li>
<li>在命令提示符窗口输入<code>npm config set prefix &quot;安装路径\node_global&quot;</code></li>
<li>接着输入<code>npm config set cache &quot;安装路径\node_cache&quot;</code></li>
<li>环境变量中设置：<ul>
<li>系统中：变量名为<code>NODE_PATH</code> ，变量值为<code>安装路径\node_global\node_modules</code> </li>
<li>用户Path中：更改<code>../Roaming/npm</code>为<code>安装路径\node_global</code></li>
<li>系统Path中：新建，输入<code>%NODE_PATH%</code></li>
</ul>
</li>
<li>下面的操作都需管理员身份：可在nodejs文件属性-&gt;安全-&gt;编辑-&gt;选择Users-&gt;完全控制-&gt;确定后退出</li>
<li>管理员cmd输入：<code>npm install -g npm-windows-upgrade</code></li>
<li>管理员Windows powershell输入：<code>set-ExecutionPolicy RemoteSigned</code>-&gt;Y，确定-&gt;选默认最高</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm -v </span><br><span class="line">node -v</span><br></pre></td></tr></table></figure>



<h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><ol>
<li>本地建立一个Hexo文件夹</li>
<li>在文件夹中，右键-&gt;<code>Git Bash</code></li>
<li>命令框中安装Hexo</li>
<li>输入<code>npm install -g hexo</code></li>
<li>初始化<code>hexoinit</code></li>
<li>npm install</li>
<li>hexo server，到此测试基本完成</li>
<li>下面是重新部署命令，可以不输入</li>
<li>hexo clean</li>
<li>hexo generate</li>
<li>hexo deploy</li>
<li>以上为本地测试</li>
</ol>
<h3 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h3><ol>
<li>准备一个仓库<code>modishuriken.github.io</code></li>
<li>仓库名字后缀一定是<code>github.io</code></li>
<li>公开的</li>
<li>用cmd：ping <code>modishuriken.github.io</code></li>
<li>记住IP地址</li>
</ol>
<h3 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h3><ol>
<li>注册域名</li>
<li>使用DNS解析服务</li>
<li>选择域名-&gt;解析设置</li>
<li>设置两个记录类型<ul>
<li>记录类型：A、 主机记录：@、 解析路线：默认、记录值：IP地址、TTL：10min</li>
<li>记录类型：CNAME、 主机记录：www、 解析路线：默认、记录值：<code>modishuriken.github.io</code>、TTL：10min</li>
</ul>
</li>
</ol>
<h2 id="设置IP解析的地方"><a href="#设置IP解析的地方" class="headerlink" title="设置IP解析的地方"></a>设置IP解析的地方</h2><ol>
<li>阿里云的DNS解析</li>
<li>在本地创建的Hexo文件夹下的source文件夹中创建<ul>
<li>右键新建txt文本-&gt;输入你购买的域名<a href="http://www.modishuriken.top/">www.modishuriken.top</a>  -&gt;保存关闭</li>
<li>右键该文本重命名-&gt;将.txt后缀去掉-&gt;会提示文件不可用继续确定即可</li>
</ul>
</li>
<li>在GitHub上：<ul>
<li>进入setting-&gt;Repositories-&gt;选择modishuriken.github.io</li>
<li>choose Settings</li>
<li>find GitHub Page</li>
<li>choose theme and wait a moment</li>
<li>flash Github Page</li>
<li>Custom domain -&gt; input: <a href="http://www.modishuriken.top/">www.modishuriken.top</a> -&gt; save</li>
</ul>
</li>
<li>在本地创建的Hexo文件夹下，找到文件<code>_config.yml</code>并编辑<ul>
<li>deploy: </li>
<li>type:  git </li>
<li>repository: <a href="mailto:&#x67;&#x69;&#116;&#x40;&#x67;&#x69;&#x74;&#x68;&#117;&#98;&#46;&#99;&#111;&#x6d;">&#x67;&#x69;&#116;&#x40;&#x67;&#x69;&#x74;&#x68;&#117;&#98;&#46;&#99;&#111;&#x6d;</a>:modiShuriken&#x2F;modishuriken.github.io.git （这个在仓库的code里找git）</li>
<li>branch: main</li>
<li>注意有空格</li>
<li>还有一个url：<a href="https://github.com/modiShuriken/modishuriken.github.io.git">https://github.com/modiShuriken/modishuriken.github.io.git</a></li>
</ul>
</li>
</ol>
<h2 id="搞定上面的后，进入bash"><a href="#搞定上面的后，进入bash" class="headerlink" title="搞定上面的后，进入bash"></a>搞定上面的后，进入bash</h2><p>git部署至Hexo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>



<h2 id="依次输入"><a href="#依次输入" class="headerlink" title="依次输入"></a>依次输入</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">	生成静态文件</span><br><span class="line">hexo d</span><br><span class="line">	部署到服务器，这一步需要保证Github上拥有本机的公钥</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean 		</span><br><span class="line">		清除缓存文件 (db.json) 和已生成的静态文件 (public)</span><br><span class="line">		在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</span><br><span class="line">		</span><br><span class="line">hexo generate</span><br><span class="line">		生成静态文件</span><br><span class="line">		</span><br><span class="line">hexo deploy</span><br><span class="line">		</span><br></pre></td></tr></table></figure>



<h2 id="日常上传"><a href="#日常上传" class="headerlink" title="日常上传"></a>日常上传</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo clean //清除缓存</span><br><span class="line">$ hexo g  //生成静态文件</span><br><span class="line">$ hexo d  //上传Github</span><br></pre></td></tr></table></figure>



<h2 id="关于使用hexo"><a href="#关于使用hexo" class="headerlink" title="关于使用hexo"></a>关于使用hexo</h2><p><a href="https://hexo.io/zh-cn/docs/configuration">详情</a></p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><h4 id="网站配置"><a href="#网站配置" class="headerlink" title="网站配置"></a>网站配置</h4><table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>title</code></td>
<td align="left">网站标题</td>
</tr>
<tr>
<td align="left"><code>subtitle</code></td>
<td align="left">网站副标题</td>
</tr>
<tr>
<td align="left"><code>description</code></td>
<td align="left">网站描述</td>
</tr>
<tr>
<td align="left"><code>keywords</code></td>
<td align="left">网站的关键词。支持多个关键词。</td>
</tr>
<tr>
<td align="left"><code>author</code></td>
<td align="left">您的名字</td>
</tr>
<tr>
<td align="left"><code>language</code></td>
<td align="left">网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 <code>zh-Hans</code>和 <code>zh-CN</code>。</td>
</tr>
<tr>
<td align="left"><code>timezone</code></td>
<td align="left">网站时区。Hexo 默认使用您电脑的时区。请参考 <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">时区列表</a> 进行设置，如 <code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。一般的，对于中国大陆地区可以使用 <code>Asia/Shanghai</code>。</td>
</tr>
</tbody></table>
<p>其中，<code>description</code>主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。<code>author</code>参数用于主题显示文章的作者。</p>
<h4 id="网址配置"><a href="#网址配置" class="headerlink" title="网址配置"></a>网址配置</h4><table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>url</code></td>
<td align="left">网址, 必须以 <code>http://</code> 或 <code>https://</code> 开头</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>root</code></td>
<td align="left">网站根目录</td>
<td align="left"><code>url&#39;s pathname</code></td>
</tr>
<tr>
<td align="left"><code>permalink</code></td>
<td align="left">文章的 <a href="https://hexo.io/zh-cn/docs/permalinks">永久链接</a> 格式</td>
<td align="left"><code>:year/:month/:day/:title/</code></td>
</tr>
<tr>
<td align="left"><code>permalink_defaults</code></td>
<td align="left">永久链接中各部分的默认值</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>pretty_urls</code></td>
<td align="left">改写 <a href="https://hexo.io/zh-cn/docs/variables"><code>permalink</code></a> 的值来美化 URL</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>pretty_urls.trailing_index</code></td>
<td align="left">是否在永久链接中保留尾部的 <code>index.html</code>，设置为 <code>false</code> 时去除</td>
<td align="left"><code>true</code></td>
</tr>
<tr>
<td align="left"><code>pretty_urls.trailing_html</code></td>
<td align="left">是否在永久链接中保留尾部的 <code>.html</code>, 设置为 <code>false</code> 时去除 (<em>对尾部的 <code>index.html</code>无效</em>)</td>
<td align="left"><code>true</code></td>
</tr>
</tbody></table>
<blockquote>
<p>网站存放在子目录</p>
<p>如果您的网站存放在子目录中，例如 <code>http://example.com/blog</code>，则请将您的 <code>url</code> 设为 <code>http://example.com/blog</code> 并把 <code>root</code> 设为 <code>/blog/</code>。</p>
</blockquote>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 比如，一个页面的永久链接是 http://example.com/foo/bar/index.html</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: false</span><br><span class="line"># 此时页面的永久链接会变为 http://example.com/foo/bar/</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>git</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis(02)</title>
    <url>/posts/f7a35e1b/</url>
    <content><![CDATA[<p>概述：MyBatis知识框架2</p>
<span id="more"></span>

<h1 id="动态代理的七个规范"><a href="#动态代理的七个规范" class="headerlink" title="动态代理的七个规范"></a>动态代理的七个规范</h1><ol>
<li>UsersMapper.xml文件与UsersMapper.java的接口必须同一个目录下.</li>
<li>UsersMapper.xml文件与UsersMapper.java的接口的文件名必须一致,后缀不管.</li>
<li>UserMapper.xml文件中标签的id值与与UserMapper.java的接口中方法的名称完全一致.</li>
<li>UserMapper.xml文件中标签的parameterType属性值与与UserMapper.java的接口中方法的参数类型完全一致.</li>
<li>UserMapper.xml文件中标签的resultType值与与UserMapper.java的接口中方法的返回值类型完全一致.</li>
<li>UserMapper.xml文件中namespace属性必须是接口的完全限定名称top.modi.mapper.UsersMapper</li>
<li>在SqlMapConfig.xml文件中注册mapper文件时,使用class&#x3D;接口的完全限定名称top.modi.mapper.UsersMapper.</li>
</ol>
<h1 id="mapper-xml文件注册"><a href="#mapper-xml文件注册" class="headerlink" title="mapper.xml文件注册"></a>mapper.xml文件注册</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册mapper.xml文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--绝对路径注册--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">&quot;/////&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--非动态代理方式下的注册--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;StudentMapper.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--动态代理方式下的单个mapper.xml文件注册--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.bjpowernode.mapper.UsersMapper&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--批量注册--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.bjpowernode.mapper&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="占位符"><a href="#占位符" class="headerlink" title="#{}占位符"></a>#{}占位符</h1><p>它的底层使用的是PreparedStatement对象，是安全的。</p>
<p>大括号里面该写什么</p>
<ul>
<li>是简单类型(8种基本(封装)+String),则#{}里随便写</li>
<li>型是实体类的类型,则#{}里只能是类中成员变量的名称,而且区分大小写！！！</li>
</ul>
<h1 id="字符串替换"><a href="#字符串替换" class="headerlink" title="${}字符串替换"></a>${}字符串替换</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    //模糊用户名和地址查询</span></span><br><span class="line"><span class="comment">    //如果参数超过一个,则parameterType不写</span></span><br><span class="line"><span class="comment">    List&lt;Users&gt; getByNameOrAddress(</span></span><br><span class="line"><span class="comment">            @Param(&quot;columnName&quot;)  ===&gt;为了在sql语句中使用的名称</span></span><br><span class="line"><span class="comment">            String columnName,</span></span><br><span class="line"><span class="comment">            @Param(&quot;columnValue&quot;)   ===&gt;为了在sql语句中使用的名称</span></span><br><span class="line"><span class="comment">            String columnValue);</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getByNameOrAddress&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;users&quot;</span>&gt;</span></span><br><span class="line">        select id,username,birthday,sex,address</span><br><span class="line">        from users</span><br><span class="line">        where $&#123;columnName&#125; like concat(&#x27;%&#x27;,#&#123;columnValue&#125;,&#x27;%&#x27;)  ==&gt;此处使用的是@Param注解里的名称</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="返回主键值"><a href="#返回主键值" class="headerlink" title="返回主键值"></a>返回主键值</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;users&quot;</span> &gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">selectKey</span>  <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">order</span>=<span class="string">&quot;AFTER&quot;</span>&gt;</span></span><br><span class="line">	        select last_insert_id()</span><br><span class="line">	    <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">        insert into users (username, birthday, sex, address) values(#&#123;userName&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>keyProperty: users对象的哪个属性来接返回的主键值<br>resultType:返回的主键的类型<br>order:在插入语句执行前,还是执行后返回主键的值</p>
<h1 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h1><p>这是一个全球唯一随机字符串,由36个字母数字中划线组.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">UUID</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID();</span><br><span class="line">System.out.println(uuid.toString().replace(<span class="string">&quot;-&quot;</span>,<span class="string">&quot;&quot;</span>).substring(<span class="number">20</span>));</span><br></pre></td></tr></table></figure>

<h1 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL***"></a>动态SQL***</h1><ol>
<li><p><code>&lt;sql&gt;</code>:用来定义代码片断,可以将所有的列名,或复杂的条件定义为代码片断,供使用时调用.</p>
<ul>
<li>&#96;&#96;&#96;xml<sql id="allColumns">
        id,username,birthday,sex,address
</sql>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. `&lt;include&gt;`:用来引用`&lt;sql&gt;`定义的代码片断</span><br><span class="line"></span><br><span class="line">   - ```xml</span><br><span class="line">     &lt;select id=&quot;getAll&quot; resultType=&quot;users&quot; &gt;</span><br><span class="line">             select &lt;include refid=&quot;allColumns&quot;&gt;&lt;/include&gt;</span><br><span class="line">             from users</span><br><span class="line">     &lt;/select&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>&lt;if&gt;:</code>进行条件判断<br>test条件判断的取值可以是实体类的成员变量,可以是map的key,可以是@Param注解的名称.</p>
</li>
<li><p><code>&lt;where&gt;</code>:进行多条件拼接,在查询,删除,更新中使用.</p>
<ul>
<li>&#96;&#96;&#96;xml<select id="getByCondition" parameterType="users" resultType="users">
        select <include refid="allColumns"></include>
        from users
        <where>
            <if test="userName != null and userName != ''">
               and username like concat('%',#{userName},'%')
            </if>
            <if test="birthday != null">
               and birthday = #{birthday}
            </if>
            <if test="sex != null and sex != ''">
               and sex = #{sex}
            </if>
            <if test="address != null and address != ''">
                and address like concat('%',#{address},'%')
            </if>
        </where>
</select>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">5. `&lt;set&gt;`:有选择的进行更新处理,至少更新一列.能够保证如果没有传值进来,则数据库中的数据保持不变.</span><br><span class="line"></span><br><span class="line">   - ```xml</span><br><span class="line">     &lt;update id=&quot;updateBySet&quot; parameterType=&quot;users&quot;&gt;</span><br><span class="line">             update users</span><br><span class="line">             &lt;set&gt;</span><br><span class="line">                 &lt;if test=&quot;userName != null and userName != &#x27;&#x27;&quot;&gt;</span><br><span class="line">                    username = #&#123;userName&#125;,</span><br><span class="line">                 &lt;/if&gt;</span><br><span class="line">                 &lt;if test=&quot;birthday != null&quot;&gt;</span><br><span class="line">                     birthday = #&#123;birthday&#125;,</span><br><span class="line">                 &lt;/if&gt;</span><br><span class="line">                 &lt;if test=&quot;sex != null and sex != &#x27;&#x27;&quot;&gt;</span><br><span class="line">                     sex = #&#123;sex&#125;,</span><br><span class="line">                 &lt;/if&gt;</span><br><span class="line">                 &lt;if test=&quot;address != null and address != &#x27;&#x27;&quot;&gt;</span><br><span class="line">                     address =#&#123;address&#125; ,</span><br><span class="line">                 &lt;/if&gt;</span><br><span class="line">             &lt;/set&gt;</span><br><span class="line">             where id = #&#123;id&#125;</span><br><span class="line">     &lt;/update&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>foreach&gt;:用来进行循环遍历,完成循环条件查询,批量删除,批量增加,批量更新.(一条语句)</p>
<ul>
<li><p>配合关键字in使用，进行循环遍历</p>
</li>
<li><p>&#96;&#96;&#96;xml</p>
<select id="getByIds" resultType="users">
        select <include refid="allColumns"></include>
        from users
        where id in
           <foreach collection="array" item="id" separator="," open="(" close=")">
               #{id}
           </foreach>
</select>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   - 参数详解:</span><br><span class="line">             collection:用来指定入参的类型,如果是List集合,则为list,如果是Map集合,则为map,如果是数组,则为array.</span><br><span class="line">             item:每次循环遍历出来的值或对象</span><br><span class="line">             separator:多个值或对象或语句之间的分隔符</span><br><span class="line">             open:整个循环外面的前括号 </span><br><span class="line">             close:整个循环外面的后括号</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 指定参数位置2</span><br><span class="line"></span><br><span class="line">如果入参是多个,可以通过指定参数位置进行传参. **（语义不明）**</span><br><span class="line"></span><br><span class="line">- 例如查询某范围内的用户信息</span><br><span class="line"></span><br><span class="line">- ```xml</span><br><span class="line">  &lt;!--</span><br><span class="line">        //查询指定日期范围内的用户</span><br><span class="line">      List&lt;Users&gt; getByBirthday(Date begin, Date end);</span><br><span class="line">      --&gt;</span><br><span class="line">      &lt;select id=&quot;getByBirthday&quot; resultType=&quot;users&quot;&gt;</span><br><span class="line">          select &lt;include refid=&quot;allColumns&quot;&gt;&lt;/include&gt;</span><br><span class="line">          from users</span><br><span class="line">          where birthday between #&#123;arg0&#125; and #&#123;arg1&#125;</span><br><span class="line">      &lt;/select&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h1 id="入参是map"><a href="#入参是map" class="headerlink" title="入参是map***"></a>入参是map***</h1><p>使用map封装查询条件,更有语义,查询条件更明确.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">       //入参是map</span></span><br><span class="line"><span class="comment">    List&lt;Users&gt; getByMap(Map map);</span></span><br><span class="line"><span class="comment">    #&#123;birthdayBegin&#125;:就是map中的key</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getByMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;users&quot;</span> &gt;</span></span><br><span class="line">        select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;allColumns&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        from users</span><br><span class="line">        where birthday between #&#123;birthdayBegin&#125; and #&#123;birthdayEnd&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">测试类中--保持key一致</span><br><span class="line">map.put(&quot;birthdayBegin&quot;,begin);</span><br><span class="line">map.put(&quot;birthdayEnd&quot;, end);</span><br></pre></td></tr></table></figure>

<h1 id="返回值是map"><a href="#返回值是map" class="headerlink" title="返回值是map"></a>返回值是map</h1><p>返回后这些数据之间没有任何关系.就是Object类型.返回的map的<strong>key就是列名或别名</strong>.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">       //返回值是map(一行)</span></span><br><span class="line"><span class="comment">    Map getReturnMap(Integer id);</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getReturnMap&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">        select username nam,address a</span><br><span class="line">        from users</span><br><span class="line">        where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      //返回多行的map</span></span><br><span class="line"><span class="comment">    List&lt;Map&gt; getMulMap();</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getMulMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">        select username,address</span><br><span class="line">        from users</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h2><p>​		无论是什么关联关系，如果某方持有另一方的集合，则使用<code>&lt;collection&gt;</code>标签完成映射，如果某方持有另一方的对象，则使用<code>&lt;association&gt;</code>标签完成映射。</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>四个特性：一致性,持久性,原子性,隔离性.</p>
<p>设置方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在MyBatis框架中设置事务</span><br><span class="line">  &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;  ===&gt;程序员自己控制处理的提交和回滚</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可设置为自动提交</span><br><span class="line">  sqlSession = factory.openSession();  ===&gt;默认是手工提交事务,设置为false也是手工提交事务,如果设置为true,则为自动提交.</span><br><span class="line">  sqlSession = factory.openSession(true);  ===&gt;设置为自动提交,在增删改后不需要commit();</span><br></pre></td></tr></table></figure>



<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>MyBatis框架提供两级缓存,一级缓存和二级缓存.默认开启一级缓存.</p>
<p>流程：</p>
<blockquote>
<p>查询时先到缓存里查,如果没有则查询数据库,放缓存一份,再返回客户端.下次再查询的时候直接从缓存返回,不再访问数据库.如果数据库中发生commit()操作,则清空缓存.</p>
</blockquote>
<p>作用域：</p>
<blockquote>
<p>​		一级缓存使用的是SqlSession的作用域,同一个sqlSession共享一级缓存的数据.</p>
<p>​		二级缓存使用的是mapper的作用域,不同的sqlSession只要访问的同一个mapper.xml文件,则共享二级缓存作用域.</p>
</blockquote>
<h2 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h2><p>ORM(Object Relational Mapping):对象关系映射</p>
<blockquote>
<p>java语言中以对象的方式操作数据,存到数据库中是以表的方式进行存储,对象中的成员变量与表中的列之间的数据互换称为映射.整个这套操作就是ORM.</p>
</blockquote>
<p><strong>持久化的操作：</strong>将对象保存到关系型数据库中 ,将关系型数据库中的数据读取出来以对象的形式封装</p>
]]></content>
      <categories>
        <category>JAVA框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis(01)</title>
    <url>/posts/dc8e0dd8/</url>
    <content><![CDATA[<p>概述：MyBatis知识框架</p>
<span id="more"></span>

<h1 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h1><p>在项目开发中遵循的一种形式模式，共三层：</p>
<ol>
<li>界面层<ul>
<li>接收用户的客户端输入，调用业务逻辑层进行功能处理，返回结果给客户端（如servlet）</li>
</ul>
</li>
<li>业务逻辑层<ul>
<li>项目中的业务逻辑处理，向上为界面层提供处理结果，向下对数据访问层要数据</li>
</ul>
</li>
<li>数据访问层<ul>
<li>进行数据库的增删改查操作，向上为业务逻辑层提供数据</li>
</ul>
</li>
</ol>
<blockquote>
<p>各层不能跨层访问</p>
</blockquote>
<h2 id="常用的框架SSM"><a href="#常用的框架SSM" class="headerlink" title="常用的框架SSM"></a>常用的框架SSM</h2><ul>
<li>Spring: 它是整合其他框架的框架。它的核心是IOC和AOP，由20多个模块构成</li>
<li>SprintMVC: 专门用来优化控制器（Servlet）的，提供了极简的数据提交，数据携带，页面跳转等功能</li>
<li>MyBatis: 是持久化层的一个框架。用来数据库访问的优化。专注与sql语句，极大的简化了JDBC的访问</li>
</ul>
<h1 id="基本实现步骤"><a href="#基本实现步骤" class="headerlink" title="基本实现步骤"></a>基本实现步骤</h1><ol>
<li><p>新建数据库中的数据表</p>
</li>
<li><p>新建maven项目,选quickstart模板</p>
</li>
<li><p>修改目录,添加缺失的目录,修改目录属性</p>
</li>
<li><p>修改pom.xml文件,添加MyBatis的依赖,添加mysql的依赖</p>
<ul>
<li><p>如果依赖爆红，可能是由于本地仓库中没有，需要刷新一下以下载</p>
</li>
<li><p>&#96;&#96;&#96;</p>
<!--添加MyBatis框架的依赖-->
<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
  &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
  &lt;version&gt;3.5.6&lt;/version&gt;
&lt;/dependency&gt;
&lt;!--添加mysql依赖--&gt;
&lt;dependency&gt;
  &lt;groupId&gt;mysql&lt;/groupId&gt;
  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
  &lt;version&gt;5.1.32&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">5. 修改pom.xml文件,添加资源文件指定</span><br><span class="line"></span><br><span class="line">   - 注意：需要将所有含xml和properties文件的路径都指定</span><br><span class="line"></span><br><span class="line">   - ```</span><br><span class="line">     &lt;build&gt;</span><br><span class="line">         &lt;resources&gt;</span><br><span class="line">           &lt;resource&gt;</span><br><span class="line">             &lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="line">             &lt;includes&gt;</span><br><span class="line">               &lt;include&gt;**/*.xml&lt;/include&gt;</span><br><span class="line">               &lt;include&gt;**/*.properties&lt;/include&gt;</span><br><span class="line">             &lt;/includes&gt;</span><br><span class="line">           &lt;/resource&gt;</span><br><span class="line">           &lt;resource&gt;</span><br><span class="line">             &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">             &lt;includes&gt;</span><br><span class="line">               &lt;include&gt;**/*.xml&lt;/include&gt;</span><br><span class="line">               &lt;include&gt;**/*.properties&lt;/include&gt;</span><br><span class="line">             &lt;/includes&gt;</span><br><span class="line">           &lt;/resource&gt;</span><br><span class="line">         &lt;/resources&gt;</span><br><span class="line">       &lt;/build&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>在idea中添加数据库的可视化</p>
<ul>
<li><p>在IDEA的最右边添加，注意驱动jar包，和版本不同</p>
</li>
<li><p>&#96;&#96;&#96;<br>com.mysql.cj.jdbc.Driver<br>com.mysql.jdbc.Driver</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">7. 添加jdbc.properties属性文件(数据库的配置)</span><br><span class="line"></span><br><span class="line">   - 需要和上面的驱动对应</span><br><span class="line"></span><br><span class="line">   - ```</span><br><span class="line">     jdbc.driverClassName=com.mysql.cj.jdbc.Driver</span><br><span class="line">     jdbc.url=jdbc:mysql://localhost:3306/ssm?useUnicode=true&amp;characterEncoding=utf8</span><br><span class="line">     jdbc.username=root</span><br><span class="line">     jdbc.password=root</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>.添加SqlMapConfig.xml文件,MyBatis的核心配置文件</p>
<ul>
<li>该文件在pom.xml的指定资源路径下</li>
</ul>
</li>
<li><p>创建实体类Student,用来封装数据</p>
<ul>
<li>与数据中的类型一一对应</li>
</ul>
</li>
<li><p>添加完成学生表的增删改查的功能的StudentMapper.xml文件</p>
</li>
<li><p>创建测试类,进行功能测试</p>
</li>
</ol>
<h1 id="SqlMapConfig-xml文件"><a href="#SqlMapConfig-xml文件" class="headerlink" title="SqlMapConfig.xml文件"></a>SqlMapConfig.xml文件</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--读取属性文件（jdbc.properties）</span></span><br><span class="line"><span class="comment">        属性：resources目录下的指定文件名称来加载（相对路径）</span></span><br><span class="line"><span class="comment">             url绝对路径</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--设置日志输出在控制台（STDOUT_LOGGING）--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;settings&gt;</span></span><br><span class="line"><span class="comment">        &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;</span></span><br><span class="line"><span class="comment">    &lt;/settings&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置实体类的别名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--单个配置实体类的别名--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;typeAlias type=&quot;top.modi.pojo.Student&quot; alias=&quot;student&quot;&gt;&lt;/typeAlias&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--批量配置实体类的别名。别名为实体类的驼峰命名法（规范）--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;top.modi.pojo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置数据库的环境变量（数据库连接配置）--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--default选择&lt;environment&gt;标签的选择--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置事务管理器</span></span><br><span class="line"><span class="comment">                type: JDBC（程序员来处理）</span></span><br><span class="line"><span class="comment">                      MANAGED（由容器Spring来管理事务）</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置数据源</span></span><br><span class="line"><span class="comment">                type: JNDI:在服务器端进行数据库连接池管理（弃用）</span></span><br><span class="line"><span class="comment">                      POOLED:使用数据库连接池</span></span><br><span class="line"><span class="comment">                      UNPOOLED:不使用数据库连接池</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--配置数据库连接的基本参数（url,driver,username,password）--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driverClassName&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--注册Mapper.xml文件</span></span><br><span class="line"><span class="comment">        class：动态代理的注册</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;StudentMapper.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="StudentMapper-xml文件"><a href="#StudentMapper-xml文件" class="headerlink" title="StudentMapper.xml文件"></a>StudentMapper.xml文件</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--namespace:指定命名空间，因为该文件有多个，需要用来区分--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;li&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--id:设置该条语句的调用名</span></span><br><span class="line"><span class="comment">        parameterType:指定传入的参数的类型</span></span><br><span class="line"><span class="comment">        resultType:指定返回结果集的类型，如果是集合，则必须是泛型</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">        select id, name, email, age</span><br><span class="line">        from student;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">        select id, name, email, age</span><br><span class="line">        from student</span><br><span class="line">        where id=#&#123;id&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getByName&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;String&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">        select id, name, email, age</span><br><span class="line">        from student</span><br><span class="line">        where name LIKE &#x27;%$&#123;name&#125;%&#x27;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;student&quot;</span> &gt;</span></span><br><span class="line">        insert into student (name, email, age)</span><br><span class="line">        values (#&#123;name&#125;, #&#123;email&#125;, #&#123;age&#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;delete&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">        delete</span><br><span class="line">        from student</span><br><span class="line">        where id = #&#123;id&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">        update student set name=#&#123;name&#125;, email=#&#123;email&#125;, age=#&#123;age&#125;</span><br><span class="line">        where id=#&#123;id&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.modi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.After;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> top.modi.pojo.Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增删改查的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    SqlSession sqlSession;</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">openSqlSession</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="comment">//使用文件流读取核心配置文件SqlMapConfig.xml</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//创建SqlSessionFactory工厂</span></span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(in);</span><br><span class="line">        <span class="comment">//取出sqlSession的对象</span></span><br><span class="line">        sqlSession = factory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">closeSqlSession</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//关闭（归还）sqlSession</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@org</span>.junit.Test</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testA</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//查询操作</span></span><br><span class="line">        List&lt;Student&gt; list = sqlSession.selectList(<span class="string">&quot;li.getAll&quot;</span>);</span><br><span class="line">        list.forEach(student -&gt; System.out.println(student));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@org</span>.junit.Test</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetById</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> sqlSession.selectOne(<span class="string">&quot;li.getById&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        System.out.println(stu);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@org</span>.junit.Test</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testByName</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">str</span> <span class="operator">=</span> sqlSession.selectOne(<span class="string">&quot;li.getByName&quot;</span>, <span class="string">&quot;李&quot;</span>);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@org</span>.junit.Test</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sqlSession.insert(<span class="string">&quot;li.insert&quot;</span>, <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李&quot;</span>, <span class="string">&quot;12@163.com&quot;</span>, <span class="number">22</span>));</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        <span class="comment">//事务提交不可写入After中！！！</span></span><br><span class="line">        sqlSession.commit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@org</span>.junit.Test</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sqlSession.delete(<span class="string">&quot;li.delete&quot;</span>, <span class="number">5</span>);</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@org</span>.junit.Test</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sqlSession.update(<span class="string">&quot;li.update&quot;</span>, <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">4</span>,<span class="string">&quot;李&quot;</span>, <span class="string">&quot;12@163.com&quot;</span>, <span class="number">12</span>));</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JAVA框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle4</title>
    <url>/posts/9cf72927/</url>
    <content><![CDATA[<p><strong>概述：</strong>PL&#x2F;SQL的使用</p>
<span id="more"></span>

<h1 id="PL-x2F-SQL"><a href="#PL-x2F-SQL" class="headerlink" title="PL&#x2F;SQL"></a>PL&#x2F;SQL</h1><p>procedure language &amp; Structured Query Language </p>
<p>过程化编程语言，运行于服务端的编程语言</p>
<p>对<code>sql</code>语言的扩展，<code>pl/sql</code>不仅允许嵌入<code>sql</code>语言，还可以完成定义变量和常量，允许使用条件语句和循环语句，允许使用例外处理各种错误</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li><p>有利于客户&#x2F;服务器环境应用的运行：</p>
<p>​			大量数据处理的应用放在服务器端来执行</p>
</li>
<li><p>适合于客户环境</p>
<p>​			分为数据库PL&#x2F;SQL和工具PL&#x2F;SQL，客户端程序可以执行本地包含PL&#x2F;SQL部分，也可以向服务发SQL命令或激活服务器端的PL&#x2F;SQL程序运行。</p>
</li>
<li><p>过程化</p>
</li>
<li><p>模块化</p>
</li>
<li><p>运行错误的可处理性</p>
</li>
<li><p>提供大量内置程序包</p>
</li>
<li><p>更好的性能、可移植性和兼容性、可维护性、易用性与快速性等。</p>
</li>
</ul>
<h2 id="块（block）"><a href="#块（block）" class="headerlink" title="块（block）"></a>块（block）</h2><p>组成： （就是编程语言）</p>
<ul>
<li>声明部分</li>
<li>执行部分</li>
<li>异常处理部分</li>
</ul>
<p>结构：其中，<strong>执行部分是必须的</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE</span><br><span class="line">  --声明部分: 在此声明PL/SQL用到的变量,类型及游标，以及局部的存储过程和函数</span><br><span class="line">BEGIN</span><br><span class="line">  -- 执行部分: 过程及SQL 语句 , 即程序的主要部分</span><br><span class="line">EXCEPTION</span><br><span class="line">  -- 执行异常部分: 错误处理</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>eg:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--只包含声明部分</span><br><span class="line">begin</span><br><span class="line">dbms_output.put_line(&#x27;hello world&#x27;);</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>



<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ul>
<li>不超过30个字符</li>
<li>首字符必为字母</li>
<li>不区分大小写</li>
<li>不用保留字</li>
</ul>
<h3 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h3><table>
<thead>
<tr>
<th>标识符</th>
<th>规则</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>变量</td>
<td>V_name</td>
<td>V_example</td>
</tr>
<tr>
<td>常量</td>
<td>C_name</td>
<td>C_example</td>
</tr>
<tr>
<td>游标</td>
<td>Cursor_name</td>
<td>Cursor_example</td>
</tr>
<tr>
<td>异常标识</td>
<td>E_name</td>
<td>E_too_many</td>
</tr>
<tr>
<td>表类型</td>
<td>name_table_type</td>
<td>Emp_record_type</td>
</tr>
<tr>
<td>表</td>
<td>name_table</td>
<td>emp</td>
</tr>
<tr>
<td>记录类型</td>
<td>name_record</td>
<td>emp_record</td>
</tr>
<tr>
<td>SQL*Plus替代变量</td>
<td>P_name</td>
<td>P_sal</td>
</tr>
<tr>
<td>绑定变量</td>
<td>G_name</td>
<td>G_year_sal</td>
</tr>
</tbody></table>
<h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>子类</th>
<th>说明</th>
<th>范围</th>
<th>Oracle限制</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>character<br />string<br />rowid<br />nchar</td>
<td>定长字符串<br>民族语言字符集</td>
<td></td>
<td>2000</td>
</tr>
<tr>
<td>varchar2</td>
<td>varchar<br />string<br />nvarchar2</td>
<td>可变字符串<br/>民族语言字符集</td>
<td></td>
<td>4000</td>
</tr>
<tr>
<td>binary_integer</td>
<td>无</td>
<td>带符号整数<br/>为整数计算优化性能</td>
<td></td>
<td></td>
</tr>
<tr>
<td>number(p,s)</td>
<td>dec double<br />precision<br />integer int<br />numeric<br />real small<br />int</td>
<td>小数,高精度实数<br/>NUMBER 的子类型 <br/>比integer 小</td>
<td></td>
<td></td>
</tr>
<tr>
<td>long</td>
<td>无</td>
<td>变长字符串</td>
<td></td>
<td>32,767字节</td>
</tr>
<tr>
<td>date</td>
<td>无</td>
<td>日期</td>
<td></td>
<td></td>
</tr>
<tr>
<td>boolean</td>
<td>无</td>
<td>布尔</td>
<td></td>
<td>不使用！！</td>
</tr>
<tr>
<td>rowid</td>
<td>无</td>
<td>行号存放</td>
<td></td>
<td></td>
</tr>
<tr>
<td>urowid</td>
<td>无</td>
<td>通用行标识符，字符类型</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>使用–自己定义和借用表中字段的数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">declare</span><br><span class="line">	v_ename varchar2(30);</span><br><span class="line">	v_sal number(5);</span><br><span class="line">	v_x number(3) :=3;--定义变量的同时赋值</span><br><span class="line">---------------------------------------</span><br><span class="line">declare</span><br><span class="line">	v_ename emp.ename%type;</span><br><span class="line">	v_sal emp.sal%type;</span><br><span class="line">	v_x number(3) := 3;</span><br><span class="line">---------------------------------------</span><br><span class="line">declare</span><br><span class="line"> --声明一个记录类型</span><br><span class="line">     type emp_record is record(</span><br><span class="line">       v_ename emp.ename%type,</span><br><span class="line">       v_sal emp.sal%type,</span><br><span class="line">       v_deptno number(4)</span><br><span class="line">	);</span><br><span class="line">--声明记录类型的变量</span><br><span class="line">v_emp_record emp_record;</span><br><span class="line">--调用记录类型</span><br><span class="line">v_emp_record.v_ename</span><br><span class="line">---------------------------------------</span><br><span class="line">declare</span><br><span class="line">     --声明记录类型，应用表中类型</span><br><span class="line">     e emp%rowtype;</span><br></pre></td></tr></table></figure>



<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>三类：选择，循环，顺序</p>
<h3 id="if语句（elsif）"><a href="#if语句（elsif）" class="headerlink" title="if语句（elsif）"></a>if语句（elsif）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IF &lt;布尔表达式&gt; THEN</span><br><span class="line">	PL/SQL 和 SQL语句</span><br><span class="line">END IF;</span><br><span class="line">-----------------------------</span><br><span class="line">IF &lt;布尔表达式&gt; THEN</span><br><span class="line">	PL/SQL 和 SQL语句</span><br><span class="line">ELSE</span><br><span class="line">	其它语句</span><br><span class="line">END IF;</span><br><span class="line">-----------------------------</span><br><span class="line">IF &lt;布尔表达式&gt; THEN</span><br><span class="line">	PL/SQL 和 SQL语句</span><br><span class="line">ELSIF &lt; 其它布尔表达式&gt; THEN</span><br><span class="line">	其它语句</span><br><span class="line">ELSIF &lt; 其它布尔表达式&gt; THEN</span><br><span class="line">	其它语句</span><br><span class="line">ELSE</span><br><span class="line">	其它语句</span><br><span class="line">END IF;</span><br></pre></td></tr></table></figure>

<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><ul>
<li><p>简单循环(exit退出)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOOP</span><br><span class="line">  要执行的语句;</span><br><span class="line">EXIT WHEN &lt;条件语句&gt; --条件满足，退出循环语句</span><br><span class="line">END LOOP;</span><br></pre></td></tr></table></figure>
</li>
<li><p>while</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WHILE &lt;布尔表达式&gt; LOOP</span><br><span class="line"> 要执行的语句;</span><br><span class="line">END LOOP;</span><br></pre></td></tr></table></figure>
</li>
<li><p>for</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FOR 循环计数器 IN [ REVERSE ] 下限 .. 上限 LOOP</span><br><span class="line">	要执行的语句;</span><br><span class="line">END LOOP [循环标签];</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for v_num in 20.. 30 loop</span><br><span class="line">      insert into temp_table values(v_num);</span><br><span class="line">end loop</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="游标（cursor）"><a href="#游标（cursor）" class="headerlink" title="游标（cursor）"></a>游标（cursor）</h2><blockquote>
<p>在PL&#x2F;SQL块中执行SELECT、INSERT、DELETE和UPDATE语句时，ORACLE会在内存中为其分配上下文区（Context Area），即缓冲区。</p>
<p>游标是指向该区的一个指针，或是命名一个工作区（Work Area），或是一种结构化数据类型。</p>
<p>它为应用等量齐观提供了一种对”具有多行数据查询结果集中的每一行数据”分别进行单独处理的方法，是设计嵌入式SQL语句的应用程序的常用编程</p>
</blockquote>
<p><strong>理解</strong>：</p>
<blockquote>
<p>游标是指向查询结果的指针，指针指向那条记录，提取的就是那条记录的数据</p>
</blockquote>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol>
<li>定义&#x2F;声明：除了游标变量，还有对应的查询语句</li>
<li>打开游标：执行查询语句并将结果放入工作区，游标指向首部，标识游标结果集合<ul>
<li>如果游标查询语句中带有FOR UPDATE选项，OPEN 语句还将锁定数据库表中，游标结果集合对应的数据行。</li>
</ul>
</li>
<li>提取游标数据：检索结果合集，放入输出变量</li>
<li>关闭游标：释放资源。</li>
<li>关闭后的游标可以使用OPEN语句重新打开。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cursor cursor_name[(parameter[, parameter]…)]</span><br><span class="line">[return datatype]  </span><br><span class="line">is  </span><br><span class="line">select_statement;</span><br><span class="line"></span><br><span class="line">open cursor_name[([parameter =&gt;] value[, [parameter =&gt;] value]…)]</span><br><span class="line"></span><br><span class="line">fetch cursor_name into &#123;variable_list | record_variable &#125;;</span><br><span class="line"></span><br><span class="line">CLOSE cursor_name;</span><br></pre></td></tr></table></figure>



<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li>布尔属性<ul>
<li>Cursor_name%found， 最近一次提取操作成功</li>
<li>Cursor_name%noufound， 最近一次提取操作失败</li>
<li>Cursor_name%isopen， 游标打开</li>
</ul>
</li>
<li>数字型属性<ul>
<li>Cursor_name%rowcount， 返回已从游标中读取的记录数</li>
</ul>
</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--普通游标，查询10号部门的员工姓名和工资</span><br><span class="line">declare</span><br><span class="line">	v_ename emp.ename%type;</span><br><span class="line">	v_sal emp.sal%type;</span><br><span class="line">	 --定义游标</span><br><span class="line">     cursor emp_cursor is select ename,sal from emp where deptno=10;</span><br><span class="line">begin</span><br><span class="line">     --打开游标</span><br><span class="line">	open emp_cursor;</span><br><span class="line">     --从游标上获取数据</span><br><span class="line">	fetch emp_cursor into v_ename,v_sal;</span><br><span class="line">	while emp_cursor%found loop</span><br><span class="line">          dbms_output.put_line(v_ename||&#x27;,&#x27;||v_sal);</span><br><span class="line">          fetch emp_cursor into v_ename,v_sal;--此处必须再次获取游标上的数据，否则会死循环</span><br><span class="line">	end loop;</span><br><span class="line">	close emp_cursor;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--参数化游标</span><br><span class="line">--cursor 游标名(参数列表) is 查询语句</span><br><span class="line">declare</span><br><span class="line">	v_ename emp.ename%type;</span><br><span class="line">	v_sal emp.sal%type;</span><br><span class="line">	cursor emp_cursor(p_deptno number) is select ename,sal from emp where</span><br><span class="line">	deptno=p_deptno;</span><br><span class="line">begin</span><br><span class="line"> --打开游标时,传入参数</span><br><span class="line">	open emp_cursor(10);</span><br><span class="line"> --从游标上获取数据</span><br><span class="line">	fetch emp_cursor into v_ename,v_sal;</span><br><span class="line">	while emp_cursor%found loop</span><br><span class="line">		dbms_output.put_line(v_ename||&#x27;,&#x27;||v_sal);</span><br><span class="line">        fetch emp_cursor into v_ename,v_sal;</span><br><span class="line">	end loop;</span><br><span class="line"> --关闭游标</span><br><span class="line">	close emp_cursor;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--游标for循环，查询10号部门的员工姓名和工资</span><br><span class="line">declare</span><br><span class="line"> --定义游标</span><br><span class="line">	cursor emp_cursor is select ename,sal from emp where deptno=10;</span><br><span class="line">begin </span><br><span class="line">	for e in emp_cursor loop</span><br><span class="line">		dbms_output.put_line(e.ename||&#x27;,&#x27;||e.sal);</span><br><span class="line">	end loop;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">--省略声明部分</span><br><span class="line">--游标for循环，查询10号部门的员工姓名和工资</span><br><span class="line">begin </span><br><span class="line">	for e in (select ename,sal from emp where deptno=10) loop</span><br><span class="line">	dbms_output.put_line(e.ename||&#x27;,&#x27;||e.sal);</span><br><span class="line">	end loop;</span><br><span class="line">end;</span><br><span class="line">--注意:游标for循环会自动打开和关闭游标，无须手动操作</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--带参数的游标for循环</span><br><span class="line">declare</span><br><span class="line"> --定义游标时定义参数列表</span><br><span class="line">	cursor emp_cursor(d_deptno number) is select ename,sal from emp where deptno =</span><br><span class="line">d_deptno;</span><br><span class="line">begin</span><br><span class="line"> --循环是传入参数即可</span><br><span class="line">	for e in emp_cursor(20) loop</span><br><span class="line">		dbms_output.put_line(e.ename||&#x27;,&#x27;||e.sal);</span><br><span class="line">	end loop;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>



<h3 id="隐式游标"><a href="#隐式游标" class="headerlink" title="隐式游标"></a>隐式游标</h3><p>注：作用于添加删除和修改的DML语句上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">declare</span><br><span class="line">begin</span><br><span class="line">     update emp set sal=sal+100 where deptno = 10;</span><br><span class="line"> 	--此时的sql就是隐式的游标</span><br><span class="line">     if sql%found then</span><br><span class="line">          dbms_output.put_line(&#x27;更新成功,更新了&#x27;||sql%rowcount||&#x27;行&#x27;);</span><br><span class="line">     else</span><br><span class="line">          dbms_output.put_line(&#x27;更新失败,部门不存在&#x27;);</span><br><span class="line">     end if;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>



<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>三类：预定义错误、非预定义错误、 自定义错误</p>
<h3 id="预定义异常处理-常见"><a href="#预定义异常处理-常见" class="headerlink" title="预定义异常处理(常见)"></a>预定义异常处理(常见)</h3><table>
<thead>
<tr>
<th>错误号</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ORA-1403</td>
<td>No_data_found</td>
<td>SELECT INTO没有找到数据</td>
</tr>
<tr>
<td>ORA-1422</td>
<td>Too_many_rows</td>
<td>SELECT INTO 返回多行</td>
</tr>
</tbody></table>
<p><a href="https://blog.csdn.net/u013882957/article/details/71305224">Link1</a></p>
<ul>
<li><p>no_data_found</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--预定义异常no_data_found</span><br><span class="line">declare</span><br><span class="line">	v_ename emp.ename%type;</span><br><span class="line">begin</span><br><span class="line">	select ename into v_ename from emp where empno =111;</span><br><span class="line">	dbms_output.put_line(v_ename);</span><br><span class="line">exception</span><br><span class="line">	when no_data_found then</span><br><span class="line">	dbms_output.put_line(&#x27;查无此人&#x27;);</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>


</li>
<li><p>too_many_rows</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--预定义异常</span><br><span class="line">declare</span><br><span class="line">	v_ename emp.ename%type;</span><br><span class="line">begin</span><br><span class="line">	select ename into v_ename from emp where deptno = 10;</span><br><span class="line">	dbms_output.put_line(v_ename);</span><br><span class="line">exception</span><br><span class="line">	when no_data_found then</span><br><span class="line">	dbms_output.put_line(&#x27;查无此人&#x27;);</span><br><span class="line">	when too_many_rows then</span><br><span class="line">	dbms_output.put_line(&#x27;返回的值太多&#x27;);</span><br><span class="line">end;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="非预定义异常"><a href="#非预定义异常" class="headerlink" title="非预定义异常"></a>非预定义异常</h3><blockquote>
<p>只有编号，没有类型名</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">declare</span><br><span class="line"> --声明一个异常</span><br><span class="line">	e_exception exception;</span><br><span class="line"> --将声明的异常与oracle中的非预定义异常的编号绑定</span><br><span class="line">	pragma exception_init(e_exception,-02291);</span><br><span class="line">begin</span><br><span class="line">	insert into emp values(119,&#x27;admim&#x27;,null,null,null,null,null,50);</span><br><span class="line">exception</span><br><span class="line"> --正常执行异常处理</span><br><span class="line">	when e_exception then</span><br><span class="line">		dbms_output.put_line(&#x27;插入值不匹配&#x27;);</span><br><span class="line"> --sqlcode可以获取异常的编号</span><br><span class="line"> --sqlerrm可以获取异常的信息</span><br><span class="line">		dbms_output.put_line(&#x27;错误编号是：&#x27;||sqlcode||&#x27;,错误信息是:&#x27;||sqlerrm);</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>



<h2 id="函数和存储过程"><a href="#函数和存储过程" class="headerlink" title="函数和存储过程"></a>函数和存储过程</h2><p>唯一区别:<strong>函数</strong>总向调用者返回数据，而<strong>过程</strong>不返回数据</p>
<blockquote>
<p>存储过程和函数统称为PL&#x2F;SQL子程序，他们是被命名的PL&#x2F;SQL块，均存储在数据中，并通过输<br>入，输出参数与其他调用者交换信息</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE [OR REPLACE] FUNCTION function_name</span><br><span class="line">	[ (argment [ &#123; IN | IN OUT &#125;] Type,</span><br><span class="line">argment [ &#123; IN | OUT | IN OUT &#125; ] Type ]</span><br><span class="line">	[ AUTHID DEFINER | CURRENT_USER ]</span><br><span class="line">RETURN return_type --返回值</span><br><span class="line">&#123; IS | AS &#125;</span><br><span class="line">	&lt;类型.变量的说明&gt; --变量的声明</span><br><span class="line">BEGIN</span><br><span class="line">	FUNCTION_body</span><br><span class="line">EXCEPTION</span><br><span class="line">	其它语句</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>需要注意的是：PL&#x2F;SQL中所有的参数的数据类型，<strong>返回值</strong>的数据类型的名称不能写括号</p>
<p>例如varchar2,number是正确的，varchar2(20),number(7,2)是错误的</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>无参数定义:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--创建函数,返回当前的系统日期</span><br><span class="line">create or replace function getDate</span><br><span class="line">return varchar2</span><br><span class="line">is</span><br><span class="line">	v_date varchar2(50);</span><br><span class="line">begin</span><br><span class="line">	v_date := to_char(sysdate,&#x27;yyyy-MM-dd hh24:mi:ss day&#x27;);</span><br><span class="line">	return v_date;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

<p>调用:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">declare</span><br><span class="line">	v_date varchar2(50);</span><br><span class="line">begin</span><br><span class="line">	--调用函数</span><br><span class="line">	v_date := getdate;</span><br><span class="line">	dbms_output.put_line(v_date);</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>



<p>有参数定义:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--示例2：通过员工的编号，返回员工的姓名，带参数的函数</span><br><span class="line">create or replace function getname(p_empno number)</span><br><span class="line">return varchar2</span><br><span class="line">is</span><br><span class="line">	v_ename emp.ename%type;</span><br><span class="line">begin</span><br><span class="line">	select ename into v_ename from emp where empno = p_empno;</span><br><span class="line">	return v_ename;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">--调用函数</span><br><span class="line">begin</span><br><span class="line">	dbms_output.put_line(getname(7839));</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--示例3：获取某个部门的人数和工资总和</span><br><span class="line">create or replace function getcount(</span><br><span class="line">	p_deptno emp.deptno%type, --部门号</span><br><span class="line">	p_sum out number) --工资总和</span><br><span class="line">return number</span><br><span class="line">is</span><br><span class="line">	v_count number(30);</span><br><span class="line">begin</span><br><span class="line">	select count(*),sum(sal) into v_count,p_sum from emp</span><br><span class="line">	where deptno=p_deptno  group by deptno;</span><br><span class="line">	return v_count;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">--调用函数</span><br><span class="line">declare</span><br><span class="line">	v_sum number(11);</span><br><span class="line">	v_count number(11);</span><br><span class="line">begin</span><br><span class="line">	v_count := getcount(30,v_sum);</span><br><span class="line">	dbms_output.put_line(v_count||&#x27;,&#x27;||v_sum);</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>



<h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE [OR REPLACE] PROCEDURE Procedure_name</span><br><span class="line">	[ (argment [ &#123; IN | IN OUT &#125;] Type,</span><br><span class="line">argment [ &#123; IN | OUT | IN OUT &#125; ] Type ]</span><br><span class="line">	[ AUTHID DEFINER | CURRENT_USER ]</span><br><span class="line">&#123; IS | AS &#125;</span><br><span class="line">	&lt;类型.变量的说明&gt;</span><br><span class="line">BEGIN</span><br><span class="line">	&lt;执行部分&gt;</span><br><span class="line">EXCEPTION</span><br><span class="line">	&lt;可选的异常错误处理程序&gt;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>有参数定义:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create or replace procedure gettime(p_date out varchar2)</span><br><span class="line">is</span><br><span class="line">begin</span><br><span class="line">	p_date := to_char(sysdate,&#x27;yyyy-MM-dd :hh24:mi:ss day&#x27;);</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">--调用过程</span><br><span class="line">declare</span><br><span class="line">	v_date varchar2(50);</span><br><span class="line">begin</span><br><span class="line">	gettime(v_date);</span><br><span class="line">	dbms_output.put_line(v_date);</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>



<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop function|procedure 函数名|过程名</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>博客个性化</title>
    <url>/posts/b1ed4171/</url>
    <content><![CDATA[<p><strong>概述：</strong>个性化定制hexo博客</p>
<span id="more"></span>

<h2 id="文章内部"><a href="#文章内部" class="headerlink" title="文章内部"></a>文章内部</h2><ul>
<li>实现博客主页只显示部分文章内容，只需要在<code>md</code>文件某一行插入<code>&lt;!--more--&gt;</code>。首页只会显示标记以前的内容，标记后的内容可以通过阅读更多查阅，也可以设置自动摘录。</li>
<li>或者自动摘录</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">melody.yml</span><br><span class="line">auto_excerpt:</span><br><span class="line">  enable: true</span><br><span class="line">  length: 150</span><br></pre></td></tr></table></figure>

<p>注意：使用自动摘录可能会导致代码区出错。所以如果你想在索引页中显示代码，那么你最好不要使用这个功能！</p>
<ul>
<li><p>文件开头设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: post title</span><br><span class="line">date: 2021-12-31 22:07:24</span><br><span class="line">tags: </span><br><span class="line">categories: </span><br><span class="line">password: </span><br><span class="line">---</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="hexo设置"><a href="#hexo设置" class="headerlink" title="hexo设置"></a>hexo设置</h2><h3 id="创建标签页和分类页"><a href="#创建标签页和分类页" class="headerlink" title="创建标签页和分类页"></a>创建标签页和分类页</h3><p>在网站根目录下执行以下代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page categories     #或者tags</span><br></pre></td></tr></table></figure>

<p>Hexo\source 目录中会生成一个 categories 文件夹，文件夹内有一个 index.md 文件，打开此文件，将其中的 type 修改为 categories 即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: 分类</span><br><span class="line">date: 2021-08-16 10:27:28</span><br><span class="line">type: &quot;categories&quot;           #或者tags</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure>



<h3 id="修改文章的链接"><a href="#修改文章的链接" class="headerlink" title="修改文章的链接"></a>修改文章的链接</h3><p>生成简洁且唯一的URL</p>
<p>安装插件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure>

<p>修改根目录站点配置文件<code>config.yml</code>，改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">permalink: posts/:abbrlink/</span><br><span class="line">abbrlink:</span><br><span class="line">	alg: crc32   #算法： crc16(default) and crc32</span><br><span class="line">	rep: hex     #进制： dec(default) and hex</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crc16 &amp; hex</span><br><span class="line">https://post.zz173.com/posts/66c8.html</span><br><span class="line"></span><br><span class="line">crc16 &amp; dec</span><br><span class="line">https://post.zz173.com/posts/65535.html</span><br><span class="line">crc32 &amp; hex</span><br><span class="line">https://post.zz173.com/posts/8ddf18fb.html</span><br><span class="line"></span><br><span class="line">crc32 &amp; dec</span><br><span class="line">https://post.zz173.com/posts/1690090958.html</span><br></pre></td></tr></table></figure>



<h3 id="网站信息设置"><a href="#网站信息设置" class="headerlink" title="网站信息设置"></a>网站信息设置</h3><ul>
<li>编辑 <strong>站点配置文件</strong>， 设置 <code>author</code> 为你的昵称。</li>
<li>编辑 <strong>站点配置文件</strong>， 设置 <code>description</code> 字段为你的站点描述。站点描述可以是你喜欢的一句签名:)</li>
</ul>
<h2 id="nextT主题设置"><a href="#nextT主题设置" class="headerlink" title="nextT主题设置"></a>nextT主题设置</h2><p><a href="https://blog.csdn.net/as480133937/article/details/100138838">Link1</a></p>
<p><a href="https://blog.csdn.net/u012294515/article/details/83094693">Link2</a></p>
<h3 id="隐藏底部”强力驱动“内容"><a href="#隐藏底部”强力驱动“内容" class="headerlink" title="隐藏底部”强力驱动“内容"></a>隐藏底部”强力驱动“内容</h3><p>打开 themes&#x2F;next&#x2F;layout&#x2F;_partials&#x2F;footer.swig，</p>
<p>找到下面内容，把这段代码首尾分别加上：<code>&lt;!--</code> 和<code>--&gt;</code>，或者直接删除。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.footer.powered.enable %&#125;</span><br><span class="line">&lt;div class=&quot;powered-by&quot;&gt;&#123;#</span><br><span class="line">#&#125;&#123;&#123; __(&#x27;footer.powered&#x27;, &#x27;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot;&#x27; + nofollow + &#x27; href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt;&#x27;) &#125;&#125;&#123;% if theme.footer.powered.version %&#125; v&#123;&#123; hexo_env(&#x27;version&#x27;) &#125;&#125;&#123;% endif %&#125;&#123;#</span><br><span class="line">#&#125;&lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&#123;% if theme.footer.powered.enable and theme.footer.theme.enable %&#125;</span><br><span class="line">&lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&#123;% if theme.footer.theme.enable %&#125;</span><br><span class="line">&lt;div class=&quot;theme-info&quot;&gt;&#123;#</span><br><span class="line">#&#125;&#123;&#123; __(&#x27;footer.theme&#x27;) &#125;&#125; – &#123;#</span><br><span class="line">#&#125;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot;&#123;&#123; nofollow &#125;&#125; href=&quot;https://theme-next.org&quot;&gt;&#123;#</span><br><span class="line">#&#125;NexT.&#123;&#123; theme.scheme &#125;&#125;&#123;#</span><br><span class="line">#&#125;&lt;/a&gt;&#123;% if theme.footer.theme.version %&#125; v&#123;&#123; version &#125;&#125;&#123;% endif %&#125;&#123;#</span><br><span class="line">#&#125;&lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>



<h3 id="移动端显示回顶部按钮"><a href="#移动端显示回顶部按钮" class="headerlink" title="移动端显示回顶部按钮"></a>移动端显示回顶部按钮</h3><p>主题的设计模版是 Muse 或 Mist，就可以直接在主题配置文件中配置：</p>
<p>修改主题配置<code>themes/next/_config.yml</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Enable sidebar on narrow view</span><br><span class="line">onmobile: true</span><br></pre></td></tr></table></figure>



<h3 id="站内搜索"><a href="#站内搜索" class="headerlink" title="站内搜索"></a>站内搜索</h3><p>安装插件<code>hexo-generator-searchdb</code>,执行以下命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>修改<code>hexo/_config.yml</code>站点配置文件,末尾新增以下代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>

<p>修改<code>themes/next/_config.yml</code>主题配置文件，搜索关键字<code>local_search</code>找到如下代码，将<code>enable</code>设置为<code>true</code>，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>



<h3 id="设置网站图标"><a href="#设置网站图标" class="headerlink" title="设置网站图标"></a>设置网站图标</h3><p>找一张（32 * 32）（16*16）的 ico 图标，或者去别的网站下载或者制作，并将图标名称改为 favicon.ico，然后把图标放在 <code>/themes/next/source/images</code> 里，并且修改主题配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Put your favicon.ico into `hexo-site/source/` directory.</span><br><span class="line">favicon: /favicon.ico</span><br></pre></td></tr></table></figure>



<h3 id="代码块复制选项"><a href="#代码块复制选项" class="headerlink" title="代码块复制选项"></a>代码块复制选项</h3><p>Next6 中自带了复制代码按钮， 在next的配置文件中找到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">codeblock:</span><br><span class="line">border_radius: 8   # 按钮圆滑度</span><br><span class="line">copy_button:  # 设置是否开启代码块复制按钮</span><br><span class="line">	enable: true</span><br><span class="line">	show_result: true  # 是否显示复制成功信息</span><br></pre></td></tr></table></figure>



<h3 id="文章加密访问"><a href="#文章加密访问" class="headerlink" title="文章加密访问"></a>文章加密访问</h3><p>打开<code>themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig</code>文件,找到这样一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;&#123;&#123; pace_js_uri &#125;&#125;&quot;&gt;&lt;/script&gt;</span><br><span class="line"> &lt;link href=&quot;&#123;&#123; pace_css_uri &#125;&#125;&quot; rel=&quot;stylesheet&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>然后在下面插入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  &lt;script&gt;</span><br><span class="line">    (function () &#123;</span><br><span class="line">        if (&#x27;&#123;&#123; page.password &#125;&#125;&#x27;) &#123;</span><br><span class="line">            if (prompt(&#x27;请输入文章密码&#x27;) !== &#x27;&#123;&#123; page.password &#125;&#125;&#x27;) &#123;</span><br><span class="line">                alert(&#x27;密码错误！&#x27;);</span><br><span class="line">                if (history.length === 1) &#123;</span><br><span class="line">                    location.replace(&quot;http://zxiaoxuan.cn&quot;); // 这里替换成你的首页</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    history.back();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>文章内部的开头就要添加password</p>
<h3 id="修改加载特效"><a href="#修改加载特效" class="headerlink" title="修改加载特效"></a>修改加载特效</h3><p>由于网页不可能一直都秒进，总会等待一段时间的，所以可以设置顶部加载条。</p>
<p>在主题的配置文件中搜索<code>pace</code>，找到如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pace:</span><br><span class="line">  enable: true</span><br><span class="line">  # Themes list:</span><br><span class="line">  # big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple</span><br><span class="line">  # corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal</span><br><span class="line">  theme: minimal</span><br></pre></td></tr></table></figure>





<h3 id="更改Google字体库"><a href="#更改Google字体库" class="headerlink" title="更改Google字体库"></a>更改Google字体库</h3><p>改为Google国内的字体库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">host: https://fonts.geekzu.org</span><br></pre></td></tr></table></figure>



<h3 id="博客背景图片"><a href="#博客背景图片" class="headerlink" title="博客背景图片"></a>博客背景图片</h3><ul>
<li><p>背景图片命名为<code>background.jpg</code>放入 <code>themes/next/source/images</code></p>
</li>
<li><p>在<code>themes/next/source/css/_schemes/Mist/index.styl</code>中添加CSS样式（在最后添加即可）</p>
</li>
<li><p>同时将代码添加到 blog_root&#x2F;source&#x2F;_data&#x2F;styles.style 下，设置成功。如果没有这个目录，直接新建即可。</p>
</li>
<li><p>具体设置<a href="https://www.likecs.com/show-207924.html">Link</a></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 背景图片</span><br><span class="line">body &#123;</span><br><span class="line">	background:pink;</span><br><span class="line">    background:url(/images/background.jpg);</span><br><span class="line">    background-repeat: no-repeat;</span><br><span class="line">    background-attachment:fixed; //不重复</span><br><span class="line">    background-position:top center;</span><br><span class="line">&#125;</span><br><span class="line">//博客内容透明化</span><br><span class="line">//文章内容的透明度设置</span><br><span class="line">.content-wrap &#123;</span><br><span class="line">  opacity: 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//侧边框的透明度设置</span><br><span class="line">.sidebar &#123;</span><br><span class="line">  opacity: 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//菜单栏的透明度设置</span><br><span class="line">.header-inner &#123;</span><br><span class="line">  background: rgba(255,255,255,0.9);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//搜索框（local-search）的透明度设置</span><br><span class="line">.popup &#123;</span><br><span class="line">  opacity: 0.9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">background:url 为图片路径，也可以直接使用链接。</span><br><span class="line">background-repeat：若果背景图片不能全屏，那么是否平铺显示，充满屏幕</span><br><span class="line">background-attachment：背景是否随着网页上下滚动而滚动，fixed 为固定</span><br><span class="line">background-size：图片展示大小，这里设置 100%，100% 的意义为：如果背景图片不能全屏，那么是否通过拉伸的方式将背景强制拉伸至全屏显示。</span><br></pre></td></tr></table></figure>



<h3 id="归档页优化（未）"><a href="#归档页优化（未）" class="headerlink" title="归档页优化（未）"></a>归档页优化（未）</h3><p>修改&#x2F;themes&#x2F;next&#x2F;layout&#x2F;_macro&#x2F;post-collapse.swig后的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% macro render(post) %&#125;</span><br><span class="line"></span><br><span class="line">  &lt;article class=&quot;post post-type-&#123;&#123; post.type | default(&#x27;normal&#x27;) &#125;&#125;&quot; itemscope itemtype=&quot;http://schema.org/Article&quot;&gt;</span><br><span class="line">    &lt;header class=&quot;post-header&quot;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;&#123;% if theme.seo %&#125;h3&#123;% else %&#125;h2&#123;% endif %&#125; class=&quot;post-title&quot;&gt;</span><br><span class="line">        &#123;% if post.link %&#125;&#123;# Link posts #&#125;</span><br><span class="line">          &lt;a class=&quot;post-title-link post-title-link-external&quot; target=&quot;_blank&quot; href=&quot;&#123;&#123; url_for(post.link) &#125;&#125;&quot; itemprop=&quot;url&quot;&gt;</span><br><span class="line">            &#123;&#123; post.title or post.link &#125;&#125;</span><br><span class="line">            &lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;</span><br><span class="line">          &lt;/a&gt;</span><br><span class="line">        &#123;% else %&#125;</span><br><span class="line">            &lt;a class=&quot;post-title-link&quot; href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot; itemprop=&quot;url&quot;&gt;</span><br><span class="line">              &#123;% if post.type === &#x27;picture&#x27; %&#125;</span><br><span class="line">                &#123;&#123; post.content &#125;&#125;</span><br><span class="line">              &#123;% else %&#125;</span><br><span class="line">                &lt;span itemprop=&quot;name&quot;&gt;&#123;&#123; post.title | default(__(&#x27;post.untitled&#x27;)) &#125;&#125;&lt;/span&gt;</span><br><span class="line">              &#123;% endif %&#125;</span><br><span class="line">            &lt;/a&gt;</span><br><span class="line">        &#123;% endif %&#125;</span><br><span class="line">      &lt;/&#123;% if theme.seo %&#125;h3&#123;% else %&#125;h2&#123;% endif %&#125;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;div class=&quot;post-meta&quot;&gt;</span><br><span class="line">        &lt;time class=&quot;post-time&quot; itemprop=&quot;dateCreated&quot;</span><br><span class="line">              datetime=&quot;&#123;&#123; moment(post.date).format() &#125;&#125;&quot;</span><br><span class="line">              content=&quot;&#123;&#123; date(post.date, config.date_format) &#125;&#125;&quot; &gt;</span><br><span class="line">          &#123;&#123; date(post.date, &#x27;MM-DD&#x27;) &#125;&#125;</span><br><span class="line">        &lt;/time&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/header&gt;</span><br><span class="line">  &lt;/article&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endmacro %&#125;</span><br></pre></td></tr></table></figure>



<h3 id="追加版权信息（未）"><a href="#追加版权信息（未）" class="headerlink" title="追加版权信息（未）"></a>追加版权信息（未）</h3><ol>
<li>修改主题<code>配置文件</code>,搜索<code>post_copyright</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">post_copyright:</span><br><span class="line">- enable: false</span><br><span class="line">+ enable: true</span><br><span class="line">  license: CC BY-NC-SA 3.0</span><br><span class="line">  license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>如果觉得默认不好看,则可以自定义样式,找到<code>themes/next/layout/_macro/post.swig</code>，在<code>footer</code>之前添加如下代码(添加之前确保已添加样式)：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">	  &lt;p id=&quot;div-border-left-red&quot;&gt;</span><br><span class="line">	   &lt;b&gt;本文基于&lt;a target=&quot;_blank&quot; title=&quot;Creative Commons Attribution-ShareAlike 4.0 International (CC BY-SA 4.0)&quot; href=&quot;http://creativecommons.org/licenses/by-sa/4.0/&quot;&gt; 知识共享署名-相同方式共享 4.0 &lt;/a&gt;国际许可协议发布&lt;/b&gt;&lt;br/&gt;</span><br><span class="line">	    &lt;span&gt;</span><br><span class="line">	    &lt;b&gt;本文地址：&lt;/b&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot; title=&quot;&#123;&#123; page.title &#125;&#125;&quot;&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt;&lt;br/&gt;&lt;b&gt;转载请注明出处，谢谢！&lt;/b&gt;</span><br><span class="line">	    &lt;/span&gt;</span><br><span class="line">	  &lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="动态title（未）"><a href="#动态title（未）" class="headerlink" title="动态title（未）"></a>动态title（未）</h3><p><code>themes/next/source/js/src</code>下创建<code>dytitle.js</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var OriginTitile = document.title;</span><br><span class="line">var titleTime;</span><br><span class="line">document.addEventListener(&#x27;visibilitychange&#x27;, function () &#123;</span><br><span class="line">    if (document.hidden) &#123;</span><br><span class="line">        $(&#x27;[rel=&quot;shortcut icon&quot;]&#x27;).attr(&#x27;href&#x27;, &quot;/TEP.png&quot;);</span><br><span class="line">        document.title = &#x27;w(ﾟДﾟ)w 出BUG啦！！！！&#x27;;</span><br><span class="line">        clearTimeout(titleTime);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        $(&#x27;[rel=&quot;shortcut icon&quot;]&#x27;).attr(&#x27;href&#x27;, &quot;/favicon.png&quot;);</span><br><span class="line">        document.title = &#x27;♪(^∇^*)又好了。。。 &#x27; + OriginTitile;</span><br><span class="line">        titleTime = setTimeout(function () &#123;</span><br><span class="line">            document.title = OriginTitile;</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h3 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h3><p>修改字段 <code>avatar</code>， 值设置成头像的链接地址。</p>
<p>地址可以是URI，也可以是主题<code>source/images/</code>目录下</p>
<h3 id="设置“订阅”"><a href="#设置“订阅”" class="headerlink" title="设置“订阅”"></a>设置“订阅”</h3><p>在主题配置文件中，找到<code>follow_me</code>下面可以设置RSS</p>
<p>切换到根目录下，然后运行如下代码，安装<code>hexo-generator-feed</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install --save hexo-generator-feed</span><br></pre></td></tr></table></figure>

<p>在<code>hexo</code>的<code>_config.yml</code>中，在最后添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: http://hexo.io/plugins/</span><br><span class="line">plugins: hexo-generate-feed</span><br></pre></td></tr></table></figure>



<h3 id="添加自定义菜单"><a href="#添加自定义菜单" class="headerlink" title="添加自定义菜单"></a>添加自定义菜单</h3><p>以新建「相册」菜单为例：在博客目录下的 source 文件夹下新建名为 photo 文件夹，然后在 photo 文件夹下新建一个 <a href="https://link.juejin.im/?target=http://index.md">index.md</a> 文件，然后在该文件填写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 相册</span><br><span class="line">date: 2018-04-16 22:14:07</span><br><span class="line">type: &quot;photo&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>然后打开主题配置文件 <code>_config.yml</code>，在 menu 中添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  archives: /archives || archive</span><br><span class="line">  categories: /categories || th</span><br><span class="line">  tags: /tags || tags</span><br><span class="line">  #添加了「相册」菜单</span><br><span class="line">  相册: /photo || camera</span><br></pre></td></tr></table></figure>

<blockquote>
<p><em>解释下：这里的「相册」是博客中显示的菜单名称，紧跟的 photo 要和前面 index.md 文件的 type 值一致，|| 后面的菜单的图标，图标名称来自于 FontAwesome icon，若没有配置图标，默认会使用问号图标。</em></p>
</blockquote>
<h3 id="设置文章封面"><a href="#设置文章封面" class="headerlink" title="设置文章封面"></a>设置文章封面</h3><p>如果只是插入本地图片作为文章封面，即在博客首页的时候会显示文章的封面图片，进入这篇文章的详细页面后，将不显示这张图片。</p>
<p>按如下方式操作：</p>
<p>1）修改 <code>\themes\next\layout\_macro\post.swing</code> 文件。将如下代码复制：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% if post.summary_img  %&#125;</span><br><span class="line">  &lt;div class=&quot;out-img-topic&quot;&gt;</span><br><span class="line">    &lt;img src=&#123;&#123; post.summary_img &#125;&#125; class=&quot;img-topic&quot;&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>2）在新建的文章添加一个字段属性：<code>summary_img</code>。<code>summary_img</code> 的值是图片的路径，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: CSS 各种Hack手段</span><br><span class="line">date: 2017-06-25 03:25:24</span><br><span class="line">categories: 前端</span><br><span class="line">tags: [CSS]</span><br><span class="line">comments: false</span><br><span class="line">summary_img: /images/css-hack-1.png</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<blockquote>
<p>图片存放的文件夹只能新建在 <code>source</code> 目录下。</p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle3</title>
    <url>/posts/293bc84/</url>
    <content><![CDATA[<p><strong>概述</strong>：Oracle数据库中的视图、序列、索引、约束、事务</p>
<span id="more"></span>

<h2 id="视图（view）-虚表"><a href="#视图（view）-虚表" class="headerlink" title="视图（view）-虚表"></a>视图（view）-虚表</h2><p><strong>特点</strong>：</p>
<ul>
<li>本身并不包含任何数据</li>
<li>对应于一条select语句，结果集被赋予一个名字，即视图的名字，</li>
<li>当基表数据发生变化，视图数据也随之变化</li>
</ul>
<p><strong>作用</strong>：</p>
<ul>
<li>简化复杂查询</li>
<li>限制数据访问</li>
</ul>
<p><strong>分类</strong>：简单（单表，无运算）、复杂（单表，有运算）、连接（多表）</p>
<p><strong>建立</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace  视图名 <span class="keyword">as</span> <span class="keyword">select</span> 子句 </span><br><span class="line"><span class="comment">---------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> v_emp <span class="keyword">as</span> <span class="keyword">select</span> ename,hirdate <span class="keyword">from</span> emp;<span class="comment">--简单</span></span><br><span class="line">#查询视图上的数据,与操作表一致</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> v_emp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> v_emp1 <span class="keyword">as</span> <span class="keyword">select</span> deptno,<span class="built_in">count</span>(<span class="operator">*</span>) count,<span class="built_in">min</span>(sal) min <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> deptno; <span class="comment">--复杂</span></span><br></pre></td></tr></table></figure>



<p><strong>修改</strong>：简单（update、delete语句，影响基表数据）、复杂（不允许）</p>
<p>​			只读视图：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> 试图名 <span class="keyword">as</span> <span class="keyword">select</span> 子句 <span class="keyword">with</span> read <span class="keyword">only</span>;</span><br></pre></td></tr></table></figure>

<p><strong>删除</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> 视图名</span><br></pre></td></tr></table></figure>



<h2 id="序列（sequence）"><a href="#序列（sequence）" class="headerlink" title="序列（sequence）"></a>序列（sequence）</h2><p><strong>特点</strong>：oracle提供的用于产生一系列唯一数字值的数据库对象</p>
<p><strong>作用</strong>：oracle数据库中主要用序列来实现主键自增的功能</p>
<p><strong>建立</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> SEQUENCE sequence #创建序列名称</span><br><span class="line">[INCREMENT <span class="keyword">BY</span> n] #递增的序列值是 n 如果 n 是正数就递增,如果是负数就递减 默认是 <span class="number">1</span></span><br><span class="line">[<span class="keyword">START</span> <span class="keyword">WITH</span> n] #开始的值,递增默认是 minvalue 递减是 maxvalue</span><br><span class="line">[&#123;MAXVALUE n <span class="operator">|</span> NOMAXVALUE&#125;] #最大值 </span><br><span class="line">[&#123;MINVALUE n <span class="operator">|</span> NOMINVALUE&#125;] #最小值</span><br><span class="line">[&#123;<span class="keyword">CYCLE</span> <span class="operator">|</span> NOCYCLE&#125;] #循环<span class="operator">/</span>不循环</span><br><span class="line">[&#123;CACHE n <span class="operator">|</span> NOCACHE&#125;];#分配并存入到内存中，默认<span class="number">20</span>个</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> sequence dept_seq</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> <span class="number">100</span></span><br><span class="line">increment <span class="keyword">by</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p><strong>使用</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--使用nextval获取序列的下一个值，currval获取序列的当前值</span></span><br><span class="line"><span class="keyword">select</span> dept_seq.nextval <span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">select</span> dept_seq.currval <span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp <span class="keyword">values</span>(dept_seq.nextval,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p><strong>删除</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> sequence 序列名;</span><br></pre></td></tr></table></figure>



<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p><strong>特点</strong>：允许直接访问数据表中某一数据行的树型结构</p>
<ul>
<li>一旦建立就将被oracle系统自动维护</li>
<li>查询语句中不用指定使用哪个索引，会自动使用</li>
<li>I&#x2F;O操作比对表的操作要少很多</li>
<li>独立于表的对象， 可以存放在与表不同的表空间中</li>
</ul>
<p><strong>原则</strong>：</p>
<ul>
<li>适合建立索引的列<ul>
<li>主键列和唯一约束列一定要建立索引，主键列，唯一约束的列，数据库会自动创建索引</li>
<li>经常查询的数据列</li>
<li>经常出现在where子句中的列</li>
</ul>
</li>
<li>不适合<ul>
<li>常修改的，少量数据的，重复值多的</li>
</ul>
</li>
</ul>
<p><strong>分类</strong>：聚集索引（索引的顺序和表的记录的顺序一致）、非聚集索引、单列索引、多列索引</p>
<p><strong>建立</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> index 索引名 <span class="keyword">on</span> 表名(字段)</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> index emp_ename <span class="keyword">on</span> emp(ename);</span><br></pre></td></tr></table></figure>

<p><strong>删除</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> index 索引名</span><br></pre></td></tr></table></figure>





<h2 id="约束（constraint）"><a href="#约束（constraint）" class="headerlink" title="约束（constraint）"></a>约束（constraint）</h2><p><strong>特点</strong>：</p>
<ul>
<li>在数据表上强制执行的一些数据校验规则，当执行DML语句时，数据必须符合这些规则，如果不符合则无法执行</li>
<li>可以保证数据表中数据的完整性，保证数据间的商业逻辑</li>
</ul>
<p><strong>分类</strong>：</p>
<ul>
<li>非空约束（not null）<br>非空约束简称nn，约束列的值不能是空值</li>
<li>唯一约束(unique)<br>唯一约束简称uk，约束列值必须是唯一的值</li>
<li>主键约束(primary key)<br>主键约束简称pk，约束列的值必须是非空且唯一的值</li>
<li>外键约束(foregin key)<br>外键约束通常用来表示两个表的关系，通常是主从关系，约束从表中的数据必须参考主表的数据</li>
<li>检查约束(check)<br>检查约束通过一定的约束条件来限定列的值的范围，比如说限制某列的值只能是男或者女</li>
</ul>
<p><strong>建立</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test1(</span><br><span class="line">id number(<span class="number">4</span>) <span class="keyword">primary</span> key,</span><br><span class="line">name varchar2(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">email varchar2(<span class="number">30</span>),</span><br><span class="line">gender <span class="type">char</span>(<span class="number">1</span>),</span><br><span class="line"><span class="keyword">constraint</span> emial_un <span class="keyword">unique</span>(email),</span><br><span class="line"><span class="keyword">constraint</span> gender_ck <span class="keyword">check</span>(gender<span class="operator">=</span><span class="string">&#x27;M&#x27;</span> <span class="keyword">or</span> gender<span class="operator">=</span><span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">--------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="keyword">constraint</span> 约束名 约束类型(字段);</span><br><span class="line">#为student表的name列添加唯一约束</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">add</span> <span class="keyword">constraint</span> test1_pk <span class="keyword">unique</span>(name);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--外键约束通常用来表示两个表的关系，通常是主从关系，约束从表中的数据必须参考主表的数据</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp1 (</span><br><span class="line">id number(<span class="number">4</span>),</span><br><span class="line">deptno number(<span class="number">4</span>),</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">40</span>),</span><br><span class="line"><span class="keyword">constraint</span> emp_dept_fk foregin key(deptno) <span class="keyword">references</span> dept(deptno)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp1 <span class="keyword">add</span> <span class="keyword">constraint</span> emp1_dept_fk <span class="keyword">foreign</span> key(deptno) <span class="keyword">references</span></span><br><span class="line">dept(deptno);</span><br><span class="line"></span><br><span class="line"><span class="comment">--存在主外键关系的表，在删除数据时，需要把有外键关系的所有数据全部删除后，才能删除主表的数据</span></span><br></pre></td></tr></table></figure>

<p><strong>删除</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">constraint</span> 约束名</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">drop</span> <span class="keyword">constraint</span> test1_pk;</span><br><span class="line"></span><br><span class="line"><span class="comment">--删主键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">primary</span> key;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">drop</span> <span class="keyword">primary</span> key;</span><br></pre></td></tr></table></figure>



<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p><strong>特点</strong>：工作的逻辑单元,一个事务是由一个或多个完成一组的相关行为的<code>SQL</code>语句组成</p>
<ul>
<li>确保数据库的完整性<ul>
<li>原子性(Atomicity)</li>
<li>一致性(Consistency)</li>
<li>隔离性(Isolation)</li>
<li>持久性(durability)</li>
</ul>
</li>
<li>所有的事务都是隐式开始的</li>
<li>须显示使用commit和rollback语句结束</li>
<li>默认未非自动提交事务模式</li>
</ul>
<p><strong>控制语句</strong>：</p>
<ul>
<li>Set transaction 设置事物属性</li>
<li>Set constrains 设置事物的约束模式</li>
<li>约束模式是指：在事务中修改数据时,数据库中的约束立即应用于数据,还是将约束推迟到当前事务结束后应用。</li>
<li>Savepoint 在事务中建立一个存储的点.当事务处理发生异常而回滚事务时,可指定事务回滚到某存储点.然后从该存储点重新执行。</li>
<li>Release savepoint 删除存储点</li>
<li>Rollback 回滚事务 取消对数据库所作的任何操作 rollback to 存储点</li>
<li>Commit 提交事务 对数据库的操作做持久的保存。</li>
</ul>
<p><strong>隔离不当结果</strong>：</p>
<ul>
<li>第一类丢失更新———-撤销一个事务时，把其他事务已提交的更新数据也撤销了</li>
<li>脏读————————–一个事务读到了另一个事务未提交的更新数据</li>
<li>不可重复读—————–一个事务读到另一个事务已经提交的更改数据</li>
<li>第二类丢失更新———–一个事务覆盖另一个事务已经提交的更改数据</li>
<li>幻读—————————一个事务读到另一个事务已经提交的新增或已删除的数据</li>
</ul>
<p><strong>操作</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> autocommit;<span class="comment">--查看</span></span><br><span class="line"><span class="keyword">set</span> autocommit <span class="keyword">on</span><span class="operator">|</span>off;更改</span><br><span class="line">#提交和结束事务</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line">#回滚事务</span><br><span class="line"><span class="keyword">rollback</span> [<span class="keyword">to</span> 回滚点];</span><br><span class="line">#设置事务回滚点</span><br><span class="line"><span class="keyword">savepoint</span> 回滚点;</span><br><span class="line">#删除回滚点</span><br><span class="line"><span class="keyword">release</span> 回滚点;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell</title>
    <url>/posts/4592b2fd/</url>
    <content><![CDATA[<p><strong>概述：</strong>Linux中的shell脚本的编写</p>
<span id="more"></span>

<h1 id="shell编程"><a href="#shell编程" class="headerlink" title="shell编程"></a>shell编程</h1><h2 id="基础了解"><a href="#基础了解" class="headerlink" title="基础了解"></a>基础了解</h2><p>c语言编写</p>
<p><img src="https://s2.loli.net/2022/06/18/VzDP9Q5d8avXfUH.png" alt="shell1"></p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>默认为<code>/bin/bash</code>， 其他<code>ash, bash, ksh, csh, zsh</code>等</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看有哪些解释器</span></span><br><span class="line">cat /etc/shells </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">切换，直接输入相应的解释器名称如</span></span><br><span class="line">ash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以直接安装相应的shell解释器</span></span><br></pre></td></tr></table></figure>

<p>默认解释器<code>/bin/bash</code>的优点</p>
<ol>
<li>tab补全</li>
<li>历史命令 history [n] n为数字； !n 可以执行指定的n行的命令</li>
<li>有快捷键，支持管道和重定向</li>
</ol>
<h3 id="简单入门"><a href="#简单入门" class="headerlink" title="简单入门"></a>简单入门</h3><ol>
<li>声明解释器<code>#!/bin/bash</code></li>
<li>编写注释, 如<code>#这是一个测试shell脚本</code></li>
<li>执行指令<code>echo helloWorld</code> ，理论上，执行指令可以写无限条，非交互式的指令</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim hello.sh     #注意文件后缀，以下是文件内容</span><br><span class="line">----------------------------------</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这是一脚本</span></span><br><span class="line">echo hellWorld</span><br><span class="line">----------------------------------</span><br><span class="line">:wq				 #退出vim</span><br><span class="line">----------------------------------</span><br><span class="line">chmod +x hello.sh#设置权限，全局</span><br><span class="line">/opt/hello.sh 	 #绝对路径</span><br><span class="line"></span><br><span class="line">bash /opt/hello.sh#直接使用解释器，但会开启新的子进程</span><br><span class="line"></span><br><span class="line">source /opt/hello.sh#实质上使用的默认的解释器 ，不会开启解释器子进程</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 搭建yum仓库</span><br><span class="line">1. 挂载光盘文件到/mnt---------------</span><br><span class="line">mount /dev/cdrom /mnt</span><br><span class="line"></span><br><span class="line">2. 先备份yum仓库配置----------------</span><br><span class="line">mkdir /etc/yum.repo.d/bak</span><br><span class="line">mv /etc/yum.repo.d/*/repo</span><br><span class="line"></span><br><span class="line">3. 在/opt下编写脚本yum.sh，内容如下--</span><br><span class="line">#!/bin/bash</span><br><span class="line">#搭建软件仓库</span><br><span class="line">rm -rf /etc/yum.repos.d/*.repo</span><br><span class="line">echo &quot;[abc]</span><br><span class="line">name=abctest</span><br><span class="line">baseurl=file:///mnt</span><br><span class="line">gpgcheck=0&quot; &gt;&gt; abc.repo</span><br><span class="line"></span><br><span class="line">4. 执行脚本</span><br><span class="line">chmod +x /opt/yum.sh</span><br><span class="line">/opt/yum.sh</span><br><span class="line"></span><br><span class="line">5. 执行成功，验证域名仓库是否搭建成功</span><br><span class="line">yum repolist</span><br></pre></td></tr></table></figure>



<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ol>
<li>不能以数字开头</li>
<li>等号左右不留空格</li>
<li>双引号括起来的内容<code>“$”</code>，<code>“(” </code>和反引号都拥有特殊含义，而单引号括起来的内容都是普通字符</li>
<li>需要增加变量的值,用双引号包含<code>&quot;$变量名&quot;</code>或用<code>$&#123;变量名&#125;</code>包含变量名</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">调用</span></span><br><span class="line">[root@localhost ~]# name=zhangsan</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">调用变量来使用,语法：$变量名</span></span><br><span class="line">[root@localhost ~]# echo $name</span><br><span class="line">zhangsan</span><br><span class="line">[root@localhost ~]# a=10</span><br><span class="line">[root@localhost ~]# echo $&#123;a&#125;RMB</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置</span><br><span class="line">命令 set[选项]</span><br><span class="line"></span><br><span class="line">-u: 如果设定此选项，调用未声明的选项时会报错，默认无任何提示</span><br><span class="line">-x: 如果设定此选项，在命令执行之前，会把命令先输出一次</span><br><span class="line">+参数: 取消某个set曾启动的参数</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 删除</span><br><span class="line">unset [变量名]</span><br></pre></td></tr></table></figure>



<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USER			当前用户名</span><br><span class="line">HOME			当前用户的家目录</span><br><span class="line">UID				当前用户的id号</span><br><span class="line">SHELL			当前用户的解释器</span><br><span class="line">PWD				当前位置</span><br><span class="line">PS1				一级提示符</span><br><span class="line">PS2				二级提示符</span><br><span class="line">PATH			存储执行指令的目录</span><br><span class="line">env 			查看所有环境变量</span><br><span class="line"></span><br><span class="line">RANDOM 			可以产生随机数</span><br></pre></td></tr></table></figure>

<h3 id="预定义变量与位置变量"><a href="#预定义变量与位置变量" class="headerlink" title="预定义变量与位置变量"></a>预定义变量与位置变量</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$n			n为数字，$0表示当前 Shell 脚本程序的名称，$1-9 代 表 第 一 到 第 九个 参 数 , 十 以上 的 参 数 需 要 用 大 括 号 包 含 ， 如 9代表第一到第九个参数,十以上的参数需要用大括号包含，如9代表第一到第九个参数,十以上的参数需要用大括号包含，如&#123;10&#125;</span><br><span class="line"></span><br><span class="line">$* 			这个变量代表命令行中所有的参数，$把所有的参数看成一个整体</span><br><span class="line">$@ 			这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待</span><br><span class="line">$# 			这个变量代表命令行中所有参数的个数</span><br><span class="line">$$ 			随机进程号</span><br><span class="line">$? 			判断上一个任务是否成功，0表示成功，非0表示失败</span><br></pre></td></tr></table></figure>

<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><h4 id="单双引号"><a href="#单双引号" class="headerlink" title="单双引号"></a>单双引号</h4><p>单引号：可以屏蔽特殊符号，直接当成字符串来处理</p>
<p>双引号：界定范围，不可屏蔽特殊字符</p>
<h4 id="反撇号-96-与"><a href="#反撇号-96-与" class="headerlink" title="反撇号&#96;与$()"></a>反撇号&#96;与$()</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=date</span><br><span class="line">echo $a #输出结果 date</span><br><span class="line"></span><br><span class="line">a=`date`</span><br><span class="line">echo $a #输出结果2021年 09月 23日 星期四 21:10:08 CST</span><br><span class="line"></span><br><span class="line">a=$(date)</span><br><span class="line">echo $a #输出结果2021年 09月 23日 星期四 21:10:08 CST</span><br></pre></td></tr></table></figure>



<h4 id="read交互式指令"><a href="#read交互式指令" class="headerlink" title="read交互式指令"></a>read交互式指令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read -p “提示的信息” 变量名</span><br><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line">read -p &quot;请输入用户名：&quot; u</span><br><span class="line">useradd $u</span><br><span class="line">read -p &quot;请输入密码：&quot; p</span><br><span class="line">echo &quot;$p&quot; | passwd --stdin $u</span><br></pre></td></tr></table></figure>



<h4 id="屏蔽输入"><a href="#屏蔽输入" class="headerlink" title="屏蔽输入"></a>屏蔽输入</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">接上例</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">read -p &quot;请输入用户名：&quot; u</span><br><span class="line">useradd $u</span><br><span class="line">stty -echo						#屏蔽输入信息</span><br><span class="line">read -p &quot;请输入密码：&quot; p</span><br><span class="line">stty echo						#显示输入信息</span><br><span class="line">echo &quot;$p&quot; | passwd --stdin $u</span><br></pre></td></tr></table></figure>



<h4 id="定义全局变量"><a href="#定义全局变量" class="headerlink" title="定义全局变量"></a>定义全局变量</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export b=20 			#定义变量的同时，并发布为全局效果</span><br><span class="line">a=200 					#定义普通变量</span><br><span class="line">export a 				#将已有的变量发布为全局变量</span><br><span class="line">export -n a 			#取消全局效果，恢复局部效果</span><br></pre></td></tr></table></figure>



<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># expr可以在运算的同时将结果输出</span><br><span class="line">expr 3 – 1  		减法</span><br><span class="line">expr 2 + 2  		加法</span><br><span class="line">expr 2 &#x27;*&#x27; 2  		乘法</span><br><span class="line">expr 2 \* 2   		使用乘法时，这里使用\代表转义符号，可以屏蔽之后1个字符的特殊效果</span><br><span class="line">expr 4 / 2  		除法</span><br><span class="line">expr 10 % 3  		取余数</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 用$[ ]结构，配合echo输出，同样可以实现加 减 乘 除 取余</span><br><span class="line">echo $[1+1]</span><br><span class="line">echo $[2-1]</span><br><span class="line">echo $[2*2]</span><br><span class="line">echo $[4/2]</span><br><span class="line">echo $[5%3]</span><br><span class="line"></span><br><span class="line">$(())与$[]效果一致</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># let指令，不输出计算结果，专用于创建变量，或者对变量进行自增减</span><br><span class="line">let a=1+1</span><br><span class="line">let a++</span><br><span class="line">let a*=10</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># bc指令可以处理小数的结果 ，参数scale=n可以指定小数保留的位数,quit退出bc模式</span><br><span class="line">echo &quot;10/3&quot; | bc</span><br><span class="line">echo &quot;scal=3;10/3&quot; | bc</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 关系运算符只支持数字，不支持字符串，除非字符串的值是数字</span><br><span class="line">-eq</span><br><span class="line">equal</span><br><span class="line">检测两个数是否相等，相等返回true。</span><br><span class="line">[ $a -eq $b ] 返回 false。</span><br><span class="line"></span><br><span class="line">-ne</span><br><span class="line">not equal</span><br><span class="line">检测两个数是否相等，不相等返回true。</span><br><span class="line">[ $a -ne $b ] 返回 true。</span><br><span class="line"></span><br><span class="line">-gt </span><br><span class="line">great than</span><br><span class="line">检测左边的数是否大于右边的，如果是，则返回 true。</span><br><span class="line">[ $a -gt $b ] 返回 false。</span><br><span class="line"></span><br><span class="line">-lt </span><br><span class="line">less than</span><br><span class="line">检测左边的数是否小于右边的，如果是，则返回 true。</span><br><span class="line">[ $a -lt $b ] 返回 true。</span><br><span class="line"></span><br><span class="line">-ge</span><br><span class="line">great than or equal</span><br><span class="line">检测左边的数是否大于等于右边的，如果是，则返回 true。</span><br><span class="line">[ $a -ge $b ] 返回 false。</span><br><span class="line"></span><br><span class="line">-le</span><br><span class="line">less than or equal</span><br><span class="line">检测左边的数是否小于等于右边的，如果是，则返回 true。</span><br><span class="line">[ $a -le $b ] 返回 true。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">！</span><br><span class="line">非运算，表达式为 true 则返回 false，否则返回 true</span><br><span class="line">[ ! false ] 返回 true。</span><br><span class="line"></span><br><span class="line">-o</span><br><span class="line">或（或者）运算，有一个表达式为 true则返回 true。</span><br><span class="line">[ $a -lt 20 -o $b -gt 100 ] 返回 true。</span><br><span class="line"></span><br><span class="line">-a</span><br><span class="line">与（并且）运算，两个表达式都为 true才返回 true。</span><br><span class="line">[ $a -lt 20 -a $b -gt 100 ] 返回 false。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 字符串运算</span><br><span class="line">!=</span><br><span class="line">检测两个字符串是否相等，不相等返回true。</span><br><span class="line">[ $a != $b ] 返回true。</span><br><span class="line"></span><br><span class="line">=</span><br><span class="line">检测两个字符串是否相等，相等返回true。</span><br><span class="line">[ $a = $b ] 返回false。</span><br><span class="line"></span><br><span class="line">-z </span><br><span class="line">检测字符串长度是否为0，为0返回 true。 </span><br><span class="line">[ -z $a ] 返回 false。</span><br><span class="line"></span><br><span class="line">-n</span><br><span class="line">检测字符串长度是否为0，不为0返回true。</span><br><span class="line">[ -n $a ] 返回 true。</span><br><span class="line"></span><br><span class="line">str </span><br><span class="line">检测字符串是否为空，不为空返回 true。 </span><br><span class="line">[ $a ] 返回 true。</span><br><span class="line">------------------------------------------------------</span><br><span class="line">[ a == a ] 判断字符串a是否等于a，如果相等，返回值就是0</span><br><span class="line">[ root == $USER ] 判断当前用户名是否叫root，如果是，返回值就是0</span><br><span class="line">[ root != $USER ] 判断当前用户名是否不叫root，如果不叫root，返回值就是0</span><br><span class="line">[ -z $a ] 判断变量a是否为空，如果是，返回值是0</span><br><span class="line">[ ! -z $a ] 判断变量a是否不为空，如果是，返回true，0</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 文件测试运算符</span><br><span class="line">-b [file]</span><br><span class="line">检测文件是否是块设备文件，如果是，则返回 true。</span><br><span class="line">[ -b $file ] 返回 false。</span><br><span class="line"></span><br><span class="line">-c [file]</span><br><span class="line">检测文件是否是字符设备文件，如果是，则返回true。</span><br><span class="line">[ -c $file ] 返回 false。</span><br><span class="line"></span><br><span class="line">-d [file]</span><br><span class="line">检测文件是否是目录，如果是，则返回 true。</span><br><span class="line">[ -d $file ] 返回 false。</span><br><span class="line"></span><br><span class="line">-f [file]</span><br><span class="line">检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</span><br><span class="line">[ -f $file ] 返回 true。</span><br><span class="line"></span><br><span class="line">-g [file]</span><br><span class="line">检测文件是否设置了 SGID 位，如果是，则返回true。</span><br><span class="line">[ -g $file ] 返回 false。</span><br><span class="line"></span><br><span class="line">-k [file]</span><br><span class="line">检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</span><br><span class="line">[ -k $file ] 返回 false。</span><br><span class="line"></span><br><span class="line">-p [file]</span><br><span class="line">检测文件是否是有名管道，如果是，则返回 true。</span><br><span class="line">[ -p $file ] 返回 false。</span><br><span class="line"></span><br><span class="line">-u [file]</span><br><span class="line">检测文件是否设置了 SUID 位，如果是，则返回true。</span><br><span class="line">[ -u $file ] 返回 false。</span><br><span class="line"></span><br><span class="line">-r [file]</span><br><span class="line">检测文件是否可读，如果是，则返回 true。</span><br><span class="line">[ -r $file ] 返回 true。</span><br><span class="line"></span><br><span class="line">-w [file]</span><br><span class="line">检测文件是否可写，如果是，则返回 true。</span><br><span class="line">[ -w $file ] 返回 true</span><br><span class="line"></span><br><span class="line">-x [file]</span><br><span class="line">检测文件是否可执行，如果是，则返回 true。</span><br><span class="line">[ -x $file ] 返回 true。</span><br><span class="line"></span><br><span class="line">-s [file]</span><br><span class="line">检测文件是否为空（文件大小是否大于0），不为空返回 true。</span><br><span class="line">[ -s $file ] 返回 true。</span><br><span class="line"></span><br><span class="line">-e [file]</span><br><span class="line">检测文件（包括目录）是否存在，如果是，则返回true。</span><br><span class="line">[ -e $file ] 返回 true。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">if 条件测试 ;then </span><br><span class="line">	执行指令 </span><br><span class="line">fi</span><br><span class="line">---------------------------------------</span><br><span class="line">if 条件测试 ;then</span><br><span class="line">	执行指令</span><br><span class="line">else</span><br><span class="line">	执行指令</span><br><span class="line">fi</span><br><span class="line">---------------------------------------</span><br><span class="line">if 条件测试;then</span><br><span class="line">	执行指令</span><br><span class="line">elif 条件测试;then</span><br><span class="line">	执行指令</span><br><span class="line">elif 条件测试;then</span><br><span class="line">	执行指令</span><br><span class="line">else</span><br><span class="line">	执行指令</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for 变量名 in 值1 值2 值3</span><br><span class="line">do</span><br><span class="line">	执行指令</span><br><span class="line">done</span><br><span class="line">---------------------------------------</span><br><span class="line">for i in &#123;1..10&#125; 使用常量循环十次</span><br><span class="line"></span><br><span class="line">a=10</span><br><span class="line">for i in $(seq $a)  使用seq命令可以调用变量</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while 条件测试</span><br><span class="line">do</span><br><span class="line">	执行指令</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>linux-centOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle2</title>
    <url>/posts/75948c12/</url>
    <content><![CDATA[<p><strong>概述：</strong>SQL语句的使用</p>
<span id="more"></span>

<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><p>结构化查询语言，<code>SQL92</code>标准</p>
<p>不同数据库厂商又在标准的基础上进行了<strong>个性的扩充</strong></p>
<p>如：Oracle中字符串使用<code>varchar2</code>，而<code>mysql</code>中使用<code>varchar</code></p>
<p>​		Oracle习惯全大写：USER_NAME，<code>mysql</code>习惯全小写：user_name</p>
<p>​		Oracle区分字符串大小写，<code>Mysql</code>不区分字符串大小写</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li><p>DQL-数据查询语言</p>
<blockquote>
<p>SELECT, FROM, WHERE, GROUP BY, HAVING, ORDER BY</p>
</blockquote>
</li>
<li><p>DML-数据操纵语言</p>
<blockquote>
<p>INSERT, UPDATE, DELETE</p>
</blockquote>
</li>
<li><p>DDL-数据定义语言</p>
<blockquote>
<p>CREATE, ALTER, DROP</p>
</blockquote>
</li>
<li><p>DCL-数据控制语言</p>
<blockquote>
<p>GRANT, REVOKE</p>
</blockquote>
</li>
</ul>
<h2 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h2><p>二维表：记录和字段构成</p>
<p>命名规则：多个单词用下划线隔开</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><table>
<thead>
<tr>
<th align="left">数据类型(字符)</th>
<th align="left">参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">char(n)</td>
<td align="left">n&#x3D;1 to 2000 字节</td>
<td>定长字符串，默认值为1个字节长(一个汉字2个字节长)，不足用空格填充</td>
</tr>
<tr>
<td align="left">varchar2(n)</td>
<td align="left">n&#x3D;1 to 4000 字节</td>
<td>可变长的字符串，指明最大长度n。数据前后有空格，Oracle 8i会自动将其删去。索引的最大长度3209</td>
</tr>
</tbody></table>
<p><strong>注</strong>：不同数据库版本长度限制可能会有不同</p>
<table>
<thead>
<tr>
<th>数据类型(数字)</th>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>number(m, n)</td>
<td>m&#x3D;1 to 38<br>n&#x3D;-84 to 127</td>
<td>可变长的数值列,m是所有<strong>有效数字</strong>的位数，n是<strong>小数点</strong>以后的位数<br>（m-n）位长度</td>
</tr>
</tbody></table>
<p>如：number(5,2)，则这个字段的最大值是99,999，如果数值超出了位数限制就会被截取多余的位数。</p>
<p><strong>注</strong>：</p>
<ul>
<li>四舍五入</li>
<li>没有指定m的话，oracle默认使用38作为精度</li>
<li>n默认设置为0， n小于0则把该数字取舍到小数点左边的指定位数</li>
</ul>
<table>
<thead>
<tr>
<th>数据类型(日期)</th>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Date</td>
<td>无</td>
<td>一个7字节的定宽日期&#x2F;时间数据类型。其中总包含7个属性，包括：<br>世纪、世纪中哪一年、月份、月中的哪一天、小时、分钟和秒</td>
</tr>
<tr>
<td>Timestamp</td>
<td>无</td>
<td>一个7 字节或12字节的定宽日期&#x2F;时间数据类型。包含小数秒(fractional second)；<br>小数点右边最多可以保留9位</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>数据类型(二进制和大文本)</th>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Blob</td>
<td>无</td>
<td>在Oracle 10g及以后的版本中允许存储最多(4GB)×(数据库块大小)字节的数据。<br>存储电子表格、字处理文档、图像文件</td>
</tr>
<tr>
<td>Clob</td>
<td>无</td>
<td>在Oracle 10g及以后的版本中允许存储最多(4GB)×(数据库块大小)字节的数据。<br>存储纯文本信息</td>
</tr>
</tbody></table>
<h2 id="——-分割线——"><a href="#——-分割线——" class="headerlink" title="——-分割线——"></a>——-分割线——</h2><h2 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student(</span><br><span class="line">	id number(<span class="number">4</span>), 		<span class="comment">--学号</span></span><br><span class="line">	name VARCHAR2(<span class="number">20</span>), 	<span class="comment">--姓名</span></span><br><span class="line">	sex <span class="type">CHAR</span>(<span class="number">2</span>), 		<span class="comment">--性别</span></span><br><span class="line">	birthday <span class="type">DATE</span>,		<span class="comment">--出生日期</span></span><br><span class="line">	salary number(<span class="number">7</span>,<span class="number">2</span>), <span class="comment">--奖学金</span></span><br><span class="line">	<span class="keyword">PRIMARY</span> KEY(id) 	<span class="comment">--主键，记录唯一标识</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">DESC</span> student;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#########字段###############</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">ADD</span>(classId number); </span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student MODIFY classId number(<span class="number">10</span>);		<span class="comment">--字段长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> classid; </span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student RENAME <span class="keyword">TO</span> tb_student;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tb_student RENAME <span class="keyword">TO</span> student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student RENAME <span class="keyword">COLUMN</span> classid <span class="keyword">TO</span> temp;  <span class="comment">--字段名</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#删除表</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> student;			<span class="comment">--数据将永久性丢失</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> student; 	<span class="comment">--一次性删掉所有数据，不删除表结构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> student; 		<span class="comment">--一条一条的删除数据，后面可以添加where条件，不删除表结构。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--如果目标表不存在</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 新表名 <span class="keyword">as</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 旧表名;</span><br><span class="line"><span class="comment">--如果目标表已存在,表结构需相同 </span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 新表名  <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 旧表名;</span><br><span class="line"><span class="comment">--复制其中的几个数据 </span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 新表名 <span class="keyword">as</span> <span class="keyword">select</span> 字段<span class="number">1</span>，字段<span class="number">2.</span>. <span class="keyword">from</span> 旧表名</span><br></pre></td></tr></table></figure>



<h2 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">&#x27;小明&#x27;</span>,<span class="string">&#x27;男&#x27;</span>, to_date(<span class="string">&#x27;1988-10-11&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd&#x27;</span>),<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student (id,NAME,sex,salary,birthday) <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">&#x27;陈晨&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">30000</span>,to_date(<span class="string">&#x27;2020-02-02&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd&#x27;</span>));		<span class="comment">--没有值的字段默认值null</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> sex<span class="operator">=</span><span class="string">&#x27;女&#x27;</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>; 					<span class="comment">--没有where条件将全表更新</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> NAME<span class="operator">=</span><span class="string">&#x27;陈妍&#x27;</span>,birthday<span class="operator">=</span>to_date(<span class="string">&#x27;2020-02-05&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd&#x27;</span>) <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> NAME<span class="operator">=</span><span class="keyword">NULL</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">3</span>; </span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">3</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> student;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student; </span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>; </span><br></pre></td></tr></table></figure>



<h2 id="——-分割线——-1"><a href="#——-分割线——-1" class="headerlink" title="——-分割线——"></a>——-分割线——</h2><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><p><strong>where</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> <span class="number">1</span><span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> empno<span class="operator">=</span><span class="number">7369</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> ename<span class="operator">=</span><span class="string">&#x27;KING&#x27;</span> <span class="keyword">AND</span> deptno<span class="operator">=</span><span class="number">10</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> ename<span class="operator">=</span><span class="string">&#x27;JONES&#x27;</span> <span class="keyword">AND</span> deptno<span class="operator">=</span><span class="number">20</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> dept <span class="keyword">WHERE</span> dname<span class="operator">=</span><span class="string">&#x27;ACCOUNTING&#x27;</span> <span class="keyword">OR</span> loc<span class="operator">=</span><span class="string">&#x27;DALLAS&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>like</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--通配符%代表0到n个字符，通配符下划线_代表1个字符</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> ename <span class="keyword">LIKE</span> <span class="string">&#x27;S%&#x27;</span>; 	<span class="comment">--S字母开头，效率高</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> ename <span class="keyword">LIKE</span> <span class="string">&#x27;%N%&#x27;</span>;	<span class="comment">--中间含有N，惯用</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> ename <span class="keyword">LIKE</span> <span class="string">&#x27;T___&#x27;</span>;	<span class="comment">--3个下划线</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> ename <span class="keyword">LIKE</span> <span class="string">&#x27;__N%&#x27;</span>;	<span class="comment">--2个下划线</span></span><br></pre></td></tr></table></figure>

<p><strong>null</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> mgr <span class="keyword">IS</span> <span class="keyword">NULL</span>; #字段内容为<span class="keyword">null</span>的</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> mgr <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>; #字段内容不为<span class="keyword">null</span>的</span><br></pre></td></tr></table></figure>

<p><strong>between</strong>：闭区间</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> sal <span class="keyword">BETWEEN</span> <span class="number">5000</span> <span class="keyword">AND</span> <span class="number">10000</span>; </span><br></pre></td></tr></table></figure>



<h2 id="特殊查询"><a href="#特殊查询" class="headerlink" title="特殊查询"></a>特殊查询</h2><p><strong>nvl</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> nvl(mgr,empno),nvl(comm,<span class="number">0</span>) <span class="keyword">FROM</span> emp		<span class="comment">--字段值为null时替换</span></span><br></pre></td></tr></table></figure>

<p><strong>nvl2</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> nvl2(comm,sal<span class="operator">+</span>comm,sal) <span class="keyword">FROM</span> emp			<span class="comment">--字段值为null时，替换为表达式2的值，不为null时，替换为表达式1的值</span></span><br></pre></td></tr></table></figure>

<p><strong>distinct</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> job <span class="keyword">FROM</span> emp;					<span class="comment">--使用distinct关键字，去除重复的记录行</span></span><br></pre></td></tr></table></figure>

<p><strong>order by</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">ORDER</span> <span class="keyword">BY</span> sal #默认正序</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">ORDER</span> <span class="keyword">BY</span> sal <span class="keyword">ASC</span> #声明为正序</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">ORDER</span> <span class="keyword">BY</span> sal <span class="keyword">desc</span> #声明为倒序</span><br></pre></td></tr></table></figure>

<p><strong>别名as</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ename,empno,sal<span class="operator">+</span>nvl(comm,<span class="number">0</span>) <span class="keyword">as</span> 总收入 <span class="keyword">FROM</span> emp </span><br></pre></td></tr></table></figure>

<p><strong>in &amp; not in</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> dname <span class="keyword">from</span> dept <span class="keyword">WHERE</span> deptno <span class="keyword">in</span> (<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">等价于</span><br><span class="line"><span class="keyword">SELECT</span> dname <span class="keyword">from</span> dept <span class="keyword">WHERE</span> deptno<span class="operator">=</span><span class="number">10</span> <span class="keyword">or</span> deptno<span class="operator">=</span><span class="number">20</span></span><br></pre></td></tr></table></figure>



<h2 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h2><p>​		多输入单输出</p>
<p>​		忽略null值</p>
<p><strong>count</strong>：记录总数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp <span class="keyword">where</span> ename <span class="keyword">like</span> <span class="string">&#x27;t%&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">from</span> emp;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(empno) <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>

<p><strong>max</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(sal) <span class="keyword">from</span> emp;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(empno),<span class="built_in">max</span>(sal),<span class="built_in">max</span>(comm) <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>

<p><strong>min</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">min</span>(sal) <span class="keyword">from</span> emp;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">min</span>(sal),<span class="built_in">max</span>(sal) <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>

<p><strong>avg</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(sal) <span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(sal),<span class="built_in">min</span>(sal),<span class="built_in">max</span>(sal) <span class="keyword">from</span> emp</span><br></pre></td></tr></table></figure>

<p><strong>sum</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(sal) <span class="keyword">from</span> emp;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(sal),<span class="built_in">sum</span>(comm) <span class="keyword">from</span> emp; 			<span class="comment">--统计字段为null时，不参与计算</span></span><br></pre></td></tr></table></figure>





<h2 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h2><p><strong>group by</strong>：用于对查询的结果进行分组统计</p>
<p><strong>注</strong>：没有被分组函数包含的列必须出现在group by的后面</p>
<p><strong>having</strong>：限制group by查询结果</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> deptno,job <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> deptno<span class="operator">=</span><span class="number">30</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> deptno,job</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">&gt;=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>



<h2 id="关联查询（连接查询）"><a href="#关联查询（连接查询）" class="headerlink" title="关联查询（连接查询）"></a>关联查询（连接查询）</h2><p>定义：查询两个或两个以上数据表或视图的查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> table1.column,table1.column <span class="keyword">from</span> table1,table2</span><br><span class="line"><span class="keyword">where</span> table1.column1<span class="operator">=</span>table2.column2;</span><br></pre></td></tr></table></figure>



<p><strong>笛卡尔积</strong>：做关联操作的每个表的每一行都和其他表的每一行做组合。通常没有意义</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp;#<span class="number">14</span>条记录</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> dept;#<span class="number">4</span>条记录</span><br><span class="line"><span class="keyword">select</span> emp.ename,dept.dname <span class="keyword">from</span> emp,dept; #<span class="number">56</span>条记录</span><br></pre></td></tr></table></figure>



<p><strong>内连接查询</strong>：把满足条件的数据查询出来</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> table1.column,table1.column </span><br><span class="line"><span class="keyword">from</span> table1 <span class="keyword">inner</span> <span class="keyword">join</span> table2</span><br><span class="line"><span class="keyword">on</span> table1.column1<span class="operator">=</span>table2.couumn2 </span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--使用别名来区分不同的表</span></span><br><span class="line"><span class="keyword">select</span> e.<span class="operator">*</span>,d.<span class="operator">*</span> <span class="keyword">from</span> emp e</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> dept d</span><br><span class="line"><span class="keyword">on</span> e.deptno <span class="operator">=</span> d.deptno</span><br></pre></td></tr></table></figure>

<p>注：内连接分为等值连接查询和非等值连接查询。连接查询的条件应该为n-1个，这样才能有效的避免笛卡尔积</p>
<p><strong>外连接查询</strong>：把满足和不满足的条件数据查出来。有三类</p>
<ul>
<li><p>左外连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> emp.<span class="operator">*</span>,dept.dname <span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> dept</span><br><span class="line"><span class="keyword">on</span> emp.deptno <span class="operator">=</span> d.deptno</span><br></pre></td></tr></table></figure>
</li>
<li><p>右外连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> emp.<span class="operator">*</span>,dname <span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">right</span> <span class="keyword">join</span> dept</span><br><span class="line"><span class="keyword">on</span> emp.deptno <span class="operator">=</span> d.deptno</span><br></pre></td></tr></table></figure>
</li>
<li><p>满外连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> emp.<span class="operator">*</span>,dname <span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">full</span> <span class="keyword">join</span> dept</span><br><span class="line"><span class="keyword">on</span> emp.deptno <span class="operator">=</span> d.deptno</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>自连接查询</strong>：数据的来源是一张表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> e.ename,m.ename,e.sal,m.sal <span class="keyword">from</span> emp e,emp m</span><br><span class="line"><span class="keyword">where</span> e.mgr <span class="operator">=</span> m.empno</span><br></pre></td></tr></table></figure>



<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>定义：一个查询是另一个查询的条件</p>
<p>范围：子查询可以出现在where子句，having子句，from子句中，select子句中</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> sal <span class="operator">&gt;</span> (<span class="keyword">select</span> sal <span class="keyword">from</span> emp <span class="keyword">where</span> ename<span class="operator">=</span> <span class="string">&#x27;scott&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> deptno,<span class="built_in">min</span>(sal) <span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> deptno</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">min</span>(sal)<span class="operator">&gt;</span>(<span class="keyword">select</span> <span class="built_in">min</span>(sal) <span class="keyword">from</span> emp <span class="keyword">where</span> deptno<span class="operator">=</span><span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> e.<span class="operator">*</span> <span class="keyword">from</span> emp e,(<span class="keyword">select</span> deptno,<span class="built_in">avg</span>(sal) avg_sal <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> deptno) x</span><br><span class="line"><span class="keyword">where</span> e.deptno <span class="operator">=</span> x.deptno</span><br><span class="line"><span class="keyword">and</span> e.sal<span class="operator">&gt;</span>x.avg_sal</span><br><span class="line"></span><br><span class="line"><span class="comment">--关联子查询</span></span><br><span class="line"><span class="keyword">select</span> e.ename,e.sal,(<span class="keyword">select</span> d.dname <span class="keyword">from</span> dept d <span class="keyword">where</span></span><br><span class="line">e.deptno<span class="operator">=</span>d.deptno) dname <span class="keyword">from</span> emp e;</span><br></pre></td></tr></table></figure>



<h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><p>oracle的分页查询需要用到<code>rownum</code></p>
<p><code>rownum</code>被称作<strong>伪列</strong>：用于返回表示行数据顺序的数字</p>
<p><code>rownum</code>的特性：查询一行添加一个行号，从1开始顺序添加。只能从1计数，不能从结果集中直接取。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> rownum,empno,ename,sal <span class="keyword">from</span> emp; </span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> rownum,empno,ename,sal <span class="keyword">from</span> emp <span class="keyword">where</span> rownum<span class="operator">&gt;</span><span class="number">3</span>;	<span class="comment">--查询是没有结果的</span></span><br><span class="line"><span class="keyword">select</span> emp.<span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> rownum <span class="operator">&lt;=</span> <span class="number">3</span>;				<span class="comment">--返回前三条数据</span></span><br><span class="line"><span class="keyword">select</span> emp.<span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> rownum <span class="operator">=</span> <span class="number">1</span>; 				<span class="comment">--返回第一条数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--要把rownum作为一个可以用的结果集，那么需要通过一个行内视图来实现</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> rownum rn,e.<span class="operator">*</span> <span class="keyword">from</span> emp e) </span><br></pre></td></tr></table></figure>

<p><code>rownum</code>实现分页的效果</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> rownum rn,emp.<span class="operator">*</span> <span class="keyword">from</span> emp)</span><br><span class="line"><span class="keyword">where</span> rn <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span></span><br><span class="line">  (<span class="keyword">select</span> rownum rn,e.<span class="operator">*</span> <span class="keyword">from</span></span><br><span class="line">    (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> sal <span class="keyword">desc</span>) e)</span><br><span class="line"><span class="keyword">where</span> rn<span class="operator">&gt;=</span><span class="number">3</span> <span class="keyword">and</span> rn<span class="operator">&lt;=</span><span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span></span><br><span class="line">(<span class="keyword">select</span> rownum rn, e.<span class="operator">*</span> <span class="keyword">from</span></span><br><span class="line">  (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> sal <span class="keyword">desc</span>) e</span><br><span class="line"> <span class="keyword">where</span> rownum<span class="operator">&lt;=</span><span class="number">10</span>)</span><br><span class="line"><span class="keyword">where</span> rn<span class="operator">&gt;=</span><span class="number">3</span>;</span><br></pre></td></tr></table></figure>



<p><code>rowid</code>用于定位数据库中一条记录的一个相对唯一地址值</p>
<p><code>rowid</code>是一个伪列，它并不存在于表中</p>
<p>应用：数据去重</p>
<p>步骤：1.按照重复的内容进行分组<br>            2.取出每一组中的一条记录并保留(注意具有唯一性)<br>            3.删除未在保留范围的数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#按照重复的内容分组</span><br><span class="line"><span class="keyword">select</span> deptno,dname,loc <span class="keyword">from</span> <span class="keyword">copy</span> <span class="keyword">group</span> <span class="keyword">by</span> deptno,dname</span><br><span class="line"></span><br><span class="line">#通过rowid的唯一性质找到分组后每组中唯一的数据</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">min</span>(rowid) <span class="keyword">from</span> <span class="keyword">copy</span> <span class="keyword">group</span> <span class="keyword">by</span> deptno</span><br><span class="line"></span><br><span class="line">#选取要删除的数据</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">copy</span> <span class="keyword">where</span> rowid <span class="keyword">not</span> <span class="keyword">in</span></span><br><span class="line">(<span class="keyword">select</span> <span class="built_in">min</span>(rowid) <span class="keyword">from</span> <span class="keyword">copy</span> <span class="keyword">group</span> <span class="keyword">by</span> deptno)</span><br><span class="line"></span><br><span class="line">#删除重复的数据</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">copy</span> <span class="keyword">where</span> rowid <span class="keyword">not</span> <span class="keyword">in</span></span><br><span class="line">(<span class="keyword">select</span> <span class="built_in">min</span>(rowid) <span class="keyword">from</span> <span class="keyword">copy</span> <span class="keyword">group</span> <span class="keyword">by</span> deptno)</span><br></pre></td></tr></table></figure>



<h2 id="——-分割线——-2"><a href="#——-分割线——-2" class="headerlink" title="——-分割线——"></a>——-分割线——</h2><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p>**concat(arg1, arg2)**：返回<code>arg1</code>与<code>arg2</code>的拼接结果</p>
<p><strong>||</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> concat(<span class="string">&#x27;ABC&#x27;</span>,<span class="string">&#x27;DEF&#x27;</span>) <span class="keyword">from</span> dual; </span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;ABC&#x27;</span><span class="operator">||</span><span class="string">&#x27;DEF&#x27;</span> <span class="keyword">from</span> dual; </span><br></pre></td></tr></table></figure>



<p>**upper(arg1)  lower(arg1)**：返回<code>arg1</code>的大小写形式</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">lower</span>(<span class="string">&#x27;ABC&#x27;</span>) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">upper</span>(<span class="string">&#x27;abc&#x27;</span>) <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>



<p>**substr(arg1, pos, len)**：从<code>arg1</code>中指定的位置<code>pos</code>开始向右侧截取指定长度<code>len</code>的子字符串.</p>
<p>​							<code>pos</code>为正则从字符串<code>arg1</code>左侧开始计数,如果为负则从字符串右侧开始计数.</p>
<p>​							未指定<code>len</code>,则返回至该字符串从位置<code>pos</code>开始到串尾的子串</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--从右侧第三位开始向后截取1个字符</span></span><br><span class="line"><span class="keyword">select</span> substr(<span class="string">&#x27;abcdefgh&#x27;</span>,<span class="number">-3</span>,<span class="number">1</span>) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="comment">--从左侧第二位开始，截取到末尾</span></span><br><span class="line"><span class="keyword">select</span> substr(<span class="string">&#x27;abcdefgh&#x27;</span>,<span class="number">2</span>) <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>



<p>**length(arg1)**：求<code>arg1</code>的长度,<code>arg1</code>可以是<code>char,varchar2,clob或nclob</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> length(<span class="string">&#x27;abcdefg&#x27;</span>) <span class="keyword">from</span> dual; </span><br></pre></td></tr></table></figure>



<p><em><em>replace(arg1,search,replace)<strong>：replace替换出现的</strong></em>所有</em>**search</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> replace(<span class="string">&#x27;abcdabce&#x27;</span>,<span class="string">&#x27;abc&#x27;</span>,<span class="string">&#x27;x&#x27;</span>) <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>



<p>**instr(arg1,to_find,pos,occurrence)**：在<code>arg1</code>中查找<code>to_find</code>子字符串,并返回一个整数表示它出现的位置.</p>
<p>​												参数<code>pos</code>指定在参数<code>arg1</code>中开始搜索的位置.</p>
<p>​							（非必要）如果<code>pos</code>为正，左边位置开始.如果<code>pos</code>为负,右边位置开始.并且反向搜索.</p>
<p>​							（非必要）参数<code>occurrence</code>指定搜索第几次出现的了字符串</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--从左侧第一个字符开始搜索，第一次出现abc的位置</span></span><br><span class="line"><span class="keyword">select</span> instr(<span class="string">&#x27;habchabc&#x27;</span>,<span class="string">&#x27;abc&#x27;</span>) <span class="keyword">from</span> dual;		<span class="comment">--结果是2</span></span><br><span class="line"><span class="comment">--从左侧第一个字符开始搜索，第一次出现abc的位置</span></span><br><span class="line"><span class="keyword">select</span> instr(<span class="string">&#x27;habchabc&#x27;</span>,<span class="string">&#x27;abc&#x27;</span>,<span class="number">1</span>) <span class="keyword">from</span> dual; 	<span class="comment">--结果是2</span></span><br><span class="line"><span class="comment">--从左侧第一个字符开始搜索，第二次出现abc的位置</span></span><br><span class="line"><span class="keyword">select</span> instr(<span class="string">&#x27;habchabc&#x27;</span>,<span class="string">&#x27;abc&#x27;</span>,<span class="number">1</span>,<span class="number">2</span>) <span class="keyword">from</span> dual; 	<span class="comment">--结果是6</span></span><br><span class="line"><span class="comment">--从右侧第一个字符开始搜索，第二次出现abc的位置</span></span><br><span class="line"><span class="keyword">select</span> instr(<span class="string">&#x27;habchabc&#x27;</span>,<span class="string">&#x27;abc&#x27;</span>,<span class="number">-1</span>,<span class="number">2</span>) <span class="keyword">from</span> dual; 	<span class="comment">--结果是6</span></span><br><span class="line"><span class="keyword">select</span> instr(<span class="string">&#x27;habchabc&#x27;</span>,<span class="string">&#x27;abc&#x27;</span>,<span class="number">-1</span>,<span class="number">2</span>) <span class="keyword">from</span> dual; 	<span class="comment">--结果是6</span></span><br></pre></td></tr></table></figure>



<p>**<code>trim([leading][trailing][both] char FROM source)</code> **：Trim返回<code>varchar2 </code>类型的字符串</p>
<p>​			其中前导的、尾随的字符char被从source中剪裁。</p>
<p>​			如果指定leading 则与char匹配的前导字符被剪裁。</p>
<p>​			如果指定trailing,则与char匹配的尾随字符被剪裁。</p>
<p>​			指定both,则字符串的首尾都被剪裁。如果没有给出char则默认为空白。</p>
<p>​			只指定source参数，则将从source参数中删除尾随和前导的空白</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">trim</span>(<span class="string">&#x27; abc &#x27;</span>) <span class="keyword">from</span> dual;							<span class="comment">--去除字符串两端的空白</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">trim</span>(<span class="string">&#x27;a&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;aaaAAAaaa&#x27;</span>) <span class="keyword">from</span> dual;			<span class="comment">--结果是AAA</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">trim</span>(<span class="keyword">leading</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;aaaAAAaaa&#x27;</span>) <span class="keyword">from</span> dual;	<span class="comment">--结果是AAAaaa</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">trim</span>(<span class="keyword">both</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;aaaAAAaaa&#x27;</span>) <span class="keyword">from</span> dual;		<span class="comment">--默认操作方式AAA</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">trim</span>(<span class="keyword">trailing</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;aaaAAAaaa&#x27;</span>) <span class="keyword">from</span> dual;	<span class="comment">--结果是aaaAAA</span></span><br><span class="line"><span class="keyword">select</span> ltrim(<span class="string">&#x27;  abc  &#x27;</span>) <span class="keyword">from</span> dual;						<span class="comment">--去除左边的空白</span></span><br><span class="line"><span class="keyword">select</span> ltrim(<span class="string">&#x27;aabbcc&#x27;</span>,<span class="string">&#x27;aa&#x27;</span>) <span class="keyword">from</span> dual;					<span class="comment">--结果为cc</span></span><br><span class="line"><span class="keyword">select</span> rtrim(<span class="string">&#x27; abc &#x27;</span>) <span class="keyword">from</span> dual;						<span class="comment">--去除右边的空白</span></span><br><span class="line"><span class="keyword">select</span> rtrim(<span class="string">&#x27;abcabc&#x27;</span>,<span class="string">&#x27;abc&#x27;</span>) <span class="keyword">from</span> dual;					<span class="comment">--结果为null</span></span><br></pre></td></tr></table></figure>



<hr>
<p>数值</p>
<p><strong>abs()</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">abs</span>(<span class="number">-21.45</span>) <span class="keyword">from</span> dual; </span><br></pre></td></tr></table></figure>



<p>**round(原数值[, 小数位数])**：四舍五入</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> round(<span class="number">3.14</span>) <span class="keyword">from</span> dual;		<span class="comment">--结果为3,</span></span><br><span class="line"><span class="keyword">select</span> round(<span class="number">3.15</span>,<span class="number">1</span>) <span class="keyword">from</span> dual;		<span class="comment">--结果为3.2,小数点位数为正，表示精确到小数点之后的位数</span></span><br><span class="line"><span class="keyword">select</span> round(<span class="number">23.54</span>,<span class="number">-1</span>) <span class="keyword">from</span> dual;	<span class="comment">--结果为20，小数点位数为负，表示精确到小数点之前的位数</span></span><br></pre></td></tr></table></figure>



<p>**ceil()**：向上取整</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">ceil</span>(<span class="number">3.14</span>) <span class="keyword">from</span> dual;		<span class="comment">--结果为4</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">ceil</span>(<span class="number">-3.14</span>) <span class="keyword">from</span> dual;		<span class="comment">--结果为 -3</span></span><br></pre></td></tr></table></figure>



<p>**floor()**：向下取整</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">floor</span>(<span class="number">23.45</span>) <span class="keyword">result</span> <span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">floor</span>(<span class="number">-23.45</span>) <span class="keyword">result</span> <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>



<p>**trunc()**：截取部分数字，直接舍去</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> trunc(<span class="number">3.99</span>) <span class="keyword">from</span> dual;		<span class="comment">--3</span></span><br><span class="line"><span class="keyword">select</span> trunc(<span class="number">3.99</span>,<span class="number">1</span>) <span class="keyword">from</span> dual;		<span class="comment">--3.9</span></span><br><span class="line"><span class="keyword">select</span> trunc(<span class="number">19.99</span>,<span class="number">-1</span>) <span class="keyword">from</span> dual;	<span class="comment">--19</span></span><br></pre></td></tr></table></figure>



<p>**to_char()**：将数值进行格式化，并返回格式化后的字符串</p>
<p>​		（1）逗号（，）：分组符号。常见的千位分隔符；<br>​		（2）<code>FM：</code> <code>Format Mask</code>屏蔽所有不必要的空格和0；<br>​		（3）$：美元符号<br>​		（4）C：与系统环境相关的国际货币符号。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--0，代表一个数字位。当原数值没有数字位与之匹配时，强制添加0.</span></span><br><span class="line"><span class="keyword">select</span> to_char(<span class="number">12.78</span>,<span class="string">&#x27;000.000&#x27;</span>) <span class="keyword">from</span> dual;#<span class="number">012.78</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--9，代表一个数字位。当元数值中的整数部分没有数字位与之匹配时，不填充任何字符。</span></span><br><span class="line"><span class="keyword">select</span> to_char(<span class="number">12.78</span>,<span class="string">&#x27;999.999&#x27;</span>) <span class="keyword">from</span> dual;#<span class="number">12.780</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--逗号(，)【一定要是英文半角逗号】，分组符号。常见的应用为千位分隔符。</span></span><br><span class="line"><span class="keyword">select</span> to_char(<span class="number">4560000</span>, <span class="string">&#x27;99,999,999.00&#x27;</span>) <span class="keyword">result</span> <span class="keyword">from</span> dual;#<span class="number">4</span>,<span class="number">560</span>,<span class="number">000.00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--为了标识货币，通常在数值之前添加“$”</span></span><br><span class="line"><span class="keyword">select</span> to_char(<span class="number">4560000</span>, <span class="string">&#x27;$99,999,999.00&#x27;</span>) <span class="keyword">result</span> <span class="keyword">from</span> dual;#<span class="number">4</span>,<span class="number">560</span>,<span class="number">000.00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--屏蔽不必要的空格和0</span></span><br><span class="line"><span class="keyword">select</span> to_char(<span class="number">12.78</span>,<span class="string">&#x27;999.999&#x27;</span>) <span class="keyword">result</span>,</span><br><span class="line">to_char(<span class="number">12.78</span>,<span class="string">&#x27;FM999.999&#x27;</span>) fm_result <span class="keyword">from</span> dual;#<span class="number">12.780</span>,<span class="number">12.78</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--“C”字符返回与数据库环境相关的货币种类符号。</span></span><br><span class="line"><span class="keyword">select</span> to_char(<span class="number">12.78</span>,<span class="string">&#x27;FM999.999C&#x27;</span>) <span class="keyword">result</span> <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>



<hr>
<p>日期</p>
<p><strong>sysdate</strong>：返回当前日期</p>
<p><strong>systimestamp</strong>：包含时分秒</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sysdate <span class="keyword">from</span> dual; </span><br><span class="line"><span class="keyword">select</span> systimestamp <span class="keyword">from</span> dual; </span><br></pre></td></tr></table></figure>



<p>**add_months(d1,n1)**：返回在日期<code>d1</code>上再加<code>n1</code>过后的新日期</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> add_months(sysdate,<span class="number">12</span>) <span class="keyword">from</span> dual;#获取<span class="number">1</span>年后的今天 </span><br></pre></td></tr></table></figure>



<p>**last_day(d1)**：返回d1日期所在的月份的最后一天</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> last_day(sysdate) <span class="keyword">from</span> dual</span><br></pre></td></tr></table></figure>



<p>**months_between(d1,d2)**：返回日期d1到日期d2之间的月数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> months_between(sysdate,add_months(sysdate,<span class="number">-12</span>)) <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>

<p>**round(d,[fmt])**：返回一个以<code>fmt</code>为格式的四舍五入日期值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> round(sysdate,<span class="string">&#x27;yyyy&#x27;</span>) <span class="keyword">from</span> dual;		<span class="comment">--01-1月 -22，明年的1月1日</span></span><br><span class="line"><span class="keyword">select</span> round(sysdate,<span class="string">&#x27;day&#x27;</span>) <span class="keyword">from</span> dual;		<span class="comment">--26-9月 -21 最近的星期日</span></span><br><span class="line"><span class="keyword">select</span> round(sysdate) <span class="keyword">from</span> dual;			<span class="comment">--最近是那天 28-9月 -21</span></span><br><span class="line"><span class="keyword">select</span> round(sysdate,<span class="string">&#x27;month&#x27;</span>) <span class="keyword">from</span> dual;	<span class="comment">--最近的1日是那天</span></span><br><span class="line"><span class="keyword">select</span> round(sysdate,<span class="string">&#x27;ddd&#x27;</span>) <span class="keyword">from</span> dual;		<span class="comment">--最近是那天 28-9月 -21</span></span><br></pre></td></tr></table></figure>



<p>**extract(fmt FROM d)**：提取日期中的特定部分。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">     <span class="built_in">extract</span>(<span class="keyword">year</span> <span class="keyword">from</span> sysdate),</span><br><span class="line">     <span class="built_in">extract</span>(<span class="keyword">month</span> <span class="keyword">from</span> sysdate),</span><br><span class="line">     <span class="built_in">extract</span>(<span class="keyword">day</span> <span class="keyword">from</span> sysdate),</span><br><span class="line">     <span class="built_in">extract</span>(<span class="keyword">hour</span> <span class="keyword">from</span> systimestamp),</span><br><span class="line">     <span class="built_in">extract</span>(<span class="keyword">minute</span> <span class="keyword">from</span> systimestamp),</span><br><span class="line">     <span class="built_in">extract</span>(<span class="keyword">second</span> <span class="keyword">from</span> systimestamp)</span><br><span class="line"><span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>



<p>**to_char(d1,fmt)**：将日期转换为字符串格式</p>
<p>**to_date()**： 将日期字符串转为日期</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> to_char(sysdate,<span class="string">&#x27;yyyy-MM-dd HH:mi:ss&#x27;</span>) <span class="keyword">from</span> dual;<span class="comment">--转为指定格式的字符串</span></span><br><span class="line"><span class="keyword">select</span> to_char(sysdate,<span class="string">&#x27;MM&#x27;</span>) <span class="keyword">from</span> dual;					<span class="comment">--获取月份</span></span><br><span class="line"><span class="keyword">select</span> to_char(sysdate,<span class="string">&#x27;day&#x27;</span>) <span class="keyword">from</span> dual;				<span class="comment">--今天是星期几</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> to_date(<span class="string">&#x27;2021-09-27 11:09:33&#x27;</span>,<span class="string">&#x27;yyyy-MM-dd HH:mi:ss&#x27;</span>) <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>



<h2 id="分支函数if-else"><a href="#分支函数if-else" class="headerlink" title="分支函数if-else"></a>分支函数if-else</h2><p><strong>decode函数</strong>：</p>
<p>语法： <code>DECODE(expr,search1,result1[,search2,result2]....[default])</code></p>
<ul>
<li><p>比较参数<code>expr</code>的值，如果匹配到哪一个<code>search</code>条件，就返回对应的result结果</p>
</li>
<li><p>可以有多组search和result的对应关系</p>
</li>
<li><p>如果任何一个search条件都没有匹配到，则返回最后default的结果</p>
</li>
<li><p>default参数是可选的，如果没有提供default的值，当没有匹配到时，将返回null值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ename,sal,job,</span><br><span class="line">decode(job,</span><br><span class="line">    <span class="string">&#x27;MANAGER&#x27;</span>,sal<span class="operator">*</span><span class="number">1.2</span>,</span><br><span class="line">    <span class="string">&#x27;ANALYST&#x27;</span>,sal<span class="operator">*</span><span class="number">1.1</span>,</span><br><span class="line">    <span class="string">&#x27;SALESMAN&#x27;</span>,sal<span class="operator">*</span><span class="number">1.05</span>,</span><br><span class="line">    sal) <span class="keyword">as</span> 奖金 <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>case语句</strong>：</p>
<p>语法:<br><code>case exp when comexp then returnvalue</code><br>        <code>...</code><br>        <code>when comexp then returnvalue</code><br>        <code>else returnvalue</code><br><code>end</code></p>
<ul>
<li>case到end之间相当于一个具体的值，可以做运算，取别名，嵌套case 等。</li>
<li>把case到end当作一个运算结果的表达式就可以了</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ename,job,sal,</span><br><span class="line"><span class="keyword">case</span> job  <span class="keyword">when</span> <span class="string">&#x27;MANAGER&#x27;</span> <span class="keyword">then</span> sal<span class="operator">*</span><span class="number">1.2</span></span><br><span class="line">     <span class="keyword">when</span> <span class="string">&#x27;ANALYST&#x27;</span> <span class="keyword">then</span> sal<span class="operator">*</span><span class="number">1.1</span></span><br><span class="line">     <span class="keyword">when</span> <span class="string">&#x27;SALESMAN&#x27;</span> <span class="keyword">then</span> sal<span class="operator">*</span><span class="number">1.05</span></span><br><span class="line">     <span class="keyword">else</span> sal </span><br><span class="line">     <span class="keyword">end</span> 奖金</span><br><span class="line">     <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>



<h2 id="排序函数"><a href="#排序函数" class="headerlink" title="排序函数"></a>排序函数</h2><p><strong>row_number</strong>：</p>
<p>语法：<code>row_number() over(partition by col order by col2)</code></p>
<ul>
<li><p>表示根据<code>col</code>分组，在分组内部根据<code>col2</code>排序</p>
</li>
<li><p>此函数计算的值就表示每组内部排序后的顺序序号，组内连续且唯一</p>
</li>
<li><p><code>rownum</code>是伪列，<code>row_number</code>功能更强， 可以直接从结果集中取出子集</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ename,deptno,sal,</span><br><span class="line"><span class="built_in">row_number</span>()</span><br><span class="line"><span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> deptno <span class="keyword">order</span> <span class="keyword">by</span> sal <span class="keyword">desc</span>) <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>



<p><strong>rank</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--按照部门分组，组内按照sal排序</span></span><br><span class="line"><span class="keyword">select</span> ename,deptno,sal,</span><br><span class="line"><span class="built_in">rank</span>()</span><br><span class="line"><span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> deptno <span class="keyword">order</span> <span class="keyword">by</span> sal <span class="keyword">desc</span>) <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>



<p><strong>dens_rank</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--按照部门分组，组内按照sal排序</span></span><br><span class="line"><span class="keyword">select</span> ename,deptno,sal,</span><br><span class="line"><span class="built_in">dense_rank</span>()</span><br><span class="line"><span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> deptno <span class="keyword">order</span> <span class="keyword">by</span> sal <span class="keyword">desc</span>) <span class="keyword">from</span> emp</span><br></pre></td></tr></table></figure>



<h2 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h2><ul>
<li><p>合并多个select语句的结果</p>
</li>
<li><p>实现集合的并，交，差</p>
</li>
<li><p>集合操作符包括union，union all，intersect 和 minus（联合&#x2F;完全联合&#x2F;相交&#x2F;相减）</p>
</li>
<li><p>select语句的列的个数和数据类型必须匹配</p>
</li>
<li><p>order by 子句只能放在最后一个查询语句中</p>
</li>
</ul>
<p>语法如下：<br><code>select statement1</code><br><code>[union|union all | intersect | minus]</code><br><code>select statement2;</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--并集</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> job<span class="operator">=</span><span class="string">&#x27;MANAGER&#x27;</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> sal<span class="operator">&gt;=</span><span class="number">2500</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Java高并发1</title>
    <url>/posts/5b88cf3b/</url>
    <content><![CDATA[<p><strong>概述：</strong>阶段1</p>
<span id="more"></span>

<h1 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h1><ol>
<li>上下文切换<ul>
<li>指某⼀时间点 CPU 寄存器和程序计数器的内容。</li>
</ul>
</li>
<li>同步(Synchronous)  &amp;  异步(Asynchronous)<ul>
<li><strong>同步</strong>方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。</li>
<li><strong>异步</strong>方法调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作</li>
</ul>
</li>
<li>并发(Concurrency)  &amp;  并行(Parallelism)<ul>
<li><strong>并发</strong>说的是在<strong>一个时间段内</strong>，多件事情在这个时间段内<strong>交替执行</strong>。</li>
<li><strong>并行</strong>说的是多件事情在<strong>同一个时刻</strong>同时发生。</li>
</ul>
</li>
<li>临界区<ul>
<li>表示一种公共资源或者说共享数据，可以被多个线程使用，但是每一次只能有一个线程使用它，一旦临界区资源被占用，其他线程要想使用这个资源就必须等待。</li>
</ul>
</li>
<li>阻塞（Blocking）  &amp;  非阻塞（Non-Blocking）<ul>
<li>比如一个线程占用了临界区资源，那么其他所有需要这个资源的线程就必须在这个临界区中等待。等待会导致线程挂起，这种情况就是阻塞</li>
</ul>
</li>
<li>死锁（Deadlock）  &amp;  饥饿（Starvation）  &amp;  活锁（Livelock）<ul>
<li><strong>死锁：</strong>彼此之间相互占用了其他线程的资源，如果都不释放自己的资源，那么这个状况将永远持续下去。</li>
<li><strong>饥饿：</strong>指某一个或者多个线程因为种种原因无法获得所要的资源，导致一直无法执行。（优先级问题）</li>
<li><strong>活锁：</strong>如果线程智力不够且都秉承着“谦让”的原则，主动将资源释放给他人使用，那么久会导致资源不断地在两个线程间跳动，而没有一个线程可以同时拿到所有资源正常执行。</li>
</ul>
</li>
</ol>
<h1 id="入门类-amp-接口"><a href="#入门类-amp-接口" class="headerlink" title="入门类&amp;接口"></a>入门类&amp;接口</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">继承Thread类，重写run发方法</span><br><span class="line"></span><br><span class="line">实现Runnable接口的run方法</span><br></pre></td></tr></table></figure>



<h2 id="Runnable-amp-Thread—没有返回值"><a href="#Runnable-amp-Thread—没有返回值" class="headerlink" title="Runnable&amp;Thread—没有返回值"></a>Runnable&amp;Thread—没有返回值</h2><p><strong>Runnable接口源码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到  Runnable  是⼀个<strong>函数式接⼝</strong>，这意味着我们可以使⽤Java 8的函数式编程来简化代码</p>
<p>Thread类源码： Thread  类是⼀个  Runnable  接⼝的实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ⽚段1 - init⽅法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span><br><span class="line"><span class="params">				<span class="type">long</span> stackSize, AccessControlContext acc,</span></span><br><span class="line"><span class="params">				<span class="type">boolean</span> inheritThreadLocals)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// ********⽚段2 - 构造函数调⽤init⽅法*******</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(Runnable target)</span> &#123;</span><br><span class="line">		init(<span class="literal">null</span>, target, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ⽚段3 - 使⽤在init⽅法⾥初始化AccessControlContext类型的私有属性----没啥用</span></span><br><span class="line"><span class="built_in">this</span>.inheritedAccessControlContext =acc != <span class="literal">null</span>?acc:AccessController.getContext();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ⽚段4 - 两个对⽤于⽀持ThreadLocal的私有属性，本地线程副本变量⼯具类</span></span><br><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">inheritableThreadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//两个主要使用的构造方法</span></span><br><span class="line">Thread(Runnable target)</span><br><span class="line">Thread(Runnable target, String name)</span><br></pre></td></tr></table></figure>



<h3 id="综上：写出一个简单的线程"><a href="#综上：写出一个简单的线程" class="headerlink" title="综上：写出一个简单的线程"></a><strong>综上：写出一个简单的线程</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Java 8 匿名内部类&quot;</span>);</span><br><span class="line">	&#125;).start();</span><br></pre></td></tr></table></figure>

<p>注意，如果是实现Runnable接口，需要Thread类来接</p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ol>
<li><p>实例方法</p>
<ul>
<li>start()：<ul>
<li>开始执⾏线程的⽅法，java虚拟机会调⽤线程内的run()⽅法；</li>
</ul>
</li>
<li>yield()：<ul>
<li>yield在英语⾥有放弃的意思，同样，这⾥的yield()指的是当前线程愿意让出对当前处理器的占⽤。这⾥需要注意的是，就算当前线程调⽤了yield()⽅法，程序在调度的时候，也还有可能继续运⾏这个线程的；</li>
</ul>
</li>
<li>join()：<ul>
<li>内部调⽤的是Object类的wait⽅法实现的；</li>
<li>合并线程（插队操作）</li>
<li>如果有两个线程Thread A和Thread B，且在A中调用了B.join()方法，则线程A会等待线程B执行结束后继续执行。</li>
</ul>
</li>
</ul>
</li>
<li><p>静态方法</p>
<ul>
<li>currentThread()：<ul>
<li>静态⽅法，返回对当前正在执⾏的线程对象的引⽤；</li>
</ul>
</li>
<li>sleep(long)：<ul>
<li>静态⽅法，使当前线程睡眠⼀段时间（毫秒级）；</li>
<li>存在异常InteruptedException(打断)</li>
<li>不会释放锁</li>
<li>必须有时间参数</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Callable-amp-Future-amp-FutureTask-—-有返回值"><a href="#Callable-amp-Future-amp-FutureTask-—-有返回值" class="headerlink" title="Callable &amp; Future &amp; FutureTask — 有返回值"></a>Callable &amp; Future &amp; FutureTask — 有返回值</h2><p><strong>Callable接口源码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">		V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：提供的方法是有返回值的，而且支持泛型</p>
<p><strong>Future接口方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> paramBoolean)</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> V <span class="title function_">get</span><span class="params">(<span class="type">long</span> paramLong, TimeUnit paramTimeUnit)</span></span><br><span class="line">		<span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> cancel—方法是<strong>试图取消</strong>⼀个线程的执行。<br>        boolean  类型的返回值是“是否取消成功”的意思。参数  paramBoolean  表示是否采⽤中断的⽅式取消线程执⾏。</p>
<p><em>使用建议：</em><br>        如果为了可取消性⽽使⽤  Future  但⼜不提供可⽤的结果，则可以声明  Future&lt;?&gt;形式类型、并返回  null  作为底层任务的结果。</p>
<p><strong>RunnableFuture接口源码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RunnableFuture</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">Runnable</span>, Future&lt;V&gt; &#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		* Sets this Future to the result of its computation</span></span><br><span class="line"><span class="comment">		* unless it has been cancelled.</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>**FutureTask类 **—–&gt; 实现RunnableFuture接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现了Callable接口的类</span></span><br><span class="line"><span class="type">Thread01</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread01</span>();</span><br><span class="line"><span class="comment">//通过task获取一个异步线程</span></span><br><span class="line"><span class="type">FutureTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(c);</span><br><span class="line"><span class="comment">//获取Callable的返回值</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> task.get();</span><br><span class="line"><span class="comment">//传入Thread类</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread(task);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>



<h1 id="线程组-amp-线程优先级"><a href="#线程组-amp-线程优先级" class="headerlink" title="线程组 &amp; 线程优先级"></a>线程组 &amp; 线程优先级</h1><ul>
<li><p>线程组</p>
<ul>
<li><p>每个Thread<strong>必然</strong>存在于⼀个ThreadGroup中，Thread不能独⽴于ThreadGroup存在。</p>
</li>
<li><p>ThreadGroup是⼀个标准的<strong>向下引⽤</strong>的树状结构，这样设计的原因是<strong>防止”上级”线程被”下级”线程引用而无法有效地被GC回收。</strong></p>
</li>
<li><p>可以统一异常处理</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//在线程组ThreadGroup threadGroup1中重写该方法，线程自动抛出</span><br><span class="line">public void uncaughtException(Thread t, Throwable e) </span><br><span class="line"></span><br><span class="line">//子线程</span><br><span class="line">Thread thread1 = new Thread(threadGroup1, new Runnable()...</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程组源码</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadGroup</span> <span class="keyword">implements</span> <span class="title class_">Thread</span>.UncaughtExceptionHandler &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup parent; <span class="comment">// ⽗亲ThreadGroup</span></span><br><span class="line">	String name; <span class="comment">// ThreadGroupr 的名称</span></span><br><span class="line">	<span class="type">int</span> maxPriority; <span class="comment">// 线程最⼤优先级</span></span><br><span class="line">	<span class="type">boolean</span> destroyed; <span class="comment">// 是否被销毁</span></span><br><span class="line">	<span class="type">boolean</span> daemon; <span class="comment">// 是否守护线程</span></span><br><span class="line">	<span class="type">boolean</span> vmAllowSuspension; <span class="comment">// 是否可以中断</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">nUnstartedThreads</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 还未启动的线程</span></span><br><span class="line">	<span class="type">int</span> nthreads; <span class="comment">// ThreadGroup中线程数⽬</span></span><br><span class="line">	Thread threads[]; <span class="comment">// ThreadGroup中的线程</span></span><br><span class="line">	<span class="type">int</span> ngroups; <span class="comment">// 线程组数⽬</span></span><br><span class="line">	ThreadGroup groups[]; <span class="comment">// 线程组数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 私有构造函数</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">ThreadGroup</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.name = <span class="string">&quot;system&quot;</span>;</span><br><span class="line">	<span class="built_in">this</span>.maxPriority = Thread.MAX_PRIORITY;</span><br><span class="line">	<span class="built_in">this</span>.parent = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 默认是以当前ThreadGroup传⼊作为parent ThreadGroup</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadGroup</span><span class="params">(String name)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>(Thread.currentThread().getThreadGroup(), name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadGroup</span><span class="params">(ThreadGroup parent, String name)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>(checkParentAccess(parent), parent, name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 私有构造函数，主要的构造函数</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">ThreadGroup</span><span class="params">(Void unused, ThreadGroup parent, String name)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">	<span class="built_in">this</span>.maxPriority = parent.maxPriority;</span><br><span class="line">	<span class="built_in">this</span>.daemon = parent.daemon;</span><br><span class="line">	<span class="built_in">this</span>.vmAllowSuspension = parent.vmAllowSuspension;</span><br><span class="line">	<span class="built_in">this</span>.parent = parent;</span><br><span class="line">	parent.add(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第三个构造函数中， 检查parent ThreadGroup</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Void <span class="title function_">checkParentAccess</span><span class="params">(ThreadGroup parent)</span> &#123;</span><br><span class="line">	parent.checkAccess();</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断当前运⾏的线程是否具有修改线程组的权限</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkAccess</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//  SecurityManager  这个类，它是Java的安全管理器，它允许应⽤程序在执⾏⼀个可能不安全或敏感的操作前确定该操作是什么，以及是否是在允许执⾏该操作的安全上下⽂中执⾏它。</span></span><br><span class="line">	<span class="type">SecurityManager</span> <span class="variable">security</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">	<span class="keyword">if</span> (security ?= <span class="literal">null</span>) &#123;</span><br><span class="line">		security.checkAccess(<span class="built_in">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>优先级</p>
<ul>
<li>可以指定，范围是1~10， 默认为5。（参考值）并不是所有的操作系统都⽀持10级优先级的划分</li>
<li>线程的调度策略采⽤抢占式， 优先级高不一定先执行</li>
<li>如果某个线程优先级⼤于线程所在线程组的最⼤优先级，那么该线程的优先级将会失效，取⽽代之的是线程组的最⼤优先级。</li>
<li>设置 &amp; 查看 ：setPriority(i) &amp; getPriority()</li>
</ul>
</li>
<li><p>守护线程   Daemon</p>
<ul>
<li>⼀个线程默认是非守护线程</li>
<li>如果某线程是守护线程，那如果所有的⾮守护线程结束，这个守护线程也会⾃动结束。</li>
<li>通过Thread类的setDaemon(boolean on)来设置。</li>
</ul>
</li>
</ul>
<h1 id="线程状态及其转换"><a href="#线程状态及其转换" class="headerlink" title="线程状态及其转换"></a>线程状态及其转换</h1><p>注：可以先看完下一节，再来看本节</p>
<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Thread.State 源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">	NEW,       <span class="comment">//线程此时尚未启动，还没调⽤Thread实例的start()⽅法。</span></span><br><span class="line">	RUNNABLE,  <span class="comment">//该状态的线程在Java虚拟机中运⾏，也有可能在等待其他系统资源（⽐如I/O）</span></span><br><span class="line">	BLOCKED,   <span class="comment">//该线程正等待锁的释放以进⼊同步区。</span></span><br><span class="line">	WAITING,   <span class="comment">//等待状态的线程变成RUNNABLE状态需要其他线程唤醒。</span></span><br><span class="line">	TIMED_WAITING, <span class="comment">//超时等待状态。线程等待⼀个具体的时间，时间到后会被自动唤醒。</span></span><br><span class="line">	TERMINATED; <span class="comment">//此时线程已执⾏完毕</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>start() 问题<ol>
<li>反复调⽤同⼀个线程的start()⽅法是否可⾏？ NO,IllegalThreadStateException异常。</li>
<li>假如⼀个线程执⾏完毕（此时处于TERMINATED状态），再次调⽤这个线程的start()⽅法是否可⾏？ NO</li>
</ol>
</li>
<li>Java线程的RUNNABLE状态其实是包括了传统操作系统线程的ready和running两个状态的。</li>
<li>调⽤如下3个⽅法会使线程进⼊<strong>等待状态</strong><ul>
<li>Object.wait()：使当前线程处于等待状态直到另⼀个线程唤醒它；</li>
<li>Thread.join()：等待线程执⾏完毕，底层调⽤的是Object实例的wait⽅法；</li>
<li>LockSupport.park()：除⾮获得调⽤许可，否则禁⽤当前线程进⾏线程调度。</li>
</ul>
</li>
<li>调⽤如下⽅法会使线程进⼊<strong>超时等待状态</strong><ul>
<li>Thread.sleep(long millis)：使当前线程睡眠指定时间</li>
<li>Object.wait(long timeout)：线程休眠指定时间，等待期间可以通过notify()&#x2F;notifyAll()唤醒</li>
<li>Thread.join(long millis)：等待当前线程最多执⾏millis毫秒，如果millis为0，则会⼀直执⾏</li>
<li>LockSupport.parkNanos(long nanos)： 除⾮获得调⽤许可，否则禁⽤当前线程进⾏线程调度指定时间</li>
<li>LockSupport.parkUntil(long deadline)：同上，也是禁⽌线程进⾏调度指定时间</li>
</ul>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/09/o5QuNZSsFk2gcdY.png" alt="状态转换图"></p>
<h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><ul>
<li>总有⼀个main线程</li>
<li>启动线程后执⾏run⽅法还是需要消耗⼀定时间的。</li>
</ul>
<ol>
<li><p>BLOCKED与RUNNABLE状态的转换</p>
<ul>
<li>处于BLOCKED状态的线程是因为在等待锁的释放。假如这⾥有两个线程a和b，a线程提前获得了锁并且暂未释放锁，此时b就处于BLOCKED状态。</li>
</ul>
</li>
<li><p>WAITING状态与RUNNABLE状态的转换</p>
<ul>
<li><p>主要有两个方法<strong>Object.wait()和Thread.join()</strong></p>
</li>
<li><p>Object.wait()</p>
<blockquote>
<ol>
<li><p>调⽤wait()⽅法前线程必须持有对象的锁。</p>
</li>
<li><p>线程调⽤wait()⽅法时，<strong>会释放当前的锁</strong>，直到有其他线程调⽤notify()&#x2F;notifyAll()⽅法唤醒等待锁的线程。</p>
</li>
<li><p>调⽤notify()⽅法只会唤醒单个等待锁的线程，如有多个线程都在等待这个锁的话不⼀定会唤醒到之前调⽤wait()⽅法的线程</p>
</li>
<li><p>调⽤notifyAll()⽅法唤醒所有等待锁的线程</p>
</li>
</ol>
</blockquote>
</li>
<li><p>Thread.join()</p>
<blockquote>
<p>调⽤join()⽅法<strong>不会释放锁</strong>，会⼀直等待当前线程执⾏完毕（转换为TERMINATED状态）</p>
</blockquote>
</li>
</ul>
</li>
<li><p>TIMED_WAITING与RUNNABLE状态转换</p>
<ul>
<li><p>Thread.sleep(long)</p>
<blockquote>
<p>并<strong>不会释放锁</strong></p>
</blockquote>
</li>
<li><p>Object.wait(long)</p>
<blockquote>
<p>可以被唤醒，也可等到时间自动唤醒</p>
</blockquote>
</li>
<li><p>Thread.join(long)</p>
<blockquote>
<p>使当前线程执⾏指定时间，并且使线程进⼊TIMED_WAITING状态</p>
</blockquote>
</li>
</ul>
</li>
<li><p>中断</p>
<ul>
<li><p>通过中断操作并不能直接终止一个线程，⽽是通知需要被中断的线程自行处理</p>
</li>
<li><p>当其他线程通知需要被中断的线程后，线程中断的状态被设置为true</p>
</li>
<li><p>静态方法</p>
<ul>
<li><p>Thread.interrupt()：中断线程。这⾥的中断线程并不会⽴即停⽌线程，⽽是设置线程的中断状态为true（默认是flase）</p>
<ol>
<li><p><strong>调用线程的interrupt()实例方法，线程的中断标志会被置为true</strong></p>
</li>
<li><p><strong>当线程处于阻塞状态时，调用线程的interrupt()实例方法，线程内部会触发InterruptedException异常，并且会清除线程内部的中断标志（即将中断标志置为false）</strong></p>
</li>
</ol>
</li>
<li><p>Thread.interrupted()：测试当前线程是否被中断。线程的中断状态受这个⽅法的影响，意思是<strong>调用⼀次</strong>使线程中断状态设置为true，<strong>连续调用两次</strong>会使得这个线程的中断状态重新转为false</p>
</li>
<li><p>Thread.isInterrupted()：<strong>查看</strong>当前线程是否被中断。</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="线程之间的通信"><a href="#线程之间的通信" class="headerlink" title="线程之间的通信"></a>线程之间的通信</h1><ul>
<li>⼀般来讲，线程内部有⾃⼰私有的线程上下文，互不干扰</li>
</ul>
<ol>
<li><strong>锁与同步</strong></li>
</ol>
<p>锁：在Java中，锁的概念都是基于对象的，所以我们⼜经常称它为对象锁。</p>
<p>同步：线程同步是线程之间按照⼀定的顺序执⾏</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (lock) &#123; <span class="comment">//⽤  synchronized  关键字加上了同⼀个对象锁  lock</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Thread B &quot;</span> + i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>等待\通知机制—不用重复尝试获得锁</strong></li>
</ol>
<p>Java多线程的等待&#x2F;通知机制是基于  Object  类的  wait() 方法和notify(), notifyAll()  ⽅法来实现的</p>
<p>注意：是同⼀个对象锁</p>
<blockquote>
<p>​		当在一个对象实例上调用wait()方法后，当前线程就会在这个对象上等待。这是什么意思？比如在线程A中，调用了obj.wait()方法，那么线程A就会停止继续执行，转为等待状态。等待到什么时候结束呢？线程A会一直等到其他线程调用obj.notify()方法为止，这时，obj对象成为了多个线程之间的有效通信手段。</p>
</blockquote>
<ol start="3">
<li><strong>信号量</strong></li>
</ol>
<p>基于  volatile  关键字实现的信号量通信</p>
<ul>
<li>volitile关键字能够保证内存的可见性，如果⽤volitile关键字声明了⼀个变量，在⼀个线程里面改变了这个变量的值，那其它线程是立刻可见更改后的值</li>
<li>volatile  变量需要进行原子操作。  如signal++  并不是⼀个原子操作（汇编有三条语句），所以我们需要使用synchronized  给它“上锁”。</li>
<li>应用场景：多个线程（超过2个）需要相互合作</li>
</ul>
<ol start="4">
<li><strong>管道</strong></li>
</ol>
<p>JDK提供了  PipedWriter  、  PipedReader  、 PipedOutputStream  、  PipedInputStream</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pipe</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReaderThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">		<span class="keyword">private</span> PipedReader reader;</span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">ReaderThread</span><span class="params">(PipedReader reader)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.reader = reader;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;this is reader&quot;</span>);</span><br><span class="line">		<span class="type">int</span> <span class="variable">receive</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> ((receive = reader.read()) ?= -<span class="number">1</span>) &#123;</span><br><span class="line">				System.out.print((<span class="type">char</span>)receive);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WriterThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">		<span class="keyword">private</span> PipedWriter writer;</span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">WriterThread</span><span class="params">(PipedWriter writer)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.writer = writer;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;this is writer&quot;</span>);</span><br><span class="line">		<span class="type">int</span> <span class="variable">receive</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			writer.write(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				writer.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">	<span class="type">PipedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PipedWriter</span>();</span><br><span class="line">	<span class="type">PipedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PipedReader</span>();</span><br><span class="line">	writer.connect(reader); <span class="comment">// 这⾥注意⼀定要连接，才能通信</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ReaderThread</span>(reader)).start();</span><br><span class="line">	Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">WriterThread</span>(writer)).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="built_in">this</span> is reader</span><br><span class="line"><span class="built_in">this</span> is writer</span><br><span class="line">test</span><br></pre></td></tr></table></figure>

<p>流程：</p>
<blockquote>
<ol>
<li>线程ReaderThread开始执⾏，</li>
<li>线程ReaderThread使⽤管道reader.read()进⼊”阻塞“，</li>
<li>线程WriterThread开始执⾏，</li>
<li>线程WriterThread⽤writer.write(“test”)往管道写⼊字符串，</li>
<li>线程WriterThread使⽤writer.close()结束管道写⼊，并执⾏完毕，</li>
<li>线程ReaderThread接受到管道输出的字符串并打印，</li>
<li>线程ReaderThread执⾏完毕。</li>
</ol>
</blockquote>
<h1 id="内存模型基础"><a href="#内存模型基础" class="headerlink" title="内存模型基础"></a>内存模型基础</h1><p>在Java中，使⽤的是<a href="http://t.csdn.cn/IFpsq">共享内存并发模型</a></p>
<ul>
<li><p>内存模型的抽象结构</p>
<ul>
<li><p>运行时内存划分</p>
</li>
<li><p>通信由JMM控制（定义了线程和主内存之间的抽象关系）</p>
<ul>
<li>线程对共享变量的所有操作都必须在⾃⼰的本地内存中进行，不能直接从主内存中读取</li>
<li>JMM通过控制主内存与每个线程的本地内存之间的交互，来提供内存可⻅性保证</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/09/l37JpxCsfb6w2Xz.png" alt="运行时内存划分"><img src="https://s2.loli.net/2022/07/09/GtbUDB7WcNO4I96.png" alt="JMM" style="zoom:80%;" /></p>
<h1 id="重排序-amp-happens-before"><a href="#重排序-amp-happens-before" class="headerlink" title="重排序 &amp; happens-before"></a>重排序 &amp; happens-before</h1><h2 id="重排序："><a href="#重排序：" class="headerlink" title="重排序："></a>重排序：</h2><ul>
<li>定义：计算机在执⾏程序时，为了提⾼性能，编译器和处理器常常会对指令做重排</li>
<li>分类：<ul>
<li>编译器优化重排<ul>
<li>编译器在不改变单线程程序语义的前提下，可以重新安排语句的执⾏顺序</li>
</ul>
</li>
<li>指令并⾏重排<ul>
<li>现代处理器采⽤了指令级并⾏技术来将多条指令重叠执⾏（前提：不存在数据依<br>  赖性）</li>
</ul>
</li>
<li>内存系统重排<ul>
<li>因为三级缓存的存在，导致内存与缓存的数据同步存在时间差</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="顺序一致性模型"><a href="#顺序一致性模型" class="headerlink" title="顺序一致性模型"></a>顺序一致性模型</h2><ul>
<li><p>数据竞争：在⼀个线程中写⼀个变量，在另⼀个线程读同⼀个变量，并且写和读没有通过同步来排序。</p>
</li>
<li><p>Java内存模型（JMM）对于正确同步多线程程序的内存⼀致性做了以下保证</p>
<blockquote>
<p>如果程序是正确同步的，程序的执⾏将具有顺序⼀致性。</p>
<p>即程序的执⾏结果和该程序在顺序⼀致性模型中执⾏的结果相同。</p>
<p>这⾥的同步包括了使⽤  volatile  、  final  、  synchronized  等关键字来实现多线程下的同步</p>
</blockquote>
</li>
<li><p>顺序⼀致性内存模型是⼀个理想化的理论参考模型</p>
<ul>
<li>⼀个线程中的所有操作必须按照程序的顺序（即Java代码的顺序）来执⾏</li>
<li>每个操作必须是原⼦性的，且⽴刻对所有线程可⻅</li>
<li>实际上，JMM没有这样的保证（见上一条）</li>
</ul>
</li>
<li><p>JMM的顺序⼀致性效果</p>
<ul>
<li>同步程序中<ul>
<li>但是JMM中，临界区内（同步块或同步⽅法中）的代码可以发⽣重排序</li>
<li>因为锁的特性，线程B⽆法观察到线程A在临界区的重排序。</li>
</ul>
</li>
<li>非同步程序中<ul>
<li>JMM<strong>只提供最小安全性</strong>：线程读取到的值，要么是之前某个线程写⼊的值，要么是默认值，不会⽆中⽣有</li>
<li>为了实现这个安全性，JVM在堆上分配对象时，⾸先会对内存空间清零，然后才会在上⾯分配对象（这两个操作是同步的）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><ul>
<li><p>JMM提供了happens-before规则（JSR-133规范），满⾜了程序员的需求——<strong>简单易懂，并且提供了足够强的内存可见性保证。</strong></p>
<ul>
<li><p>happens-before关系本质上和as-if-serial语义是<a href="http://t.csdn.cn/mHfOn">⼀回事</a></p>
</li>
<li><p>如果操作A happens-before操作B，那么操作A在内存上所做的操作对操作B都是可见的，不管它们在不在⼀个线程</p>
</li>
</ul>
</li>
<li><p>有以下天然的happens-before关系</p>
<ul>
<li>程序顺序规则：⼀个线程中的每⼀个操作，happens-before于该线程中的任意后续操作。</li>
<li>监视器锁规则：对⼀个锁的解锁，happens-before于随后对这个锁的加锁。</li>
<li>volatile变量规则：对⼀个volatile域的写，happens-before于任意后续对这个volatile域的读。</li>
<li>传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</li>
<li>start规则：如果线程A执⾏操作ThreadB.start()启动线程B，那么A线程的ThreadB.start（）操作happens-before于线程B中的任意操作、</li>
<li>join规则：如果线程A执⾏操作ThreadB.join（）并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li>
</ul>
</li>
</ul>
<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><ul>
<li>保证变量的<strong>内存可见性</strong>（指线程之间的可见性，当⼀个线程修改了共享变量时，另⼀个线<br>  程可以读取到这个修改后的值）</li>
<li>禁⽌volatile变量与普通变量重排序</li>
<li>一个例子</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileExample</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">		a = <span class="number">1</span>; <span class="comment">// step 1</span></span><br><span class="line">		flag = <span class="literal">true</span>; <span class="comment">// step 2</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (flag) &#123; <span class="comment">// step 3</span></span><br><span class="line">			System.out.println(a); <span class="comment">// step 4</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 在这段代码⾥，我们使⽤  volatile  关键字修饰了⼀个  boolean  类型的变量  flag  。</p>
<p>所谓内存可⻅性，指的是当⼀个线程对  volatile  修饰的变量进⾏写操作（⽐如step 2）时，JMM会⽴即把该线程对应的本地内存中的共享变量的值刷新到主内存；</p>
<p>当⼀个线程对  volatile  修饰的变量进⾏读操作（⽐如step 3）时，JMM会把⽴即该线程对应的本地内存置为⽆效，从主内存中读取共享变量的值。</p>
</blockquote>
<ul>
<li><p>用途</p>
<ul>
<li><p>在保证内存可⻅性这⼀点上，volatile有着与锁相同的内存语义，所以可以作为⼀个“轻量级”的锁来使⽤。</p>
</li>
<li><p>例如在单例模式中</p>
</li>
<li><p>&#96;&#96;&#96;java<br>  public class Singleton {<br>  private static Singleton instance; &#x2F;&#x2F; 不使⽤volatile关键字<br>  &#x2F;&#x2F; 双重锁检验<br>  public static Singleton getInstance() {<br>      if (instance &#x3D;&#x3D; null) { &#x2F;&#x2F; 第7⾏<br>          synchronized (Singleton.class) {<br>              if (instance &#x3D;&#x3D; null) {<br>                  instance &#x3D; new Singleton(); &#x2F;&#x2F; 第10⾏<br>              }<br>          }<br>      }<br>      return instance;<br>  }<br>  }</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># synchronized &amp; 锁</span><br><span class="line"></span><br><span class="line">## Synchronized关键字</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">// 关键字在实例⽅法上，锁为当前实例</span><br><span class="line">public synchronized void instanceLock() &#123;</span><br><span class="line">	// code</span><br><span class="line">&#125;</span><br><span class="line">// 关键字在静态⽅法上，锁为当前Class对象</span><br><span class="line">public static synchronized void classLock() &#123;</span><br><span class="line">	// code</span><br><span class="line">&#125;</span><br><span class="line">// 关键字在代码块上，锁为括号⾥⾯的对象</span><br><span class="line">public void blockLock() &#123;</span><br><span class="line">	Object o = new Object();</span><br><span class="line">	synchronized (o) &#123;</span><br><span class="line">	// code</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<blockquote>
<p>总结：</p>
<ol>
<li>修饰实例方法，作用于当前实例，进入同步代码前需要先获取实例的锁</li>
<li>修饰静态方法，作用于类的Class对象，进入修饰的静态方法前需要先获取类的Class对象的锁</li>
<li>修饰代码块，需要指定加锁对象(记做lockobj)，在进入同步代码块前需要先获取lockobj的锁</li>
</ol>
</blockquote>
<blockquote>
<p> Java类只有⼀个Class对象（可以有多个实例对象，多个实例共享这个Class对象），⽽Class对象也是特殊的Java对象。</p>
</blockquote>
<blockquote>
<p>所谓“临界区”，指的是某⼀块代码区域，它同⼀时刻只能由⼀个线程执⾏。</p>
</blockquote>
<blockquote>
<p>synchronized可以把任意一个非NULL的对象当作锁。</p>
<ol>
<li>作用于方法时，锁住的是对象的实例(this)；</li>
<li>当作用于静态方法时，锁住的是Class实例，又因为Class的相关数据存储在永久带PermGen（jdk1.8则是metaspace），永久带是全局共享的，因此静态方法锁相当于类的一个全局锁，会锁所有调用该方法的线程；</li>
<li>synchronized作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。</li>
</ol>
</blockquote>
<h2 id="锁–状态"><a href="#锁–状态" class="headerlink" title="锁–状态"></a>锁–状态</h2><p>⼀个对象其实有四种锁状态，它们级别由低到⾼依次是：</p>
<ol>
<li>⽆锁状态 — 略</li>
<li>偏向锁状态</li>
<li>轻量级锁状态</li>
<li>重量级锁状态</li>
</ol>
<p>注：可能会发生锁降级，但条件苛刻，不做细讲</p>
<h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h3><ul>
<li><p>每个Java对象都有对象头。</p>
<ul>
<li><p>如果是非数组类型，则⽤2个字宽来存储对象头</p>
</li>
<li><p>如果是数组，则会⽤3个字宽来存储对象头。</p>
</li>
</ul>
</li>
<li><p>在32位处理器中，⼀个字宽是32位；在64位虚拟机中，⼀个字宽是64位。</p>
</li>
<li><p>对象头内容：其中<strong>锁的状态判断主要是读取Mark Word的内容（表二）</strong></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>对象头内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Mark Word</td>
<td>存储对象的hashCode或锁信息等</td>
</tr>
<tr>
<td>Class Metadata Address</td>
<td>存储到对象类型数据的指针</td>
</tr>
<tr>
<td>Array length</td>
<td>数组的长度（如果是数组）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>锁状态</th>
<th>61bit</th>
<th>1bit–偏向锁判断位</th>
<th>2bit–锁标志位</th>
</tr>
</thead>
<tbody><tr>
<td>无锁</td>
<td></td>
<td>0</td>
<td>01</td>
</tr>
<tr>
<td>偏向锁</td>
<td>线程ID</td>
<td>1</td>
<td>01</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>指向栈中锁记录的指针</td>
<td>×</td>
<td>00</td>
</tr>
<tr>
<td>重量级锁</td>
<td>指向互斥量（重量级锁）的指针</td>
<td>×</td>
<td>10</td>
</tr>
<tr>
<td>GC标记</td>
<td></td>
<td>×</td>
<td>11</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>锁状态</th>
<th>上锁条件</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>锁总是由同⼀线程多次获得</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>多个线程在不同时段获取同⼀把锁，即不存在锁竞争的情况</td>
</tr>
<tr>
<td>重量级锁</td>
<td>多个线程同时请求某个对象锁时</td>
</tr>
</tbody></table>
<h3 id="锁状态升级流程"><a href="#锁状态升级流程" class="headerlink" title="锁状态升级流程"></a>锁状态升级流程</h3><blockquote>
<p> 第⼀步，检查MarkWord⾥⾯是不是放的⾃⼰的ThreadId ,如果是，表示当前线程是处于 “偏向锁”。</p>
<p>第⼆步，如果MarkWord不是⾃⼰的ThreadId，锁升级，这时候，⽤CAS来执⾏切换，新的线程根据MarkWord⾥⾯现有的ThreadId，通知之前线程暂停，之前线程将Markword的内容置为空。</p>
<p>第三步，两个线程都把锁对象的HashCode复制到⾃⼰新建的⽤于存储锁的记录空间，接着开始通过CAS操作， 把锁对象的MarKword的内容修改为⾃⼰新建的记录空间的地址的⽅式竞争MarkWord。</p>
<p>第四步，第三步中成功执⾏CAS的获得资源，失败的则进⼊⾃旋 。</p>
<p>第五步，⾃旋的线程在⾃旋过程中，成功获得资源(即之前获的资源的线程执⾏完成并释放了共享资源)，则整个状态依然处于 轻量级锁的状态，如果⾃旋失败 。</p>
<p>第六步，进⼊重量级锁的状态，这个时候，⾃旋的线程进⾏阻塞，等待之前线程执⾏完成并唤醒⾃⼰。</p>
</blockquote>
<h3 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h3><table>
<thead>
<tr>
<th>类型</th>
<th>概念</th>
</tr>
</thead>
<tbody><tr>
<td>悲观锁</td>
<td>总是认为每次访问共享资源时会发⽣冲突，所以必须对每次数据操作加上锁，以保证临界区的程序同⼀时间只能有⼀个线程在执行<br><strong>写多读少操作</strong></td>
</tr>
<tr>
<td>乐观锁</td>
<td>总是假设对共享资源的访问没有冲突，线程可以不停地执⾏，⽆需加锁也⽆需等待<br>发生线程冲突时，使用⼀种称为CAS的技术来保证线程执⾏的安全性<br><strong>读多写少操作</strong></td>
</tr>
<tr>
<td>…</td>
<td>公平\非公平锁  可重入锁  独享锁\共享锁  互斥锁\读写锁</td>
</tr>
</tbody></table>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><strong>死锁产生条件（缺一不可）</strong></p>
<ol>
<li>互斥条件：一个资源每次只能被一个线程使用</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获取资源不释放</li>
<li>不剥夺条件：进程已获得资源，在未使用完之前，不能强行剥夺</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源</li>
</ol>
<p><strong>死锁的预防</strong></p>
<ol>
<li>资源一次性分配：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）</li>
<li>只要有一个资源得不到分配，也不给这个进程分配其他的资源：（破坏请保持条件）</li>
<li>可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）</li>
<li>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件</li>
</ol>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><ul>
<li>创建&#x2F;销毁线程需要消耗系统资源，线程池可以<strong>复用</strong>已创建的线程</li>
<li>控制并发的<strong>数量</strong></li>
<li>可以对线程做统⼀管理</li>
</ul>
<h2 id="ThreadPoolExecutor基础-amp-原理"><a href="#ThreadPoolExecutor基础-amp-原理" class="headerlink" title="ThreadPoolExecutor基础&amp;原理"></a>ThreadPoolExecutor基础&amp;原理</h2><p>线程池顶层接口是  Executor 接口，  ThreadPoolExecutor  是这个接口的实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 五个参数的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, //核心线程数最⼤值</span></span><br><span class="line"><span class="params">						<span class="type">int</span> maximumPoolSize, //线程总数最⼤值</span></span><br><span class="line"><span class="params">						<span class="type">long</span> keepAliveTime, //⾮核⼼线程闲置超时时⻓</span></span><br><span class="line"><span class="params">						TimeUnit unit,  	//keepAliveTime的单位</span></span><br><span class="line"><span class="params">						BlockingQueue&lt;Runnable&gt; workQueue)</span> <span class="comment">//阻塞队列</span></span><br><span class="line"><span class="comment">// 六个参数的构造函数-1</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">						<span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">						<span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">						TimeUnit unit,</span></span><br><span class="line"><span class="params">						BlockingQueue&lt;Runnable&gt; workQueue, </span></span><br><span class="line"><span class="params">						ThreadFactory threadFactory)</span><span class="comment">//创建线程的⼯⼚&#123;⽤于批量创建线程&#125;</span></span><br><span class="line"><span class="comment">// 六个参数的构造函数-2</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">						<span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">						<span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">						TimeUnit unit,</span></span><br><span class="line"><span class="params">						BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">						RejectedExecutionHandler handler)</span><span class="comment">//拒绝处理策略</span></span><br><span class="line"><span class="comment">// 七个参数的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">						<span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">						<span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">						TimeUnit unit,</span></span><br><span class="line"><span class="params">						BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">						ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">						RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure>

<p>其中有五个必须参数：</p>
<ul>
<li><p>int corePoolSize：该线程池中核心线程数最⼤值</p>
<blockquote>
<p>核⼼线程：线程池中有两类线程，核心线程和⾮核心线程。核⼼线程默认情况下会⼀直存在于线程池中，即使这个核心线程什么都不⼲（铁饭碗），⽽非核心线程如果⻓时间的闲置，就会被销毁（临时⼯）</p>
</blockquote>
</li>
<li><p>int maximumPoolSize：该线程池中线程总数最⼤值</p>
<blockquote>
<p>等于核心线程数量 + 非核心线程数量</p>
</blockquote>
</li>
<li><p>long keepAliveTime：非核心线程闲置超时时⻓</p>
<blockquote>
<p>如果设置allowCoreThreadTimeOut(true)，则会也作⽤于核⼼线程</p>
</blockquote>
</li>
<li><p>TimeUnit unit：keepAliveTime的单位</p>
<blockquote>
<p>枚举类型: NANOSECONDS(微毫秒)   MICROSECONDS(微秒) MILLISECONDS(毫秒) SECONDS  MINUTES  HOURS  DAYS</p>
</blockquote>
</li>
<li><p>BlockingQueue workQueue：阻塞队列，维护着等待执⾏的Runnable任务对象。</p>
<ul>
<li><strong>LinkedBlockingQueue</strong> 链式阻塞队列，底层数据结构是链表，有默认也可指定</li>
<li><strong>ArrayBlockingQueue</strong> 数组阻塞队列，底层数据结构是数组，大小要指定</li>
<li><strong>SynchronousQueue</strong> 同步队列，内部容量为0，每个put操作必须等待⼀个take操作</li>
<li><strong>DelayQueue</strong> 延迟队列，任务只有当其指定的延迟时间到了才能够从队列中获取</li>
</ul>
</li>
</ul>
<p>以及两个非必须参数：</p>
<ul>
<li><p><strong>ThreadFactory threadFactory</strong>：⽤于批量创建线程，统⼀在创建线程时设置⼀些参数</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">	<span class="comment">// 省略属性</span></span><br><span class="line">	<span class="comment">// 构造函数</span></span><br><span class="line">	DefaultThreadFactory() &#123;</span><br><span class="line">		<span class="type">SecurityManager</span> <span class="variable">s</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">		group = (s != <span class="literal">null</span>) ? s.getThreadGroup() :</span><br><span class="line">		Thread.currentThread().getThreadGroup();</span><br><span class="line">		namePrefix = <span class="string">&quot;pool-&quot;</span> +</span><br><span class="line">		poolNumber.getAndIncrement() +</span><br><span class="line">		<span class="string">&quot;-thread-&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>RejectedExecutionHandler handler</strong>: 线程数量⼤于最⼤线程数就会采⽤拒绝处理策略(四种)</p>
<ol>
<li><strong>ThreadPoolExecutor.AbortPolicy</strong>：默认的，丢弃任务并抛出RejectedExecutionException异常</li>
<li><strong>ThreadPoolExecutor.DiscardPolicy</strong>：丢弃新来的任务，但是不抛出异常</li>
<li><strong>ThreadPoolExecutor.DiscardOldestPolic</strong>y：丢弃队列头部（最旧的）的任务，然后重新尝试执行程序（如果再次失败，重复此过程）</li>
<li><strong>ThreadPoolExecutor.CallerRunsPolicy</strong>：由调⽤线程处理该任务</li>
</ol>
</li>
</ul>
<h2 id="ThreadPoolExecutor状态"><a href="#ThreadPoolExecutor状态" class="headerlink" title="ThreadPoolExecutor状态"></a>ThreadPoolExecutor状态</h2><p>​		线程池本身有⼀个调度线程，这个线程就是⽤于管理布控整个线程池⾥的各种任务和事务，例如创建线程、销毁线程、任务队列管理、线程队列管理等等</p>
<p>​		故线程池也有⾃⼰的状态。  ThreadPoolExecutor  类中定义了⼀个  volatile int  变量runState来表示线程池的状态 ，分别为RUNNING、SHURDOWN、STOP、TIDYING 、TERMINATED</p>
<ul>
<li><p>线程池创建后处于RUNNING状态</p>
</li>
<li><p>调⽤<code>shutdown()</code>⽅法后处于SHUTDOWN状态，线程池不能接受新的任务，清除⼀些空闲worker,会等待阻塞队列的任务完成</p>
</li>
<li><p>调⽤<code>shutdownNow()</code>⽅法后处于STOP状态，线程池不能接受新的任务，中断所有线程，阻塞队列中没有被执⾏的任务全部丢弃。此时，poolsize&#x3D;0,阻塞队列的size也为0</p>
</li>
<li><p>当所有的任务已终⽌，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。接着会执行<code>terminated()</code>函数</p>
<blockquote>
<p>控制状态的属性叫ctl，它是⼀个AtomicInteger类型的变量</p>
</blockquote>
</li>
<li><p>线程池处在TIDYING状态时，执⾏完terminated()⽅法之后，就会由 TIDYING-&gt; TERMINATED， 线程池被设置为TERMINATED状态</p>
</li>
</ul>
<h2 id="任务处理流程"><a href="#任务处理流程" class="headerlink" title="任务处理流程"></a>任务处理流程</h2><ol>
<li>线程总数量 &lt; corePoolSize，⽆论线程是否空闲，都会新建⼀个核⼼线程执⾏任务（让核⼼线程数量快速达到corePoolSize，在核⼼线程数量 &lt; corePoolSize时）。<strong>注意，这⼀步需要获得全局锁</strong>。</li>
<li>线程总数量 &gt;&#x3D; corePoolSize时，新来的线程任务会进⼊任务队列中等待，然后空闲的核⼼线程会依次去缓存队列中取任务来执⾏（体现了<strong>线程复用</strong>）。</li>
<li>当缓存队列满了，说明这个时候任务已经多到爆棚，需要⼀些“临时⼯”来执⾏这些任务了。于是会创建⾮核⼼线程去执⾏这个任务。<strong>注意，这⼀步需要获得全局锁</strong>。</li>
<li>缓存队列满了， 且总线程数达到了maximumPoolSize，则会采取上⾯提到的拒绝策略进⾏处理。</li>
</ol>
<h2 id="常用的线程池（四种）"><a href="#常用的线程池（四种）" class="headerlink" title="常用的线程池（四种）"></a>常用的线程池（四种）</h2><p> Executors  类中提供的⼏个<strong>静态方法</strong>来创建线程池</p>
<ol>
<li><p><strong>newCachedThreadPool</strong></p>
<ul>
<li><pre><code class="java">  public static ExecutorService newCachedThreadPool() &#123;
      return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                    60L, TimeUnit.SECONDS,
                                    new SynchronousQueue&lt;Runnable&gt;());
  &#125;
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    - 运行流程：</span><br><span class="line"></span><br><span class="line">        1. 提交任务进线程池。</span><br><span class="line"></span><br><span class="line">        2. 因为corePoolSize为0的关系，不创建核⼼线程，线程池最⼤为Integer.MAX_VALUE。</span><br><span class="line">        3. 尝试将任务添加到SynchronousQueue队列。</span><br><span class="line">        4. 如果SynchronousQueue⼊列成功，等待被当前运⾏的线程空闲后拉取执⾏。如果当前没有空闲线程，那么就创建⼀个⾮核⼼线程，然后从SynchronousQueue拉取任务并在当前线程执⾏。</span><br><span class="line">        5. 如果SynchronousQueue已有任务在等待，⼊列操作将会阻塞。</span><br><span class="line"></span><br><span class="line">    - 作用：</span><br><span class="line"></span><br><span class="line">        - 当需要执⾏很多**短时间的任务**时，CacheThreadPool的线程复⽤率⽐较⾼， 会显著的提⾼性能。⽽且线程60s后会回收，意味着即使没有任务进来，CacheThreadPool并**不会占用很多资源**</span><br><span class="line"></span><br><span class="line">2. **newFixedThreadPool**</span><br><span class="line"></span><br><span class="line">    - ```java</span><br><span class="line">        public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">        		return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">        									  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">        									  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>运行流程：</p>
<ol>
<li>核⼼线程数量和总线程数量相等，都是传⼊的参数nThreads，所以只能创建核⼼线程，不能创建⾮核⼼线程</li>
<li>因为LinkedBlockingQueue的默认⼤⼩是Integer.MAX_VALUE，故如果核⼼线程空闲，则交给核⼼线程处理；如果核⼼线程不空闲，则⼊列等待，直到核⼼线程空闲</li>
</ol>
</li>
<li><p>与CachedThreadPool的区别</p>
<ul>
<li>FixedThreadPool只会创建核⼼线程，但CachedThreadPool只会创建非核心线程</li>
<li>FixedThreadPool线程会⼀直阻塞在LinkedBlockingQueue.take() ，线程不会被回收，但CachedThreadPool会在60S后回收</li>
<li>没有任务的情况下，FixedThreadPool占⽤资源更多</li>
<li>都⼏乎不会触发拒绝策略，但是原理不同。FixedThreadPool是因为阻塞队列可以很⼤，而CachedThreadPool是因为线程池很⼤</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>newSingleThreadExecutor</strong></p>
<ul>
<li><p>&#96;&#96;&#96;java<br>  public static ExecutorService newSingleThreadExecutor() {<br>      return new FinalizableDelegatedExecutorService<br>              (new ThreadPoolExecutor(1, 1,<br>               0L, TimeUnit.MILLISECONDS,<br>               new LinkedBlockingQueue<Runnable>()));<br>  }</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    - 运行流程：</span><br><span class="line"></span><br><span class="line">        1. 有且仅有⼀个核⼼线程</span><br><span class="line"></span><br><span class="line">        2. 使用了LinkedBlockingQueue（容量很⼤），所以，不会创建非核心线程</span><br><span class="line"></span><br><span class="line">        3. 如果这个唯⼀的线程不空闲，那么新来的任务会存储在任务队列⾥等待执⾏</span><br><span class="line"></span><br><span class="line">4. **newScheduledThreadPool**</span><br><span class="line"></span><br><span class="line">    - ```java</span><br><span class="line">        public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</span><br><span class="line">            return new ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //ScheduledThreadPoolExecutor():</span><br><span class="line">        public ScheduledThreadPoolExecutor(int corePoolSize) &#123;</span><br><span class="line">            super(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">                  DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">                  new DelayedWorkQueue());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行流程</p>
<ul>
<li>创建⼀个定⻓线程池，⽀持定时及周期性任务执⾏</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><p><strong>由来：</strong></p>
<p>​		我们假设⼀种场景，⽣产者⼀直⽣产资源，消费者⼀直消费资源，资源存储在⼀个缓冲池中，⽣产者将⽣产的资源存进缓冲池中，消费者从缓冲池中拿到资源进⾏消费，这就是<strong>生产者-消费者模式</strong></p>
<p><strong>实现&amp;问题：</strong></p>
<p>​		因为需要让<strong>多个线程操作共享变量</strong>（即资源），所以很容易引发线程安全问题，造成<strong>重复消费和死锁</strong>，尤其是⽣产者和消费者存在多个的情况。另外，当缓冲池空了，我们需要阻塞消费者，唤醒⽣产者；当缓冲池满了，我们需要阻塞⽣产者，唤醒消费者，这些个<strong>等待-唤醒逻辑都需要自己实现</strong></p>
<p><strong>解决：</strong></p>
<p>​		BlockingQueue是Java util.concurrent包下重要的数据结构，区别于普通的队列，BlockingQueue提供了<strong>线程安全的队列访问⽅式</strong>，并发包下很多⾼级同步类的实现都是基于BlockingQueue实现的</p>
<p>​		即：BlockingQueue就是存放元素的容器</p>
<p><strong>注意：</strong></p>
<p>​		生产者的生产数据的速度绝对不能快于消费者消费数据的速度，否则时间⼀⻓，会最终耗尽所有的可⽤堆内存空间</p>
<h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>一直阻塞</th>
<th>超时退出</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e, time, unit)</td>
</tr>
<tr>
<td>移除</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time, unit)</td>
</tr>
<tr>
<td>检查</td>
<td>element()</td>
<td>peek()</td>
<td>-</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>抛出异常：当阻塞队列满时候，再往队列⾥插⼊元素，会抛出IllegalStateException(“Queue full”)异常。当队列为空时，从队列⾥获取元素时会NoSuchElementException异常 。</li>
<li>返回特殊值：如果试图的操作⽆法⽴即执⾏，返回⼀个特殊值，通常是true &#x2F;false。</li>
<li>⼀直阻塞：如果试图的操作⽆法⽴即执⾏，则⼀直阻塞或者响应中断。</li>
<li>超时退出：如果试图的操作⽆法⽴即执⾏，该⽅法调⽤将会发⽣阻塞，直到能够执⾏，但等待时间不会超过给定值。返回⼀个特定值以告知该操作是否成功，通常是 true &#x2F; false。(unit—&gt;时间的单位)</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li><p>避免null值传入</p>
</li>
<li><p>可以访问阻塞队列中的任意元素</p>
</li>
<li><p>调⽤remove(o)可以将队列之中的特定对象移除，但并不高效，尽量避免使⽤</p>
</li>
</ul>
<h2 id="BlockingQueue的实现类"><a href="#BlockingQueue的实现类" class="headerlink" title="BlockingQueue的实现类"></a>BlockingQueue的实现类</h2><p>父类为<code>Queue&lt;E&gt;</code></p>
<ol>
<li><p>ArrayBlockingQueue</p>
<ul>
<li><p>底层数组，初始化大小后不能改变，默认非公平锁</p>
</li>
<li><p>&#96;&#96;&#96;java<br>  &#x2F;&#x2F;fair表示控制对象的内部锁是否采⽤公平锁<br>  public ArrayBlockingQueue(int capacity, boolean fair)</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. LinkedBlockingQueue</span><br><span class="line"></span><br><span class="line">    - 有界链表，有默认大小（Integer.MAX_VALUE），可以初始化大小，先进先出的原则</span><br><span class="line"></span><br><span class="line">3. DelayQueue</span><br><span class="line"></span><br><span class="line">    - 无界队列无界阻塞队列</span><br><span class="line">    - 添加进该队列的元素**必须实现**Delayed接口（指定延迟时间），而且只有在延迟期满后才能从中提取元素。</span><br><span class="line">    - 此队列不允许使用null元素</span><br><span class="line"></span><br><span class="line">4. PriorityBlockingQueue</span><br><span class="line"></span><br><span class="line">    - 是一个无界队列，它没有限制，在内存允许的情况下可以无限添加元素</span><br><span class="line">    - 它又是具有优先级的队列，是通过构造函数传入的对象来判断，传入的对象必须实现comparable接口</span><br><span class="line"></span><br><span class="line">5. SynchronousQueue</span><br><span class="line"></span><br><span class="line">    - **没有任何内部容量**，甚⾄连⼀个队列的容量都没有。并且每个put 必须等待⼀个 take</span><br><span class="line">    - 需要区别容量为1的ArrayBlockingQueue、LinkedBlockingQueue</span><br><span class="line"></span><br><span class="line">6. 一个生产者消费者模式的实例</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class Test &#123;</span><br><span class="line">    private int queueSize = 10;</span><br><span class="line">    private ArrayBlockingQueue&lt;Integer&gt; queue = new ArrayBlockingQueue&lt;Integer&gt;(queueSize);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        Test test = new Test();</span><br><span class="line">        Producer producer = test.new Producer();</span><br><span class="line">        Consumer consumer = test.new Consumer();</span><br><span class="line"></span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Consumer extends Thread&#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            consume();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void consume() &#123;</span><br><span class="line">            while(true)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    queue.take();</span><br><span class="line">                    System.out.println(&quot;从队列取走一个元素，队列剩余&quot;+queue.size()+&quot;个元素&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Producer extends Thread&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            produce();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void produce() &#123;</span><br><span class="line">            while(true)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    queue.put(1);</span><br><span class="line">                    System.out.println(&quot;向队列取中插入一个元素，队列剩余空间：&quot;+(queueSize-queue.size()));</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h1 id="锁–接口和类"><a href="#锁–接口和类" class="headerlink" title="锁–接口和类"></a>锁–接口和类</h1><p>JDK中关于并发的类大多都在<code>java.util.concurrent</code>（以下简称juc）包下。而juc.locks包是提供了一些并发锁的工具类的。</p>
<p>问题引入：</p>
<ul>
<li><p>如果临界区是只读操作，其实可以多线程一起执行，但使用synchronized的话，<strong>同一时间只能有一个线程执行</strong>。</p>
</li>
<li><p>synchronized无法知道线程有没有成功获取到锁</p>
</li>
<li><p>使用synchronized，如果临界区因为IO或者sleep方法等原因阻塞了，而当前线程又没有释放锁，就会导致<strong>所有线程等待</strong>。</p>
</li>
</ul>
<p>锁分类</p>
<pre><code>1. 重入锁
    - 支持重新进入的锁，也就是说这个锁支持一个**线程对资源重复加锁**。
    - synchronized关键字就是使用的重入锁。

2. 公平锁
    - 如果对一个锁来说，先对锁获取请求的线程一定会先被满足，后对锁获取请求的线程后被满足，那这个锁就是公平的。但是非公平锁可能会发生线程饥饿（有一些线程长时间得不到锁）的情况。
    - ReentrantLock支持非公平锁和公平锁两种

3. 排它锁
    - 这些锁在同一时刻只允许一个线程进行访问。
    - synchronized用的锁和ReentrantLock，其实都是“排它锁”。

4. 读写锁
    - 可以在同一时刻允许多个**读**线程访问
    - ReentrantReadWriteLock类作为读写锁的默认实现，内部维护了两个锁：一个读锁，一个写锁。
</code></pre>
<h2 id="抽象类AQS-x2F-AQLS-x2F-AOS"><a href="#抽象类AQS-x2F-AQLS-x2F-AOS" class="headerlink" title="抽象类AQS&#x2F;AQLS&#x2F;AOS"></a>抽象类AQS&#x2F;AQLS&#x2F;AOS</h2><p>​		<strong>AQS</strong>（AbstractQueuedSynchronizer）在JDK 1.5 发布的，提供了一个“队列同步器”的基本功能实现。而AQS里面的“资源”是用一个<code>int</code>类型的数据来表示的，有时候我们的业务需求资源的数量超出了<code>int</code>的范围。</p>
<p>​		所以在JDK 1.6 中，多了一个<strong>AQLS</strong>（AbstractQueuedLongSynchronizer）。它的代码跟AQS几乎一样，只是把资源的类型变成了<code>long</code>类型</p>
<p>​		AQS和AQLS都继承了一个类叫<strong>AOS</strong>（AbstractOwnableSynchronizer）。这个类也是在JDK 1.6 中出现的。这个类只有几行简单的代码。它是用于表示锁与持有者之间的关系（独占模式）。</p>
<h2 id="接口Condition-x2F-Lock-x2F-ReadWriteLock"><a href="#接口Condition-x2F-Lock-x2F-ReadWriteLock" class="headerlink" title="接口Condition&#x2F;Lock&#x2F;ReadWriteLock"></a>接口Condition&#x2F;Lock&#x2F;ReadWriteLock</h2><p>​		juc.locks包下共有三个接口：<code>Condition</code>、<code>Lock</code>、<code>ReadWriteLock</code>。</p>
<p>​		其中，Lock和ReadWriteLock从名字就可以看得出来，分别是锁和读写锁的意思。</p>
<p>​		Lock接口里面有一些获取锁和释放锁的方法声明，而ReadWriteLock里面只有两个方法，分别返回“读锁”和“写锁”</p>
<p>​		Lock接口中有一个方法是可以获得一个<code>Condition</code>。每个对象都可以用继承自<code>Object</code>的<strong>wait&#x2F;notify</strong>方法来实现<strong>等待&#x2F;通知机制</strong>。而Condition接口也提供了类似Object监视器的方法，通过与<strong>Lock</strong>配合来实现等待&#x2F;通知模式</p>
<h2 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h2><ol>
<li><p>ReentrantLock</p>
<ul>
<li>ReentrantLock是一个非抽象类，它是Lock接口的JDK默认实现，实现了锁的基本功能</li>
</ul>
</li>
<li><p>ReentrantReadWriteLock</p>
<ul>
<li>这个类也是一个非抽象类，它是ReadWriteLock接口的JDK默认实现。它与ReentrantLock的功能类似，同样是可重入的，支持非公平锁和公平锁。不同的是，它还支持”读写锁“。</li>
</ul>
</li>
<li><p>StampedLock</p>
<ul>
<li>核心思想：在读的时候如果发生了写，应该通过重试的方式来获取新的值，而不应该阻塞写操作。这种模式也就是典型的无锁编程思想，和CAS自旋的思想一样。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>Java高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/posts/6c92115f/</url>
    <content><![CDATA[<p>概述：Spring基础</p>
<span id="more"></span>

<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>Spring的核心：</p>
<ul>
<li>控制反转（IOC）</li>
<li>面向切面编程（AOP）</li>
</ul>
<p>优点：</p>
<ul>
<li>Spring是存储对象的容器</li>
<li>轻量针对接口编程，解耦合</li>
<li>AOP编程支持</li>
<li>方便继承各种框架</li>
</ul>
<blockquote>
<p>IOC 控制反转- Inversion of Control</p>
<p>​		是一个概念思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。</p>
<p>实现方式：依赖注入Dependency Injection</p>
<p>​		依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。</p>
</blockquote>
<h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><p>Maven依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--核心--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="基于xml的DI"><a href="#基于xml的DI" class="headerlink" title="基于xml的DI"></a>基于xml的DI</h2><h3 id="Spring的配置文件"><a href="#Spring的配置文件" class="headerlink" title="Spring的配置文件"></a>Spring的配置文件</h3><ul>
<li><p>文件名称可以随意，推荐名称为applicationContext.xml</p>
</li>
<li><p>内容：<code>&lt;bean/&gt;</code>：用于定义一个实例对象。一个实例对应一个 bean 元素。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//自定义</span><br><span class="line">&lt;bean id=&quot;stu&quot; class=&quot;top.modi.pojo.Student&quot;&gt;&lt;/bean&gt;</span><br><span class="line">//自带的</span><br><span class="line">&lt;bean id=&quot;myDate&quot; class=&quot;java.util.Date&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>  id：该属性是 Bean 实例的唯一标识，程序通过 id 属性访问 Bean，Bean 与 Bean 间的依赖关系也是通过 id 属性关联的。</p>
</li>
</ul>
<h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">	<span class="type">Student</span> <span class="variable">st</span> <span class="operator">=</span> (Student) ac.getBean(<span class="string">&quot;stu&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建Java对象"><a href="#创建Java对象" class="headerlink" title="创建Java对象"></a>创建Java对象</h3><ul>
<li>Spring初始化对象时要使用无参的构造方法，切记保证实体类中有<strong>无参构造方法</strong>。</li>
<li>Spring 创建对象的默认作用域是<strong>单例模式</strong></li>
</ul>
<h4 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h4><ul>
<li><p>作用：初始化bean对象属性</p>
</li>
<li><p>分类</p>
<ul>
<li><p>set注入：在实体类中设置setter，在配置文件中赋值</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;stu&quot; class=&quot;top.modi.pojo.Student&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;name&quot; value=&quot;xxx&quot;/&gt;</span><br><span class="line">	&lt;property name=&quot;age&quot; value=&quot;20&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>  <strong>如果是引用类型，则需要将value改为ref且值为其id</strong></p>
</li>
<li><p>构造注入：在实体类中的有参构造方法，进行注入</p>
</li>
</ul>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    创建学生对象,通过构造方法参数名称注入值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;stu&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.modi.pojo.Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;22&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;school&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;school&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--    通过构造方法参数下标索引进入注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;stuindex&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.modi.pojo.Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;22&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;李四&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;school&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--    通过构造方法参数进入注入,不指定参数名称和索引下标--&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对于引用类型属性注入，除了上述，还有</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;stuindex&quot; class=&quot;top.modi.pojo.Student&quot; autowire=&quot;byID&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;stuindex&quot; class=&quot;top.modi.pojo.Student&quot; autowire=&quot;byClass&quot;&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>单例模式设置</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;mydate&quot; class=&quot;java.util.Date&quot; scope=&quot;singleton&quot;&gt; ===&gt;单例模式</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;mydate&quot; class=&quot;java.util.Date&quot; scope=&quot;prototype&quot;&gt;   ===&gt;非单例模式</span><br></pre></td></tr></table></figure>



<h2 id="基于注解的DI"><a href="#基于注解的DI" class="headerlink" title="基于注解的DI"></a>基于注解的DI</h2><ul>
<li>不再需要在 Spring 配置文件中声明bean 实例。</li>
<li>需要在 Spring 配置文件中配置组件扫描器，用于在指定的基本包中扫描注解。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;top.modi.pojo&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--如果有多个可以写多行，也可以在引号中用，或者；分隔--&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="创建注解"><a href="#创建注解" class="headerlink" title="创建注解"></a>创建注解</h3><p>对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component :创建所有对象都可以使用此注解,除了控制器,业务逻辑层,数据访问层的对象</span><br><span class="line">@Controller:创建控制器层的对象,此对象可以接收用户请求,返回处理结果</span><br><span class="line">@Service:创建业务逻辑层的对象,此对象可施事务控制,向上给控制器返回数据,向下调用数据访问层</span><br><span class="line">@Repository:创建数据访问层的对象 ,对数据库中的数据进行增删改查操作</span><br></pre></td></tr></table></figure>

<p>对象赋值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Value:给简单类型赋值</span><br><span class="line">@Autowired:给引用类型按类型注入</span><br><span class="line">@Qualifier:给引用类型按名称注入</span><br></pre></td></tr></table></figure>



<ul>
<li>实例1</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component(&quot;xxx&quot;) //该注解的 value 属性用于指定该 bean 的 id 值。</span><br><span class="line">public class Student &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>注：@Component 不指定 value 属性，bean 的 id 是类名的首字母小写。</p>
<ul>
<li>实例2</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Value(&quot;yyy&quot;)</span><br><span class="line">private int age;</span><br></pre></td></tr></table></figure>

<p>注：类中无需 setter。当然，若属性有 setter，则也可将其加到 setter 上</p>
<ul>
<li>实例3</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private School school;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired  //有个属性 required--匹配bean对象，false为忽略</span><br><span class="line">@Qualifier(&quot;xxxName&quot;)//value 属性用于指定要匹配的 Bean 的 id 值</span><br></pre></td></tr></table></figure>

<p>注：在引用属性上使用注解@Autowired，该注解默认使用按类型自动装配 Bean 的方式。</p>
<h2 id="拆分Spring配置文件"><a href="#拆分Spring配置文件" class="headerlink" title="拆分Spring配置文件"></a>拆分Spring配置文件</h2><ul>
<li>拆分策略有按模块拆分和按层拆分</li>
<li>可以使用通配符*进行整合（但父配置文件不能被其包含–一般完全与子配置文件不同）</li>
<li>总配置文件将各其它子文件通过<code>&lt;import/&gt;</code>引入</li>
<li>在测试类中只用导入父配置文件即可</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;import resource=&quot;application_*.xml&quot;&gt;&lt;/import&gt;</span><br></pre></td></tr></table></figure>



<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><ul>
<li>面向切面编程</li>
<li>AOP 底层，就是采用动态代理模式实现的<ul>
<li>JDK 的动态代理</li>
<li>CGLIB的动态代理</li>
</ul>
</li>
<li>优点：减少重复，专注业务</li>
<li>AOP通知类型<ul>
<li>Spring支持AOP的编程，常用的有以下几种：<ol>
<li><strong>Before通知</strong>：在目标方法被调用前调用，涉及接口		org.springframework.aop.MethodBeforeAdvice; </li>
<li><strong>After通知</strong>：在目标方法被调用后调用，涉及接口为org.springframework.aop.AfterReturningAdvice; </li>
<li><strong>Throws通知</strong>：目标方法抛出异常时调用，涉及接口org.springframework.aop.ThrowsAdvice; </li>
<li><strong>Around通知</strong>：拦截对目标对象方法调用，涉及接口为org.aopalliance.intercept.MethodInterceptor。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ol>
<li>切面（Aspect）：公共的，通用的业务</li>
<li>连接点（JoinPoint）：可以被切面织入的具体方法。通常业务接口中的方法均为连接点</li>
<li>切入点（Pointcut）：指声明的一个或多个连接点的集合。</li>
<li>目标对象（Target）：包含主业务逻辑的类的对象</li>
<li>通知（Advice）：切面的执行时间</li>
</ol>
<blockquote>
<p> <strong>切入点定义切入的位置，通知定义切入的时机。</strong></p>
</blockquote>
<h2 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h2><p>maven依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h3><p>AspectJ 中常用的通知有四种类型：</p>
<p>（1）前置通知@Before</p>
<p>（2）后置通知@AfterReturning</p>
<p>（3）环绕通知@Around</p>
<p>（4）最终通知@After</p>
<p>（5）定义切入点@Pointcut(了解)</p>
<h3 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h3><p><strong>execution(访问权限 方法返回值 方法声明(参数)  异常类型)</strong></p>
<p>实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">execution(public * *(..))//任意公共方法</span><br><span class="line">execution(* set*(..))//任何一个以“set”开始的方法</span><br><span class="line">execution(* top.modi.service.impl.*.*(..))//定义在 service 包里的任意类的任意方法</span><br></pre></td></tr></table></figure>

<h3 id="基于注解的AOP"><a href="#基于注解的AOP" class="headerlink" title="基于注解的AOP"></a>基于注解的AOP</h3><p>过程</p>
<ol>
<li>定义切面类–里面的方法是用来插入到目标对象方法中的</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Aspect   //交给AspectJ框架去识别切面类,来进行切面方法的调用</span><br><span class="line">public class MyAspect &#123;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>定义相应的通知方法</p>
</li>
<li><p>在Spring配置文件中声明目标对象和目标对象</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;&quot; class=&quot;目标对象&quot;&gt;</span><br><span class="line">&lt;bean id=&quot;&quot; class=&quot;目标对象&quot;&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>同时注册AspectJ自动代理</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;aop:aspectj-autoproxy&gt;//通过扫描找到@Aspect 定义的切面类，再由切面类根据切入点找到目标类的目标方法，再由通知类型找到切入的时间点</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> 			           <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">SomeService</span> <span class="variable">someService</span> <span class="operator">=</span> (SomeService) ac.getBean(<span class="string">&quot;someService&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>通知类型</strong></p>
<ol>
<li><p><strong>@Before前置通知</strong></p>
<ol>
<li><p>public void</p>
</li>
<li><p>名字自定义</p>
</li>
<li><p>一般没参，可以有个<code>JoinPoint</code></p>
<ul>
<li>可获取切入点表达式、方法签名、目标对象等</li>
<li>所有的通知方法均可包含该参数</li>
</ul>
</li>
<li><p>&#96;&#96;&#96;<br> @Before(value &#x3D; “execution( * top.modi.<em>.</em>(..))”)</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. **@AfterReturning 后置通知**</span><br><span class="line"></span><br><span class="line">    1. public void </span><br><span class="line"></span><br><span class="line">    2. 名字自定义</span><br><span class="line"></span><br><span class="line">    3. 可以包含 JoinPoint 参数（第一），还可以包含用于接收返回值的变量（Object）</span><br><span class="line"></span><br><span class="line">    4. ```</span><br><span class="line">        @AfterReturning(value = &quot;execution(* top.modi.s02.SomeServiceImpl.*(..))&quot;,returning = &quot;必须同接受返回值的变量同名&quot;)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>@Around 环绕通知-</strong></p>
<ol>
<li><p>public 目标方法返回值</p>
</li>
<li><p>名字自定义</p>
</li>
<li><p>参数是ProceedingJoinPoint的类型</p>
</li>
<li><p>必须<code>throws Throwable</code></p>
</li>
<li><p>&#96;&#96;&#96;<br> @Around(value &#x3D; “execution(* top.modi.s03.SomeServiceImpl.*(..))”)</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4.  **@After 最终通知**</span><br><span class="line"></span><br><span class="line">    1. public void</span><br><span class="line"></span><br><span class="line">    2. 名字自定义</span><br><span class="line"></span><br><span class="line">    3. ```</span><br><span class="line">        @After(value = &quot;execution(* top.modi.s04.SomeServiceImpl.*(..))&quot;)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>@Pointcut 定义切入点别名</strong></p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//给切入点表达式起别名</span><br><span class="line">    @Pointcut(value = &quot;execution(* top.modi.s04.SomeServiceImpl.*(..))&quot;)</span><br><span class="line">    public void mycut()&#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="SM集成"><a href="#SM集成" class="headerlink" title="SM集成"></a>SM集成</h1><h2 id="Spring中事务的五大隔离级别"><a href="#Spring中事务的五大隔离级别" class="headerlink" title="Spring中事务的五大隔离级别"></a><strong>Spring中事务的五大隔离级别</strong></h2><ol>
<li>未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据</li>
<li>提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)</li>
<li>可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读，但是innoDB解决了幻读</li>
<li>串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞</li>
</ol>
<blockquote>
<p><strong>MySQL</strong>：mysql默认的事务处理级别是’REPEATABLE-READ’,也就是<strong>可重复读</strong></p>
</blockquote>
<blockquote>
<p><strong>Oracle</strong>：oracle数据库支持READ COMMITTED 和 SERIALIZABLE这两种事务隔离级别。默认系统事务隔离级别是READ COMMITTED,也就是<strong>读已提交</strong></p>
</blockquote>
<h2 id="Spring事务的传播特性"><a href="#Spring事务的传播特性" class="headerlink" title="Spring事务的传播特性"></a>Spring事务的传播特性</h2><ul>
<li><p>常用</p>
<ul>
<li><p><strong>PROPAGATION_REQUIRED：必被包含事务</strong></p>
</li>
<li><p><strong>PROPAGATION_REQUIRES_NEW：自己新开事务，不管之前是否有事务</strong></p>
</li>
<li><p><strong>PROPAGATION_SUPPORTS：支持事务，如果加入的方法有事务，则支持事务，如果没有，不单开事务</strong></p>
</li>
<li><p><strong>PROPAGATION_NEVER：不能运行中事务中，如果包在事务中，抛异常</strong></p>
</li>
<li><p><strong>PROPAGATION_NOT_SUPPORTED：不支持事务，运行在非事务的环境</strong></p>
</li>
</ul>
</li>
<li><p>不常用</p>
<ul>
<li><p>PROPAGATION_MANDATORY：必须包在事务中，没有事务则抛异常</p>
</li>
<li><p>PROPAGATION_NESTED：嵌套事务</p>
</li>
</ul>
</li>
</ul>
<h2 id="Transactional的参数"><a href="#Transactional的参数" class="headerlink" title="@Transactional的参数"></a>@Transactional的参数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Transactional(readOnly = false,  // 读写事务</span><br><span class="line">			timeout = -1,       // 事务的超时时间不限制(数据库有异常或没有连接上，等待的时间，但还是要看连接的数据库是如何设置的。</span><br><span class="line">			//noRollbackFor = ArithmeticException.class,  // noRollbackFor设置遇到指定的错误不用回滚。此处是遇到数学异常不回滚</span><br><span class="line">			isolation = Isolation.DEFAULT,     // 事务的隔离级别，数据库的默认</span><br><span class="line">			propagation = Propagation.REQUIRED	// 事务的传播行为,此处是指当前的方法要在事务中去执行。</span><br><span class="line">	)</span><br></pre></td></tr></table></figure>

<p>注：</p>
<ol>
<li><p><strong>只能声明在public的method</strong></p>
</li>
<li><p>不能被类内部方法调用</p>
</li>
</ol>
<h2 id="事务管理器配置"><a href="#事务管理器配置" class="headerlink" title="事务管理器配置"></a>事务管理器配置</h2><p>Spring的配置文件中定义</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义事务管理器 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span>		<span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--使用注解事务 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">tx:annotation-driven</span>  <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="事务实现"><a href="#事务实现" class="headerlink" title="事务实现"></a>事务实现</h2><p>一种是基于xml文件的实现，一种是基于注解方式实现（多）</p>
<p>Maven依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--aspectj依赖--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--spring核心ioc--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--做spring事务用到的--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--mybatis依赖--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--mybatis和spring集成的依赖--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--mysql驱动--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--阿里公司的数据库连接池--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--声明式事务的配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--声明式事务的配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--使用xml方式声明事务--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置切面的属性，哪些方法需要添加什么事务传播特性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;get*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;select*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;find*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;search*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;add*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;save*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">no-rollback-for</span>=<span class="string">&quot;ArithmeticException&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;insert*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>  <span class="attr">no-rollback-for</span>=<span class="string">&quot;ArithmeticException&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;delete*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;remove*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;clean*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;update*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;modify*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;set*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;change*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;SUPPORTS&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--使用AOP的技术进行切入点织入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> &gt;</span></span><br><span class="line">    <span class="comment">&lt;!--切入点表达式：指定在哪个包下的哪些类中的哪些方法添加事务处理--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcat&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.bjpowernode.service.*.*(..))&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:pointcut</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--完成切面与切入点绑定--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--声明式事务的配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    配置注解驱动--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在对应的类上或方法上添加@Transactional设置传播特性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span>  <span class="comment">//交给Spring接管,进行对象的创建,并且自动注入mapper</span></span><br><span class="line"><span class="meta">@Transactional( propagation = Propagation.REQUIRED  //必须添加事务</span></span><br><span class="line"><span class="meta">                ,readOnly = true  //只读事务（用于查询操作）</span></span><br><span class="line"><span class="meta">                ,timeout = -1   //设置连接永不超时</span></span><br><span class="line"><span class="meta">                ,noRollbackForClassName = &quot;ArithmeticException&quot;  //遇到这个异常不回滚事务</span></span><br><span class="line"><span class="meta">                ,isolation = Isolation.DEFAULT  //使用数据库的隔离级别</span></span><br><span class="line"><span class="meta">              )</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UsersServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UsersService</span> &#123;</span><br></pre></td></tr></table></figure>





<h1 id="综合过程"><a href="#综合过程" class="headerlink" title="综合过程"></a>综合过程</h1><p>整合实现步骤：</p>
<p>1.新建maven工程,添加各种依赖</p>
<p>2.修改目录结构</p>
<p>3.添加SqlMapConfig.xml和XXXMapper.xml模板（Setting-&gt;Editor-&gt;Code Style -&gt;File and Code Templates-&gt;添加）</p>
<p>4.添加jdbc.properties文件</p>
<p>5.添加SqlMapConfig.xml文件—&gt;MyBatis Config file</p>
<p>6.添加applicationContext_dao.xml文件并实现功能</p>
<p>7.添加applicationContext_service.xml文件并实现功能(注解驱动)</p>
<p>8.添加applicationContext_trans.xml文件(xml配置文件方式)</p>
<p>9.新建库springuser,新建表users,accounts</p>
<p>10.新建实体类Users,Accounts</p>
<p>11.新建mapper包下的接口和.xml文件</p>
<p>12.新建service包下的接口和接口实现类</p>
<p>13.新建测试类,完成功能测试</p>
]]></content>
      <categories>
        <category>JAVA框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>javax.serlvet</title>
    <url>/posts/6fdfada4/</url>
    <content><![CDATA[<p>概述：介绍servlet中用到的两种设计模式    <a href="http://t.csdn.cn/QGw8W">参考链接</a></p>
<span id="more"></span>

<h1 id="关于servlet"><a href="#关于servlet" class="headerlink" title="关于servlet"></a>关于servlet</h1><p>​		<strong>Servlet通过servlet引擎运行在Web服务器(如Tomcat，jBoss….)中，以执行请求和响应。</strong>而主流网页的请求、响应是根据HTTP协议（值得一提的是 HTTP是一个没有状态的协议。这意味着要建立一个有效的Web服务应用，你必须能够识别一个连续的来自远端的客户机的唯一的请求。）</p>
<p>​		Java Servlet API提供了一个简单的接口，通过这个接口，Servlet引擎可以有效地跟踪用户的会话。</p>
<p>​		Servlet被初始化之后，它已经可以处理来自客户端的请求，每一个来自客户端的请求都被描述成一个ServletRequest对象，Servlet的响应被描述成一个ServletResponse对象</p>
<h1 id="Servlet接口"><a href="#Servlet接口" class="headerlink" title="Servlet接口"></a>Servlet接口</h1><p>以下是Servlet接口的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">    <span class="comment">// Servlet引擎会在Servlet实例化之后，置入服务之前精确地调用init方法。在调用service方法之前，init方法必须成功退出。</span></span><br><span class="line">    <span class="comment">//但很少用</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig var1)</span> <span class="keyword">throws</span> ServletException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Servlet引擎调用这个方法以允许Servlet响应请求。</span></span><br><span class="line">   <span class="comment">//常用</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest var1, ServletResponse var2)</span> <span class="keyword">throws</span> ServletException, IOException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当一个Servlet被从服务中去除时，Servlet引擎调用这个方法。</span></span><br><span class="line">    <span class="comment">//也很少用</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//允许Servlet向主机的Servlet运行者提供有关它本身的信息。(类似toString)</span></span><br><span class="line">    String <span class="title function_">getServletInfo</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 返回一个ServletConfig对象，作为一个Servlet的开发者，你应该通过init方法存储ServletConfig对象以便这个方法能返回这个对象。</span></span><br><span class="line">    ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		<strong>问题引入</strong>：这里因为需要经常使用某个接口或者类中的某个方法，那么我需要在其子类中实现一些没有用到的方法，这样将会影响开发效率。</p>
<p>​		<strong>解决办法：</strong>Adapter模式（适配器）</p>
<p>​		<strong>概念引入：</strong>那么什么是适配器，举个简单的例子，我们平时给手机充电，如果直接使用220V…显然是不行的，所以我们需要相应的<strong>充电器</strong>为我们降降压。</p>
<p>​		<strong>代码实现思路：</strong> 因为Servlet是一个接口，我需要创建一个类G，让G类去实现Servlet中我不常用（变动很小）的方法。然后我再去继承G类。</p>
<p>​		那么这个G类应该定义成实体类还是抽象类呢？显然为了以后我可以继续复用这个G类，保证我会重写service方法，G类应该写成抽象类，service方法为抽象方法，那么在我继承G类时，就会很自然的重写该方法。</p>
<h2 id="GenericServlet类"><a href="#GenericServlet类" class="headerlink" title="GenericServlet类"></a>GenericServlet类</h2><p>该类的部分源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">GenericServlet</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span>, ServletConfig, Serializable &#123;</span><br><span class="line">    <span class="comment">//重写的destory方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载init方法（不建议在子类中重写该方法）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="built_in">this</span>.config = config;</span><br><span class="line">        <span class="built_in">this</span>.init(); <span class="comment">//保证如果我在GenericServlet的子类中重写init()方法，该init(ServletConfig config)方法不会被破坏，还会执行我重写的init()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写init方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//抽象的service方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest var1, ServletResponse var2)</span> <span class="keyword">throws</span> ServletException, IOException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		抽象类中的方法不一定都是抽象方法，也可以有实例方法，所以我可以让在GenericServlet类继承Servlet后实现更多的功能，如日志，得到某些参数等等的功能，我以后继承这个GenericServlet类后，子类可以直接使用</p>
<p>​		<strong>问题引入</strong>：但是在前面我提到过一个问题，现在用的是HTTP协议，那么为了<strong>判断</strong>前端到底发送了什么请求给后端，并且当前端发送的请求与我写的service要处理的<strong>请求类型不一致</strong>时我要抛出同一个异常给其前端，当我的需要写的子类很多以后，就会有大量重复的代码。</p>
<p>​		<strong>解决办法：</strong>Template Method模式（模板方法）</p>
<p>​		<strong>概念引入：</strong>那么什么是模板方法，也举个例子，我们如果遇到需要到去取钱，前厅小姐姐总会提醒我们需要先去挂个号，然后等待，然后去柜台…这些步骤对每个需要到银行取钱的人来说是一致的，但是显然我们的需要怎么实现这些步骤并不是固定的。</p>
<p>​		<strong>代码实现思路：</strong> 略</p>
<h2 id="HttpServlet类"><a href="#HttpServlet类" class="headerlink" title="HttpServlet类"></a>HttpServlet类</h2><p>该类的部分源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpServlet</span> <span class="keyword">extends</span> <span class="title class_">GenericServlet</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> req.getMethod();</span><br><span class="line">    <span class="type">long</span> lastModified;</span><br><span class="line">    <span class="keyword">if</span> (method.equals(<span class="string">&quot;GET&quot;</span>)) &#123;</span><br><span class="line">        lastModified = <span class="built_in">this</span>.getLastModified(req);</span><br><span class="line">        <span class="keyword">if</span> (lastModified == -<span class="number">1L</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">long</span> ifModifiedSince;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ifModifiedSince = req.getDateHeader(<span class="string">&quot;If-Modified-Since&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalArgumentException var9) &#123;</span><br><span class="line">                ifModifiedSince = -<span class="number">1L</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ifModifiedSince &lt; lastModified / <span class="number">1000L</span> * <span class="number">1000L</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class="line">                <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resp.setStatus(<span class="number">304</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;HEAD&quot;</span>)) &#123;</span><br><span class="line">        lastModified = <span class="built_in">this</span>.getLastModified(req);</span><br><span class="line">        <span class="built_in">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class="line">        <span class="built_in">this</span>.doHead(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;POST&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.doPost(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;PUT&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.doPut(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;DELETE&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.doDelete(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;OPTIONS&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.doOptions(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;TRACE&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.doTrace(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">errMsg</span> <span class="operator">=</span> lStrings.getString(<span class="string">&quot;http.method_not_implemented&quot;</span>);</span><br><span class="line">        Object[] errArgs = <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;method&#125;;</span><br><span class="line">        errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line">        resp.sendError(<span class="number">501</span>, errMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">//报405错误(请求方式)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> lStrings.getString(<span class="string">&quot;http.method_get_not_supported&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.sendMethodNotAllowed(req, resp, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK1.8新特性</title>
    <url>/posts/d111bf74/</url>
    <content><![CDATA[<p><strong>概述：</strong>JDK1.8新特性</p>
<span id="more"></span>

<h1 id="JDK1-8新特性"><a href="#JDK1-8新特性" class="headerlink" title="JDK1.8新特性"></a>JDK1.8新特性</h1><p>新增了9种新特性</p>
<ol>
<li>Lambda 表达式</li>
<li>方法引用</li>
<li>函数式接口</li>
<li>默认方法</li>
<li>Stream</li>
<li>Optional 类</li>
<li>Nashorn  JavaScript引擎</li>
<li>新的日期时间API</li>
<li>Base64</li>
</ol>
<p><a href="https://www.runoob.com/java/java8-new-features.html">参考链接（菜鸟教程）</a></p>
<h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p>也可称为闭包</p>
<p><strong>作用</strong>： 函数作为参数传递进方法中</p>
<p><strong>特征：</strong></p>
<ul>
<li><strong>可选类型声明：</strong>不需要声明参数类型，编译器可以统一识别参数值。</li>
<li><strong>可选的参数圆括号：</strong>一个参数无需定义圆括号，但多个参数需要定义圆括号。</li>
<li><strong>可选的大括号：</strong>如果主体包含了一个语句，就不需要使用大括号。</li>
<li><strong>可选的返回关键字：</strong>如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定表达式返回了一个数值。</li>
</ul>
<p><strong>优势和注意：</strong></p>
<ul>
<li>Lambda 表达式主要用来定义行内执行的方法类型接口，例如，一个简单方法接口。</li>
<li>Lambda 表达式免去了使用匿名方法的麻烦，并且给予Java简单但是强大的函数化的编程能力。</li>
<li>不能在 lambda 内部修改定义在域外的局部变量（只能引用标记了 final 的外层局部变量）</li>
</ul>
<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>Lambda 表达式的替代方式，<strong>方法引用</strong>使用一对冒号 <strong>::</strong></p>
<ul>
<li><p>对象名::方法名</p>
<ul>
<li>被引用方法的参数和接口中的参数一致</li>
<li>接口有返回值，则被引用方法也必须有</li>
<li>方法引用直接赋给接口变量，则此接口变量就引用了一个接口实例</li>
</ul>
</li>
<li><p>类名::静态方法名</p>
<p>  - </p>
</li>
<li><p>类名::引用实例方法</p>
<ul>
<li><p>前提： 当一个对象调用方法时，方法的某个参数是函数式接口，而接口的方法参数列表的第一个参数就是调用者所属的类时，可以用类::实例方法的写法赋给此函数式接口。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ImTheOne</span>&lt;T&gt; &#123;</span><br><span class="line">    String <span class="title function_">handleString</span><span class="params">(T a, String b)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OneClass</span> &#123;</span><br><span class="line">    String oneString;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">concatString</span><span class="params">(String a)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.oneString + a;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">startHandleString</span><span class="params">(ImTheOne&lt;OneClass&gt; imTheOne, String str)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> imTheOne.handleString(<span class="built_in">this</span>, str);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">OneClass</span> <span class="variable">oneClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OneClass</span>();</span><br><span class="line">        oneClass.oneString = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> oneClass.startHandleString(OneClass::concatString, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//相当于以下效果</span></span><br><span class="line">        <span class="type">OneClass</span> <span class="variable">oneClass2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OneClass</span>();</span><br><span class="line">        oneClass2.oneString = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">ImTheOne</span> <span class="variable">theOne2</span> <span class="operator">=</span> (a, b) -&gt; oneClass2.concatString(b);</span><br><span class="line">        <span class="type">String</span> <span class="variable">result2</span> <span class="operator">=</span> theOne2.handleString(theOne2, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        System.out.println(result2);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>类名::构造器</p>
<ul>
<li>格式<code>类名::new</code></li>
</ul>
</li>
<li><p>数组::构造器</p>
<ul>
<li>格式<code>数组[]::new</code></li>
<li>函数式接口的方法必须有一个参数，而且只能有一个，代表未来的数组长度。</li>
</ul>
</li>
</ul>
<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。函数式接口可以被隐式转换为 lambda 表达式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br></pre></td></tr></table></figure>



<h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><ul>
<li><p>以一种声明的方式处理数据</p>
</li>
<li><p>这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。</p>
</li>
<li><p><strong>stream()</strong> − 为集合创建串行流。</p>
</li>
<li><p><strong>parallelStream()</strong> − 为集合创建并行流。</p>
</li>
</ul>
<h1 id="Optional-类"><a href="#Optional-类" class="headerlink" title="Optional 类"></a>Optional 类</h1><p>Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</p>
<p>Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</p>
<p>Optional 类的引入很好的解决空指针异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Optional</span>&lt;T&gt;</span><br><span class="line"><span class="keyword">extends</span> <span class="title class_">Object</span></span><br></pre></td></tr></table></figure>



<h1 id="日期时间-API"><a href="#日期时间-API" class="headerlink" title="日期时间 API"></a>日期时间 API</h1><ul>
<li><strong>Local(本地)</strong> − 简化了日期时间的处理，没有时区的问题。</li>
<li><strong>Zoned(时区)</strong> − 通过制定的时区处理日期时间。</li>
</ul>
<p>LocalDate&#x2F;LocalTime 和 LocalDateTime 类可以在处理时区不是必须的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime.now()</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">System.out.println(localDateTime.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>)));</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(Clock.systemDefaultZone().millis());</span><br><span class="line"><span class="comment">//使用localDateTime获取当前毫秒值</span></span><br><span class="line">System.out.println(LocalDateTime.now().atZone(ZoneId.systemDefault()).toInstant().toEpochMilli())</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime.of(<span class="number">2021</span>, <span class="number">10</span>, <span class="number">28</span>, <span class="number">16</span>, <span class="number">22</span>, <span class="number">50</span>)  <span class="comment">//自定义</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java 1.8</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="comment">//年</span></span><br><span class="line">System.out.println(ldt.getYear());</span><br><span class="line"><span class="comment">//月(英文)1-12</span></span><br><span class="line">System.out.println(ldt.getMonth());</span><br><span class="line"><span class="comment">//月(数字)1-12</span></span><br><span class="line">System.out.println(ldt.getMonthValue());</span><br><span class="line"><span class="comment">//日(以年计算)1-365</span></span><br><span class="line">System.out.println(ldt.getDayOfYear());</span><br><span class="line"><span class="comment">//日(以月计算)1-30</span></span><br><span class="line">System.out.println(ldt.getDayOfMonth());</span><br><span class="line"><span class="comment">//时</span></span><br><span class="line">System.out.println(ldt.getHour());</span><br><span class="line"><span class="comment">//分</span></span><br><span class="line">System.out.println(ldt.getMinute());</span><br><span class="line"><span class="comment">//秒</span></span><br><span class="line">System.out.println(ldt.getSecond());</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Swagger</title>
    <url>/posts/70ccd23d/</url>
    <content><![CDATA[<p><strong>概述：</strong>Swagger基本介绍，<a href="https://mp.weixin.qq.com/s/0-c0MAgtyOeKx6qzmdUG0w">参考链接</a></p>
<span id="more"></span>

<h1 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h1><p><strong>问题：</strong>前后端分离后，API调用更新同步问题</p>
<p><strong>解决方案：</strong>定义schema（计划提纲），实时更新API</p>
<p><strong>工具：</strong>Swagger</p>
<p><strong>官网：</strong><a href="https://swagger.io/">https://swagger.io/</a></p>
<p>Swagger的主要功能： </p>
<ul>
<li>Restful Api 文档在线自动生成器（实时更新）</li>
<li>在线测试API</li>
</ul>
<h2 id="Spring-Boot集成"><a href="#Spring-Boot集成" class="headerlink" title="Spring Boot集成"></a>Spring Boot集成</h2><ol>
<li>导入依赖</li>
<li>设配置类</li>
<li>配置参数</li>
<li>访问测试地址（根据UI界面而定）   <a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a></li>
</ol>
<p>Maven依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 核心依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- UI界面依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>配置类（在启动类上也需要注解@EnableSwagger2）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//配置类</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span><span class="comment">// 开启Swagger2的自动配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="配置Swagger"><a href="#配置Swagger" class="headerlink" title="配置Swagger"></a>配置Swagger</h2><p>Swagger实例Bean是<strong>Docket</strong>  </p>
<h3 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span> <span class="comment">//配置docket以配置Swagger具体参数</span></span><br><span class="line"><span class="keyword">public</span> Docket <span class="title function_">docket</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h3><ol>
<li><p>个人信息设置，通过<code>apiInfo()</code>属性配置文档信息</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Docket <span class="title function_">docket</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2).apiInfo(apiInfo());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置文档信息</span></span><br><span class="line"><span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">Contact</span> <span class="variable">contact</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Contact</span>(<span class="string">&quot;联系人名字&quot;</span>, <span class="string">&quot;http://xxx.xxx.com/联系人访问链接&quot;</span>, <span class="string">&quot;联系人邮箱&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfo</span>(</span><br><span class="line">           <span class="string">&quot;Swagger学习&quot;</span>, <span class="comment">// 标题</span></span><br><span class="line">           <span class="string">&quot;学习演示如何配置Swagger&quot;</span>, <span class="comment">// 描述</span></span><br><span class="line">           <span class="string">&quot;v1.0&quot;</span>, <span class="comment">// 版本</span></span><br><span class="line">           <span class="string">&quot;http://terms.service.url/组织链接&quot;</span>, <span class="comment">// 组织链接</span></span><br><span class="line">           contact, <span class="comment">// 联系人信息</span></span><br><span class="line">           <span class="string">&quot;Apach 2.0 许可&quot;</span>, <span class="comment">// 许可</span></span><br><span class="line">           <span class="string">&quot;许可链接&quot;</span>, <span class="comment">// 许可连接</span></span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()<span class="comment">// 扩展</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置扫描接口，Docket调用<code>select()</code>方法配置将要的扫描接口</p>
<p> 通过包路径扫描</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Docket <span class="title function_">docket</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">      .apiInfo(apiInfo())</span><br><span class="line">      .select()<span class="comment">// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span></span><br><span class="line">      .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;top.modi.swagger.controller&quot;</span>))</span><br><span class="line">      .build();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 通过其他方式</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">any() <span class="comment">// 扫描所有，项目中的所有接口都会被扫描到</span></span><br><span class="line">none() <span class="comment">// 不扫描接口</span></span><br><span class="line"><span class="comment">// 通过方法上的注解扫描，如withMethodAnnotation(GetMapping.class)只扫描get请求</span></span><br><span class="line">withMethodAnnotation(<span class="keyword">final</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotation)</span><br><span class="line"><span class="comment">// 通过类上的注解扫描，如.withClassAnnotation(Controller.class)只扫描有controller注解的类中的接口</span></span><br><span class="line">withClassAnnotation(<span class="keyword">final</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotation)</span><br><span class="line">basePackage(<span class="keyword">final</span> String basePackage) <span class="comment">// 根据包路径扫描接口</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置将要过滤的接口</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Docket <span class="title function_">docket</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">      .apiInfo(apiInfo())</span><br><span class="line">      .select()<span class="comment">// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span></span><br><span class="line">      .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;top.modi.swagger.controller&quot;</span>))</span><br><span class="line">       <span class="comment">// 配置如何通过path过滤,即这里只扫描请求以/modi开头的接口</span></span><br><span class="line">      .paths(PathSelectors.ant(<span class="string">&quot;/modi/**&quot;</span>))</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 其他可选值</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">any() <span class="comment">// 任何请求都扫描</span></span><br><span class="line">none() <span class="comment">// 任何请求都不扫描</span></span><br><span class="line">regex(<span class="keyword">final</span> String pathRegex) <span class="comment">// 通过正则表达式控制</span></span><br><span class="line">ant(<span class="keyword">final</span> String antPattern) <span class="comment">// 通过ant()控制</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Swagger开关，通过<code>enable()</code>方法配置是否启用swagger</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Docket <span class="title function_">docket</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">      .apiInfo(apiInfo())</span><br><span class="line">      .enable(<span class="literal">false</span>) <span class="comment">//配置是否启用Swagger，如果是false，在浏览器将无法访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 动态设置开关</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Docket <span class="title function_">docket</span><span class="params">(Environment environment)</span> &#123;</span><br><span class="line">   <span class="comment">// 设置要显示swagger的环境</span></span><br><span class="line">   <span class="type">Profiles</span> <span class="variable">of</span> <span class="operator">=</span> Profiles.of(<span class="string">&quot;dev&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">   <span class="comment">// 判断当前是否处于该环境</span></span><br><span class="line">   <span class="comment">// 通过 enable() 接收此参数判断是否要显示</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> environment.acceptsProfiles(of);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">      .apiInfo(apiInfo())</span><br><span class="line">      .enable(b) <span class="comment">//配置是否启用Swagger，如果是false，在浏览器将无法访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="API分组"><a href="#API分组" class="headerlink" title="API分组"></a>API分组</h3><p>当配置了多个docket时，通过<code>groupName()</code>方法即可配置分组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Docket <span class="title function_">docket</span><span class="params">(Environment environment)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2).apiInfo(apiInfo())</span><br><span class="line">      .groupName(<span class="string">&quot;group1&quot;</span>) <span class="comment">// 配置分组group1</span></span><br><span class="line">       <span class="comment">// 省略配置....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>给需要的类、方法和属性进行<strong>注解</strong></p>
<p>示例：一个实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiModel(&quot;用户实体&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">   <span class="meta">@ApiModelProperty(&quot;用户名&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> String username;</span><br><span class="line">   <span class="meta">@ApiModelProperty(&quot;密码&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="常用的注解"><a href="#常用的注解" class="headerlink" title="常用的注解"></a>常用的注解</h3><p>Swagger的所有注解定义在io.swagger.annotations包下</p>
<table>
<thead>
<tr>
<th>Swagger注解</th>
<th>简单说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Api(tags &#x3D; “xxx模块说明”)</td>
<td>作用在模块类上</td>
</tr>
<tr>
<td>@ApiOperation(“xxx接口说明”)</td>
<td>作用在接口方法上</td>
</tr>
<tr>
<td>@ApiModel(“xxxPOJO说明”)</td>
<td>作用在模型类上：如VO、BO</td>
</tr>
<tr>
<td>@ApiModelProperty(value &#x3D; “xxx属性说明”,hidden &#x3D; true)</td>
<td>作用在类方法和属性上，hidden设置为true可以隐藏该属性</td>
</tr>
<tr>
<td>@ApiParam(“xxx参数说明”)</td>
<td>作用在参数、方法和字段上，类似@ApiModelProperty</td>
</tr>
</tbody></table>
<h2 id="各种UI界面"><a href="#各种UI界面" class="headerlink" title="各种UI界面"></a>各种UI界面</h2><p>1、默认的  <strong>访问 <a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a></strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、bootstrap-ui  <strong>访问 <a href="http://localhost:8080/doc.html">http://localhost:8080/doc.html</a></strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入swagger-bootstrap-ui包 /doc.html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-bootstrap-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3、Layui-ui  <strong>访问 <a href="http://localhost:8080/docs.html">http://localhost:8080/docs.html</a></strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入swagger-ui-layer包 /docs.html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.caspar-chen<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-ui-layer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>4、mg-ui  <strong>访问 <a href="http://localhost:8080/document.html">http://localhost:8080/document.html</a></strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入swagger-ui-layer包 /document.html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zyplayer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-mg-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注：需要看到相应的界面样式长啥样，点文章顶部的参考链接哦。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Swagger</tag>
      </tags>
  </entry>
  <entry>
    <title>vue基本知识</title>
    <url>/posts/94774664/</url>
    <content><![CDATA[<p><strong>概述：</strong>vue基本入门</p>
<span id="more"></span>

<h1 id="Vue准备工作"><a href="#Vue准备工作" class="headerlink" title="Vue准备工作"></a>Vue准备工作</h1><p>参考文档<a href="https://cn.vuejs.org/">(官方文档)</a></p>
<ol>
<li>安装Vue工具<strong>Vue CLI</strong></li>
<li>检查</li>
<li>创建项目</li>
<li>启动项目</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cnpm install -g @vue/cli</span><br><span class="line">vue --version</span><br><span class="line">vue create name-demo</span><br><span class="line"><span class="comment">//进入项目选择，根据需要选择</span></span><br><span class="line"><span class="comment">//一般选择 Babel / Progressive web App... / Router / Vuex</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//启动方式一</span></span><br><span class="line">cd name-demo</span><br><span class="line">cnpm run serve</span><br><span class="line"><span class="comment">//启动方式二: 图形化启动</span></span><br><span class="line">vue ui</span><br></pre></td></tr></table></figure>

<p>文件中比较重要的文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name-demo</span><br><span class="line"> |</span><br><span class="line"> |---src </span><br><span class="line"> 	  |---assets  	 //存放静态文件</span><br><span class="line"> 	  |---component  //存放组件</span><br></pre></td></tr></table></figure>



<h1 id="Vue基本语法"><a href="#Vue基本语法" class="headerlink" title="Vue基本语法"></a>Vue基本语法</h1><h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;   	//支持JavaScript</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">	export default &#123;</span><br><span class="line">        name: &quot;hello&quot;,</span><br><span class="line">        data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                message: &quot;test&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<ol>
<li><p><strong>v-html</strong>  :  渲染html语句</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p v-html=&quot;data&quot;&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>v-bind ( : )</strong>   :  将数据放入标签中的属性中</p>
</li>
</ol>
<h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><ol>
<li><p><strong>v-if &amp; v-else</strong> : 渲染为<code>true &amp; false</code>的内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p v-if=&quot;flag&quot;&gt;xxxx&lt;/p&gt;</span><br><span class="line">&lt;p v-else&gt;yyyy&lt;/p&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>v-show</strong>  :  同上</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p v-show=&quot;flag&quot;&gt;xxxx&lt;/p&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>区别：v-if 会按条件渲染页面（F12中的元素中没有或者有该语句块），切换开销大，而v-show反之。</p>
</li>
</ol>
<h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><ol>
<li><p><strong>v-for</strong>  :  把数组循环遍历一遍 ;  items 数据源 &amp; item每条数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;item in items&quot;&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;(item,index) in items&quot; :key=&quot;item.id&quot;&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p>特点：添加元素时，已经渲染好的不会再次渲染</p>
</li>
</ol>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><ol>
<li><p><strong>v-on   ( @ )</strong>  : 监听事件</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button @click=&quot;数据/函数名/函数名(有参)&quot;&gt;&lt;/button&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="表单输入绑定"><a href="#表单输入绑定" class="headerlink" title="表单输入绑定"></a>表单输入绑定</h2><ol>
<li><p>v-model  :  <code>&lt;input&gt;  &lt;textarea&gt;  &lt;select&gt;</code>  双向绑定数据</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input v-model=&quot;message&quot; / &gt;</span><br><span class="line">&lt;input v-model.lazy=&quot;message&quot; / &gt;   //不会与&lt;p&gt;立即同步</span><br><span class="line">&lt;input v-model.trim=&quot;message&quot; / &gt;   //去除空格</span><br><span class="line">&lt;p&gt;</span><br><span class="line">    &#123;&#123;message&#125;&#125;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure>

 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">	return &#123;</span><br><span class="line">		message: &quot;&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><ul>
<li>单文件组件（<code>.vue</code>文件）</li>
</ul>
<p>demo01.vue</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;h1&gt;demo01&lt;/h1&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &quot;demo01&quot;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">//scoped 限定当前的css样式只在此组件中生效</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">    h1 &#123;</span><br><span class="line">        color: blue;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>



<ul>
<li>引入组件（组件进行组合）</li>
</ul>
<p>demo02.vue</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;h1&gt;demo02&lt;/h1&gt;</span><br><span class="line">	&lt;demo01&gt;&lt;/demo01&gt;     //3.使用</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import demo01 from &quot;../components/demo01.vue&quot;  //1.引入</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    name: &quot;demo02&quot;,</span><br><span class="line">    components: &#123;</span><br><span class="line">    	demo01            //2.挂载</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>



<ul>
<li>组件交互（数据交互1–调用传入）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;h1&gt;demo01&lt;/h1&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &quot;demo01&quot;</span><br><span class="line">    props:&#123;</span><br><span class="line">    	key: &#123;        // 在demo02引用的标签中 可以使用的属性</span><br><span class="line">    		type: String, // 该属性的类型</span><br><span class="line">    		default: &quot;&quot;   // 该属性的默认值</span><br><span class="line">    	&#125;</span><br><span class="line">    	names: &#123;</span><br><span class="line">            type: Array,</span><br><span class="line">            //数组和对象必须使用函数进行返回</span><br><span class="line">            default: function() &#123;</span><br><span class="line">                return []</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>Prop类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String， Number， Boolean， Array， Object， Function</span><br></pre></td></tr></table></figure>



<ul>
<li>自定义事件组件交互（数据交互2–被调用传入）<code>$emit</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;h1&gt;demo01&lt;/h1&gt;</span><br><span class="line">	&lt;button @click=&quot;sendClickHandler&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">	name: &quot;demo01&quot;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            msg: &quot;data&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        sendClickHandler()&#123;</span><br><span class="line">            this.&amp;emit(&quot;onEvent&quot;, this.msg)  // onEvent就是demo02通过事件调用demo01的方法名,this.msg将会进行返回</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;h1&gt;demo02&lt;/h1&gt;</span><br><span class="line">	&lt;demo01 @onEvent=&quot;getMsg&quot;&gt;&lt;/demo01&gt;     //3.使用</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import demo01 from &quot;../components/demo01.vue&quot;  //1.引入</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    name: &quot;demo02&quot;,</span><br><span class="line">    components: &#123;</span><br><span class="line">    	demo01            //2.挂载</span><br><span class="line">    &#125;</span><br><span class="line">    methods: &#123;</span><br><span class="line">    	getMsg(data) &#123;  //data来接收this.msg</span><br><span class="line">            console.log(data)</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>子组件中通过各种事件监听（click..）调用本地方法，再通过$emit 将数据返回给父组件。</p>
<p>父组件通过$emit中的事件名调用，得到返回的数据，再通过本地方法进行处理。</p>
<p>从而子组件的数据可以返回给父组件</p>
</blockquote>
<ul>
<li>组件的生命周期</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beforeCreate/created     创建</span><br><span class="line">beforeMount/mounted      渲染</span><br><span class="line">beforeUpdate/updated     更新</span><br><span class="line">beforeUnmount/unmounted  卸载</span><br></pre></td></tr></table></figure>



<h2 id="第三方"><a href="#第三方" class="headerlink" title="第三方"></a>第三方</h2><p>如Swiper等，通过组件组合进行引用，具体参照具体的官方文档</p>
<h1 id="Axios-amp-路由"><a href="#Axios-amp-路由" class="headerlink" title="Axios &amp; 路由"></a>Axios &amp; 路由</h1><h2 id="网络请求-amp-其封装"><a href="#网络请求-amp-其封装" class="headerlink" title="网络请求 &amp; 其封装"></a>网络请求 &amp; 其封装</h2><ul>
<li><p>全局引用axios  再main.js中设置</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import axios from &quot;axios&quot;</span><br><span class="line"></span><br><span class="line">const app=createApp(App);</span><br><span class="line">app.config.globalProperties.$axios = axios</span><br><span class="line">app.mount(&#x27;#app&#x27;)</span><br><span class="line"></span><br><span class="line">//组件中调用</span><br><span class="line">this.$axios</span><br></pre></td></tr></table></figure>
</li>
<li><p>局部引用</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import axios from &quot;axios&quot;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">	name: &quot;demo03&quot;,</span><br><span class="line">	data() &#123;&#125;,</span><br><span class="line">	mounted() &#123;</span><br><span class="line">		axios(&#123;</span><br><span class="line">			method: &quot;get&quot;,</span><br><span class="line">			url: &quot;xxx&quot;</span><br><span class="line">		&#125;).then(res =&gt; &#123;....&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//简写</span><br><span class="line">axios.get(url)</span><br></pre></td></tr></table></figure>
</li>
<li><p>封装</p>
<blockquote>
<p>创建一个util包，进行公共配置，如请求超时设置，拦截器，post请求处理 ， request&#x2F;response请求处理</p>
</blockquote>
</li>
</ul>
<h2 id="请求跨域解决方案"><a href="#请求跨域解决方案" class="headerlink" title="请求跨域解决方案"></a>请求跨域解决方案</h2><ol>
<li>后台在Controller上加注解**@CrossOrigin**</li>
<li>前台解决：proxy  在config文件中设置</li>
</ol>
<h2 id="路由Router"><a href="#路由Router" class="headerlink" title="路由Router"></a>路由Router</h2><p>作用： 管理页面的跳转  需要在main.js中引入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123;createRouter, createWebHashHistory &#125; from &quot;vue-router&quot;</span><br><span class="line"></span><br><span class="line">const routes = &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		path: &quot;/&quot;,</span><br><span class="line">		component: demo01</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		path: &quot;/news/:msg&quot;,   //传递参数</span><br><span class="line">		name: news</span><br><span class="line">		component: () =&gt; import(&quot;vue-path&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		path: &quot;/about&quot;, </span><br><span class="line">		name: about,</span><br><span class="line">		component: () =&gt; import(&quot;vue-path&quot;),</span><br><span class="line">		children: [</span><br><span class="line">			&#123;</span><br><span class="line">				path: &quot;info&quot;,  //不加/</span><br><span class="line">				component: () =&gt; import(&quot;vue-path&quot;)</span><br><span class="line">			&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const router = createRouter(&#123;</span><br><span class="line">	history: createWebHashHistory(),</span><br><span class="line">	routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export default router;</span><br></pre></td></tr></table></figure>

<p>调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line"></span><br><span class="line">&lt;router-link to=&quot;/&quot;&gt;home1&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;router-link to=&quot;/news/username&quot;&gt;home2&lt;/router-link&gt;  //username参数</span><br><span class="line">&#123;&#123; $route.params.msg &#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;router-link to=&quot;/about/info&quot;&gt;home3&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>



<h1 id="Vue状态管理"><a href="#Vue状态管理" class="headerlink" title="Vue状态管理"></a>Vue状态管理</h1><p>简单理解： 管理组件间的数据交互，它提供了一个STORE空间来集中管理数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; createStore &#125; from &quot;vuex&quot;</span><br><span class="line"></span><br><span class="line">export default createStore(&#123;</span><br><span class="line">	state: &#123;</span><br><span class="line">		msg: 0   //数据 &amp; 状态</span><br><span class="line">	&#125;,</span><br><span class="line">	//对state中的某些状态进行预处理（不能改变state的状态）</span><br><span class="line">	getters: &#123;</span><br><span class="line">		getMsg(state) &#123;</span><br><span class="line">			return state.msg &gt; 0 ? 1:0</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	//对state中的某些状态进行更改（同步）</span><br><span class="line">	mutations: &#123;</span><br><span class="line">		addMsg(state, num) &#123;</span><br><span class="line">			state.msg++</span><br><span class="line">			state.msg += num</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	//对state中的某些状态进行更改（异步）</span><br><span class="line">	actions: &#123;</span><br><span class="line">		asynSetMsg(&#123; commit &#125;) &#123;  //注意写法</span><br><span class="line">			axios.get(url).then(res =&gt; &#123;</span><br><span class="line">				commit(&quot;addMsg&quot;,res.data)</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123; $store.state.msg &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; $store.getters.getMsg &#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;button @click=&quot;xx&quot;&gt;&lt;/button&gt; </span><br><span class="line">methods: &#123;</span><br><span class="line">	xx() &#123;</span><br><span class="line">		this.$store.commit(&quot;addMsg&quot;, 12)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;button @click=&quot;yy&quot;&gt;&lt;/button&gt; </span><br><span class="line">methods: &#123;</span><br><span class="line">	yy() &#123;</span><br><span class="line">		this.$store.dispatch(&quot;asynSetMsg&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; mapState,mapGetters,mapMutations,mapActions &#125; from &quot;vuex&quot;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">	//专门来读取vuex</span><br><span class="line">	computed:&#123;</span><br><span class="line">		...mapState([&quot;msg&quot;])</span><br><span class="line">		...mapGetters([&quot;getMsg&quot;])</span><br><span class="line">		...mapMutations([&quot;addMsg&quot;])</span><br><span class="line">		...mapMutations([&quot;asynSetMsg&quot;])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//直接读取</span><br><span class="line">&#123;&#123; msg &#125;&#125;</span><br><span class="line">&#123;&#123; getMsg &#125;&#125;</span><br><span class="line"></span><br><span class="line">this.addMsg(1212)</span><br><span class="line">this.asynSetMsg</span><br></pre></td></tr></table></figure>



<h1 id="Vue3新特性"><a href="#Vue3新特性" class="headerlink" title="Vue3新特性"></a>Vue3新特性</h1><p>待补充…</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/posts/7b510e10/</url>
    <content><![CDATA[<p>概括：代理模式基础</p>
<span id="more"></span>

<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><ul>
<li>定义：目标对象不可访问，通过代理对象增强功能访问</li>
<li>作用：控制目标对象的访问， 增强功能</li>
<li>分类：静态和动态代理</li>
</ul>
<blockquote>
<p>在学习之前明确谁是目标对象，代理对象，业务接口</p>
</blockquote>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><ul>
<li>目标对象和代理对象实现同一个业务接口（业务接口service固定）</li>
<li>目标对象必须实现接口</li>
<li>代理对象在程序运行前就已经存在</li>
<li>灵活的进行目标对象的<strong>切换</strong></li>
</ul>
<p>目标对象(implement  service)—–&gt;业务接口（Service）(固定的)&lt;——–代理对象(implement  service)&lt;——-客户</p>
<blockquote>
<p>面向接口编程</p>
<p>​	生活化实例：</p>
<p>​		就例如Type-C接口（一个数据线），将接口定义好以后，我们有两样东西，一个是手机，一个是插座。</p>
<p>​		当手机不再是这个手机换成另一个手机（键盘）的时候，我还可以用这个接口来给手机充电（插上插座）</p>
<p>​		同样插座不一定需要，我可以换成充电宝，它也实现了这个Type-C接口，它也可以给我的手机（键盘）充电</p>
</blockquote>
<blockquote>
<p>静态的理解：</p>
<p>​	关于静态代理，就是把在<strong>代理对象</strong>内部，用<strong>业务接口</strong>去接住传入的<strong>目标对象</strong>（多态），然后调用该<strong>业务接口中的被目标对象实现的方法</strong>（固定的调用方法名），<strong>代理对象</strong>也可以实现其他过程来丰富<strong>业务接口</strong>中的方法（对于客户来说，我只需要知道<strong>业务接口</strong>中的方法名叫啥，就可以调用<strong>代理对象</strong>中丰富后的方法）</p>
<p>​	局限就是，当业务接口中的<em><strong>方法名变化时</strong></em>，需要更改<strong>代理对象</strong>和<strong>目标对象</strong>中的相应方法</p>
</blockquote>
<blockquote>
<p>动态的理解：</p>
<p>​	相较于静态代理，弥补了其局限，动态的获得业务中的方法名</p>
<p>​	其他同静态代理一样，需要传入<strong>目标对象</strong>，实现更多的功能</p>
</blockquote>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h3 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h3><ul>
<li>目标对象必须实现业务接口</li>
<li>代理对象不需要实现业务接口（比较静态，少了一个）</li>
<li>代理对象在程序运行前不存在，运行后动态的在内存中创建</li>
<li>可以对业务接口中的功能进行切换（多了静态没有的东西，也是重点）</li>
<li>代理对象不能强转为目标对象（也不允许）</li>
</ul>
<h4 id="使用的类和接口"><a href="#使用的类和接口" class="headerlink" title="使用的类和接口"></a>使用的类和接口</h4><ol>
<li><p>Proxy类：java.lang.reflect.Proxy包下，有个方法Proxy.newProxyInstance(  ,   ,   )—-生成动态代理对象</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader, //类加载器，加载目标对象</span><br><span class="line">								   Class&lt;?&gt;[] interfaces, //目标对象实现的所有接口</span><br><span class="line">							  InvocationHandler h//实现代理和业务功能，使用匿名内部类实现</span><br><span class="line">												)</span><br></pre></td></tr></table></figure>

</li>
<li><p>Method类</p>
<ul>
<li>反射用的类，用来进行目标对象的方法（具体的业务实现方法）反射调用</li>
</ul>
</li>
<li><p>InvocationHandler接口</p>
<ul>
<li><p>实现代理和业务功能，使用匿名内部类实现</p>
</li>
<li><p>&#96;&#96;&#96;java<br>interface Service {}<br>Service service &#x3D; new Service() {<br>@Override<br>public void sing() {<br>    System.out.println(“匿名内部实现”)<br>}<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 动态代理工厂实现</span><br><span class="line"></span><br><span class="line">```Java</span><br><span class="line">public class ProxyFactory &#123;</span><br><span class="line">    //创建接口成员变量</span><br><span class="line">    Service target;</span><br><span class="line">    //传入目标对象</span><br><span class="line">    public ProxyFactory(Service target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    //获取代理对象的方法，返回一个代理对象</span><br><span class="line">    public Object getAgent() &#123;</span><br><span class="line">        //调用Proxy类中的newProxyInstance方法，创建代理对象</span><br><span class="line">        return Proxy.newProxyInstance(</span><br><span class="line">                //ClassLoader loader,加载目标对象</span><br><span class="line">                target.getClass().getClassLoader(),</span><br><span class="line">                //Class&lt;?&gt;[] interfaces,得到目标对象所实现的所有接口</span><br><span class="line">                target.getClass().getInterfaces(),</span><br><span class="line">                //InvocationHandler h， 实现代理功能的接口</span><br><span class="line">                new InvocationHandler() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public Object invoke(</span><br><span class="line">                                        //创建代理对象</span><br><span class="line">                                         Object proxy,</span><br><span class="line">                                         //method就是目标方法</span><br><span class="line">                                         Method method,</span><br><span class="line">                                         //目标方法的参数</span><br><span class="line">                                         Object[] args) throws Throwable &#123;</span><br><span class="line">                        System.out.println(&quot;代理功能，，，，&quot;);</span><br><span class="line">                        //目标对象的业务方法</span><br><span class="line">                        Object obj = method.invoke(target, args);</span><br><span class="line">                        return obj; //目标方法的返回值</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="CGLib动态代理"><a href="#CGLib动态代理" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h3><ul>
<li>通过动态的在内存中构建子类对象，重写父类方法进行代理（补充了JDK代理的不足）</li>
<li>目标对象没有实现接口，但需要进行代理</li>
<li>子类代理是对象字节码框架ASM来实现的</li>
</ul>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
