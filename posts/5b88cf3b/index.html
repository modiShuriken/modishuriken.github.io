<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon2.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon3.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.geekzu.org/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>
    <script>
    (function () {
        if ('') {
            if (prompt('请输入文章密码') !== '') {
                alert('密码错误！');
                if (history.length === 1) {
                    location.replace("http://www.modishuriken.top"); // 这里替换成你的首页
                } else {
                    history.back();
                }
            }
        }
    })();
</script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"modishuriken.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","width":320,"display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>
  <meta name="description" content="概述：阶段1">
<meta property="og:type" content="article">
<meta property="og:title" content="Java高并发1">
<meta property="og:url" content="https://modishuriken.github.io/posts/5b88cf3b/index.html">
<meta property="og:site_name" content="Java笔记">
<meta property="og:description" content="概述：阶段1">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/07/09/o5QuNZSsFk2gcdY.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/09/l37JpxCsfb6w2Xz.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/09/GtbUDB7WcNO4I96.png">
<meta property="article:published_time" content="2022-06-15T16:00:00.000Z">
<meta property="article:modified_time" content="2022-07-11T10:12:04.699Z">
<meta property="article:author" content="modiShuriken">
<meta property="article:tag" content="Java高并发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/07/09/o5QuNZSsFk2gcdY.png">

<link rel="canonical" href="https://modishuriken.github.io/posts/5b88cf3b/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java高并发1 | Java笔记</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Java笔记" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Java笔记</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Personal Weblog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://modishuriken.github.io/posts/5b88cf3b/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lin.png">
      <meta itemprop="name" content="modiShuriken">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Java笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java高并发1
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-16 00:00:00" itemprop="dateCreated datePublished" datetime="2022-06-16T00:00:00+08:00">2022-06-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-11 18:12:04" itemprop="dateModified" datetime="2022-07-11T18:12:04+08:00">2022-07-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">JAVA基础</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><strong>概述：</strong>阶段1</p>
<span id="more"></span>

<h1 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h1><ol>
<li>上下文切换<ul>
<li>指某⼀时间点 CPU 寄存器和程序计数器的内容。</li>
</ul>
</li>
<li>同步(Synchronous)  &amp;  异步(Asynchronous)<ul>
<li><strong>同步</strong>方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。</li>
<li><strong>异步</strong>方法调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作</li>
</ul>
</li>
<li>并发(Concurrency)  &amp;  并行(Parallelism)<ul>
<li><strong>并发</strong>说的是在<strong>一个时间段内</strong>，多件事情在这个时间段内<strong>交替执行</strong>。</li>
<li><strong>并行</strong>说的是多件事情在<strong>同一个时刻</strong>同时发生。</li>
</ul>
</li>
<li>临界区<ul>
<li>表示一种公共资源或者说共享数据，可以被多个线程使用，但是每一次只能有一个线程使用它，一旦临界区资源被占用，其他线程要想使用这个资源就必须等待。</li>
</ul>
</li>
<li>阻塞（Blocking）  &amp;  非阻塞（Non-Blocking）<ul>
<li>比如一个线程占用了临界区资源，那么其他所有需要这个资源的线程就必须在这个临界区中等待。等待会导致线程挂起，这种情况就是阻塞</li>
</ul>
</li>
<li>死锁（Deadlock）  &amp;  饥饿（Starvation）  &amp;  活锁（Livelock）<ul>
<li><strong>死锁：</strong>彼此之间相互占用了其他线程的资源，如果都不释放自己的资源，那么这个状况将永远持续下去。</li>
<li><strong>饥饿：</strong>指某一个或者多个线程因为种种原因无法获得所要的资源，导致一直无法执行。（优先级问题）</li>
<li><strong>活锁：</strong>如果线程智力不够且都秉承着“谦让”的原则，主动将资源释放给他人使用，那么久会导致资源不断地在两个线程间跳动，而没有一个线程可以同时拿到所有资源正常执行。</li>
</ul>
</li>
</ol>
<h1 id="入门类-amp-接口"><a href="#入门类-amp-接口" class="headerlink" title="入门类&amp;接口"></a>入门类&amp;接口</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">继承Thread类，重写run发方法</span><br><span class="line"></span><br><span class="line">实现Runnable接口的run方法</span><br></pre></td></tr></table></figure>



<h2 id="Runnable-amp-Thread—没有返回值"><a href="#Runnable-amp-Thread—没有返回值" class="headerlink" title="Runnable&amp;Thread—没有返回值"></a>Runnable&amp;Thread—没有返回值</h2><p><strong>Runnable接口源码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到  Runnable  是⼀个<strong>函数式接⼝</strong>，这意味着我们可以使⽤Java 8的函数式编程来简化代码</p>
<p>Thread类源码： Thread  类是⼀个  Runnable  接⼝的实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ⽚段1 - init⽅法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span><br><span class="line"><span class="params">				<span class="type">long</span> stackSize, AccessControlContext acc,</span></span><br><span class="line"><span class="params">				<span class="type">boolean</span> inheritThreadLocals)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// ********⽚段2 - 构造函数调⽤init⽅法*******</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(Runnable target)</span> &#123;</span><br><span class="line">		init(<span class="literal">null</span>, target, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ⽚段3 - 使⽤在init⽅法⾥初始化AccessControlContext类型的私有属性----没啥用</span></span><br><span class="line"><span class="built_in">this</span>.inheritedAccessControlContext =acc != <span class="literal">null</span>?acc:AccessController.getContext();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ⽚段4 - 两个对⽤于⽀持ThreadLocal的私有属性，本地线程副本变量⼯具类</span></span><br><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">inheritableThreadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个主要使用的构造方法</span></span><br><span class="line">Thread(Runnable target)</span><br><span class="line">Thread(Runnable target, String name)</span><br></pre></td></tr></table></figure>



<h3 id="综上：写出一个简单的线程"><a href="#综上：写出一个简单的线程" class="headerlink" title="综上：写出一个简单的线程"></a><strong>综上：写出一个简单的线程</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Java 8 匿名内部类&quot;</span>);</span><br><span class="line">	&#125;).start();</span><br></pre></td></tr></table></figure>

<p>注意，如果是实现Runnable接口，需要Thread类来接</p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ol>
<li><p>实例方法</p>
<ul>
<li>start()：<ul>
<li>开始执⾏线程的⽅法，java虚拟机会调⽤线程内的run()⽅法；</li>
</ul>
</li>
<li>yield()：<ul>
<li>yield在英语⾥有放弃的意思，同样，这⾥的yield()指的是当前线程愿意让出对当前处理器的占⽤。这⾥需要注意的是，就算当前线程调⽤了yield()⽅法，程序在调度的时候，也还有可能继续运⾏这个线程的；</li>
</ul>
</li>
<li>join()：<ul>
<li>内部调⽤的是Object类的wait⽅法实现的；</li>
<li>合并线程（插队操作）</li>
<li>如果有两个线程Thread A和Thread B，且在A中调用了B.join()方法，则线程A会等待线程B执行结束后继续执行。</li>
</ul>
</li>
</ul>
</li>
<li><p>静态方法</p>
<ul>
<li>currentThread()：<ul>
<li>静态⽅法，返回对当前正在执⾏的线程对象的引⽤；</li>
</ul>
</li>
<li>sleep(long)：<ul>
<li>静态⽅法，使当前线程睡眠⼀段时间（毫秒级）；</li>
<li>存在异常InteruptedException(打断)</li>
<li>不会释放锁</li>
<li>必须有时间参数</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Callable-amp-Future-amp-FutureTask-—-有返回值"><a href="#Callable-amp-Future-amp-FutureTask-—-有返回值" class="headerlink" title="Callable &amp; Future &amp; FutureTask — 有返回值"></a>Callable &amp; Future &amp; FutureTask — 有返回值</h2><p><strong>Callable接口源码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">		V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：提供的方法是有返回值的，而且支持泛型</p>
<p><strong>Future接口方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> paramBoolean)</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> V <span class="title function_">get</span><span class="params">(<span class="type">long</span> paramLong, TimeUnit paramTimeUnit)</span></span><br><span class="line">		<span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> cancel—方法是<strong>试图取消</strong>⼀个线程的执行。<br>        boolean  类型的返回值是“是否取消成功”的意思。参数  paramBoolean  表示是否采⽤中断的⽅式取消线程执⾏。</p>
<p><em>使用建议：</em><br>        如果为了可取消性⽽使⽤  Future  但⼜不提供可⽤的结果，则可以声明  Future&lt;?&gt;形式类型、并返回  null  作为底层任务的结果。</p>
<p><strong>RunnableFuture接口源码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RunnableFuture</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">Runnable</span>, Future&lt;V&gt; &#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		* Sets this Future to the result of its computation</span></span><br><span class="line"><span class="comment">		* unless it has been cancelled.</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>**FutureTask类 **—–&gt; 实现RunnableFuture接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现了Callable接口的类</span></span><br><span class="line"><span class="type">Thread01</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread01</span>();</span><br><span class="line"><span class="comment">//通过task获取一个异步线程</span></span><br><span class="line"><span class="type">FutureTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(c);</span><br><span class="line"><span class="comment">//获取Callable的返回值</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> task.get();</span><br><span class="line"><span class="comment">//传入Thread类</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread(task);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>



<h1 id="线程组-amp-线程优先级"><a href="#线程组-amp-线程优先级" class="headerlink" title="线程组 &amp; 线程优先级"></a>线程组 &amp; 线程优先级</h1><ul>
<li><p>线程组</p>
<ul>
<li><p>每个Thread<strong>必然</strong>存在于⼀个ThreadGroup中，Thread不能独⽴于ThreadGroup存在。</p>
</li>
<li><p>ThreadGroup是⼀个标准的<strong>向下引⽤</strong>的树状结构，这样设计的原因是<strong>防止”上级”线程被”下级”线程引用而无法有效地被GC回收。</strong></p>
</li>
<li><p>可以统一异常处理</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//在线程组ThreadGroup threadGroup1中重写该方法，线程自动抛出</span><br><span class="line">public void uncaughtException(Thread t, Throwable e) </span><br><span class="line"></span><br><span class="line">//子线程</span><br><span class="line">Thread thread1 = new Thread(threadGroup1, new Runnable()...</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程组源码</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadGroup</span> <span class="keyword">implements</span> <span class="title class_">Thread</span>.UncaughtExceptionHandler &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup parent; <span class="comment">// ⽗亲ThreadGroup</span></span><br><span class="line">	String name; <span class="comment">// ThreadGroupr 的名称</span></span><br><span class="line">	<span class="type">int</span> maxPriority; <span class="comment">// 线程最⼤优先级</span></span><br><span class="line">	<span class="type">boolean</span> destroyed; <span class="comment">// 是否被销毁</span></span><br><span class="line">	<span class="type">boolean</span> daemon; <span class="comment">// 是否守护线程</span></span><br><span class="line">	<span class="type">boolean</span> vmAllowSuspension; <span class="comment">// 是否可以中断</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">nUnstartedThreads</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 还未启动的线程</span></span><br><span class="line">	<span class="type">int</span> nthreads; <span class="comment">// ThreadGroup中线程数⽬</span></span><br><span class="line">	Thread threads[]; <span class="comment">// ThreadGroup中的线程</span></span><br><span class="line">	<span class="type">int</span> ngroups; <span class="comment">// 线程组数⽬</span></span><br><span class="line">	ThreadGroup groups[]; <span class="comment">// 线程组数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 私有构造函数</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">ThreadGroup</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.name = <span class="string">&quot;system&quot;</span>;</span><br><span class="line">	<span class="built_in">this</span>.maxPriority = Thread.MAX_PRIORITY;</span><br><span class="line">	<span class="built_in">this</span>.parent = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 默认是以当前ThreadGroup传⼊作为parent ThreadGroup</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadGroup</span><span class="params">(String name)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>(Thread.currentThread().getThreadGroup(), name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadGroup</span><span class="params">(ThreadGroup parent, String name)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>(checkParentAccess(parent), parent, name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 私有构造函数，主要的构造函数</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">ThreadGroup</span><span class="params">(Void unused, ThreadGroup parent, String name)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">	<span class="built_in">this</span>.maxPriority = parent.maxPriority;</span><br><span class="line">	<span class="built_in">this</span>.daemon = parent.daemon;</span><br><span class="line">	<span class="built_in">this</span>.vmAllowSuspension = parent.vmAllowSuspension;</span><br><span class="line">	<span class="built_in">this</span>.parent = parent;</span><br><span class="line">	parent.add(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第三个构造函数中， 检查parent ThreadGroup</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Void <span class="title function_">checkParentAccess</span><span class="params">(ThreadGroup parent)</span> &#123;</span><br><span class="line">	parent.checkAccess();</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断当前运⾏的线程是否具有修改线程组的权限</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkAccess</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//  SecurityManager  这个类，它是Java的安全管理器，它允许应⽤程序在执⾏⼀个可能不安全或敏感的操作前确定该操作是什么，以及是否是在允许执⾏该操作的安全上下⽂中执⾏它。</span></span><br><span class="line">	<span class="type">SecurityManager</span> <span class="variable">security</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">	<span class="keyword">if</span> (security ?= <span class="literal">null</span>) &#123;</span><br><span class="line">		security.checkAccess(<span class="built_in">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>优先级</p>
<ul>
<li>可以指定，范围是1~10， 默认为5。（参考值）并不是所有的操作系统都⽀持10级优先级的划分</li>
<li>线程的调度策略采⽤抢占式， 优先级高不一定先执行</li>
<li>如果某个线程优先级⼤于线程所在线程组的最⼤优先级，那么该线程的优先级将会失效，取⽽代之的是线程组的最⼤优先级。</li>
<li>设置 &amp; 查看 ：setPriority(i) &amp; getPriority()</li>
</ul>
</li>
<li><p>守护线程   Daemon</p>
<ul>
<li>⼀个线程默认是非守护线程</li>
<li>如果某线程是守护线程，那如果所有的⾮守护线程结束，这个守护线程也会⾃动结束。</li>
<li>通过Thread类的setDaemon(boolean on)来设置。</li>
</ul>
</li>
</ul>
<h1 id="线程状态及其转换"><a href="#线程状态及其转换" class="headerlink" title="线程状态及其转换"></a>线程状态及其转换</h1><p>注：可以先看完下一节，再来看本节</p>
<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread.State 源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">	NEW,       <span class="comment">//线程此时尚未启动，还没调⽤Thread实例的start()⽅法。</span></span><br><span class="line">	RUNNABLE,  <span class="comment">//该状态的线程在Java虚拟机中运⾏，也有可能在等待其他系统资源（⽐如I/O）</span></span><br><span class="line">	BLOCKED,   <span class="comment">//该线程正等待锁的释放以进⼊同步区。</span></span><br><span class="line">	WAITING,   <span class="comment">//等待状态的线程变成RUNNABLE状态需要其他线程唤醒。</span></span><br><span class="line">	TIMED_WAITING, <span class="comment">//超时等待状态。线程等待⼀个具体的时间，时间到后会被自动唤醒。</span></span><br><span class="line">	TERMINATED; <span class="comment">//此时线程已执⾏完毕</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>start() 问题<ol>
<li>反复调⽤同⼀个线程的start()⽅法是否可⾏？ NO,IllegalThreadStateException异常。</li>
<li>假如⼀个线程执⾏完毕（此时处于TERMINATED状态），再次调⽤这个线程的start()⽅法是否可⾏？ NO</li>
</ol>
</li>
<li>Java线程的RUNNABLE状态其实是包括了传统操作系统线程的ready和running两个状态的。</li>
<li>调⽤如下3个⽅法会使线程进⼊<strong>等待状态</strong><ul>
<li>Object.wait()：使当前线程处于等待状态直到另⼀个线程唤醒它；</li>
<li>Thread.join()：等待线程执⾏完毕，底层调⽤的是Object实例的wait⽅法；</li>
<li>LockSupport.park()：除⾮获得调⽤许可，否则禁⽤当前线程进⾏线程调度。</li>
</ul>
</li>
<li>调⽤如下⽅法会使线程进⼊<strong>超时等待状态</strong><ul>
<li>Thread.sleep(long millis)：使当前线程睡眠指定时间</li>
<li>Object.wait(long timeout)：线程休眠指定时间，等待期间可以通过notify()&#x2F;notifyAll()唤醒</li>
<li>Thread.join(long millis)：等待当前线程最多执⾏millis毫秒，如果millis为0，则会⼀直执⾏</li>
<li>LockSupport.parkNanos(long nanos)： 除⾮获得调⽤许可，否则禁⽤当前线程进⾏线程调度指定时间</li>
<li>LockSupport.parkUntil(long deadline)：同上，也是禁⽌线程进⾏调度指定时间</li>
</ul>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/09/o5QuNZSsFk2gcdY.png" alt="状态转换图"></p>
<h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><ul>
<li>总有⼀个main线程</li>
<li>启动线程后执⾏run⽅法还是需要消耗⼀定时间的。</li>
</ul>
<ol>
<li><p>BLOCKED与RUNNABLE状态的转换</p>
<ul>
<li>处于BLOCKED状态的线程是因为在等待锁的释放。假如这⾥有两个线程a和b，a线程提前获得了锁并且暂未释放锁，此时b就处于BLOCKED状态。</li>
</ul>
</li>
<li><p>WAITING状态与RUNNABLE状态的转换</p>
<ul>
<li><p>主要有两个方法<strong>Object.wait()和Thread.join()</strong></p>
</li>
<li><p>Object.wait()</p>
<blockquote>
<ol>
<li><p>调⽤wait()⽅法前线程必须持有对象的锁。</p>
</li>
<li><p>线程调⽤wait()⽅法时，<strong>会释放当前的锁</strong>，直到有其他线程调⽤notify()&#x2F;notifyAll()⽅法唤醒等待锁的线程。</p>
</li>
<li><p>调⽤notify()⽅法只会唤醒单个等待锁的线程，如有多个线程都在等待这个锁的话不⼀定会唤醒到之前调⽤wait()⽅法的线程</p>
</li>
<li><p>调⽤notifyAll()⽅法唤醒所有等待锁的线程</p>
</li>
</ol>
</blockquote>
</li>
<li><p>Thread.join()</p>
<blockquote>
<p>调⽤join()⽅法<strong>不会释放锁</strong>，会⼀直等待当前线程执⾏完毕（转换为TERMINATED状态）</p>
</blockquote>
</li>
</ul>
</li>
<li><p>TIMED_WAITING与RUNNABLE状态转换</p>
<ul>
<li><p>Thread.sleep(long)</p>
<blockquote>
<p>并<strong>不会释放锁</strong></p>
</blockquote>
</li>
<li><p>Object.wait(long)</p>
<blockquote>
<p>可以被唤醒，也可等到时间自动唤醒</p>
</blockquote>
</li>
<li><p>Thread.join(long)</p>
<blockquote>
<p>使当前线程执⾏指定时间，并且使线程进⼊TIMED_WAITING状态</p>
</blockquote>
</li>
</ul>
</li>
<li><p>中断</p>
<ul>
<li><p>通过中断操作并不能直接终止一个线程，⽽是通知需要被中断的线程自行处理</p>
</li>
<li><p>当其他线程通知需要被中断的线程后，线程中断的状态被设置为true</p>
</li>
<li><p>静态方法</p>
<ul>
<li><p>Thread.interrupt()：中断线程。这⾥的中断线程并不会⽴即停⽌线程，⽽是设置线程的中断状态为true（默认是flase）</p>
<ol>
<li><p><strong>调用线程的interrupt()实例方法，线程的中断标志会被置为true</strong></p>
</li>
<li><p><strong>当线程处于阻塞状态时，调用线程的interrupt()实例方法，线程内部会触发InterruptedException异常，并且会清除线程内部的中断标志（即将中断标志置为false）</strong></p>
</li>
</ol>
</li>
<li><p>Thread.interrupted()：测试当前线程是否被中断。线程的中断状态受这个⽅法的影响，意思是<strong>调用⼀次</strong>使线程中断状态设置为true，<strong>连续调用两次</strong>会使得这个线程的中断状态重新转为false</p>
</li>
<li><p>Thread.isInterrupted()：<strong>查看</strong>当前线程是否被中断。</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="线程之间的通信"><a href="#线程之间的通信" class="headerlink" title="线程之间的通信"></a>线程之间的通信</h1><ul>
<li>⼀般来讲，线程内部有⾃⼰私有的线程上下文，互不干扰</li>
</ul>
<ol>
<li><strong>锁与同步</strong></li>
</ol>
<p>锁：在Java中，锁的概念都是基于对象的，所以我们⼜经常称它为对象锁。</p>
<p>同步：线程同步是线程之间按照⼀定的顺序执⾏</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (lock) &#123; <span class="comment">//⽤  synchronized  关键字加上了同⼀个对象锁  lock</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Thread B &quot;</span> + i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>等待\通知机制—不用重复尝试获得锁</strong></li>
</ol>
<p>Java多线程的等待&#x2F;通知机制是基于  Object  类的  wait() 方法和notify(), notifyAll()  ⽅法来实现的</p>
<p>注意：是同⼀个对象锁</p>
<blockquote>
<p>​		当在一个对象实例上调用wait()方法后，当前线程就会在这个对象上等待。这是什么意思？比如在线程A中，调用了obj.wait()方法，那么线程A就会停止继续执行，转为等待状态。等待到什么时候结束呢？线程A会一直等到其他线程调用obj.notify()方法为止，这时，obj对象成为了多个线程之间的有效通信手段。</p>
</blockquote>
<ol start="3">
<li><strong>信号量</strong></li>
</ol>
<p>基于  volatile  关键字实现的信号量通信</p>
<ul>
<li>volitile关键字能够保证内存的可见性，如果⽤volitile关键字声明了⼀个变量，在⼀个线程里面改变了这个变量的值，那其它线程是立刻可见更改后的值</li>
<li>volatile  变量需要进行原子操作。  如signal++  并不是⼀个原子操作（汇编有三条语句），所以我们需要使用synchronized  给它“上锁”。</li>
<li>应用场景：多个线程（超过2个）需要相互合作</li>
</ul>
<ol start="4">
<li><strong>管道</strong></li>
</ol>
<p>JDK提供了  PipedWriter  、  PipedReader  、 PipedOutputStream  、  PipedInputStream</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pipe</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReaderThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">		<span class="keyword">private</span> PipedReader reader;</span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">ReaderThread</span><span class="params">(PipedReader reader)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.reader = reader;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;this is reader&quot;</span>);</span><br><span class="line">		<span class="type">int</span> <span class="variable">receive</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> ((receive = reader.read()) ?= -<span class="number">1</span>) &#123;</span><br><span class="line">				System.out.print((<span class="type">char</span>)receive);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WriterThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">		<span class="keyword">private</span> PipedWriter writer;</span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">WriterThread</span><span class="params">(PipedWriter writer)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.writer = writer;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;this is writer&quot;</span>);</span><br><span class="line">		<span class="type">int</span> <span class="variable">receive</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			writer.write(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				writer.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">	<span class="type">PipedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PipedWriter</span>();</span><br><span class="line">	<span class="type">PipedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PipedReader</span>();</span><br><span class="line">	writer.connect(reader); <span class="comment">// 这⾥注意⼀定要连接，才能通信</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ReaderThread</span>(reader)).start();</span><br><span class="line">	Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">WriterThread</span>(writer)).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="built_in">this</span> is reader</span><br><span class="line"><span class="built_in">this</span> is writer</span><br><span class="line">test</span><br></pre></td></tr></table></figure>

<p>流程：</p>
<blockquote>
<ol>
<li>线程ReaderThread开始执⾏，</li>
<li>线程ReaderThread使⽤管道reader.read()进⼊”阻塞“，</li>
<li>线程WriterThread开始执⾏，</li>
<li>线程WriterThread⽤writer.write(“test”)往管道写⼊字符串，</li>
<li>线程WriterThread使⽤writer.close()结束管道写⼊，并执⾏完毕，</li>
<li>线程ReaderThread接受到管道输出的字符串并打印，</li>
<li>线程ReaderThread执⾏完毕。</li>
</ol>
</blockquote>
<h1 id="内存模型基础"><a href="#内存模型基础" class="headerlink" title="内存模型基础"></a>内存模型基础</h1><p>在Java中，使⽤的是<a target="_blank" rel="noopener" href="http://t.csdn.cn/IFpsq">共享内存并发模型</a></p>
<ul>
<li><p>内存模型的抽象结构</p>
<ul>
<li><p>运行时内存划分</p>
</li>
<li><p>通信由JMM控制（定义了线程和主内存之间的抽象关系）</p>
<ul>
<li>线程对共享变量的所有操作都必须在⾃⼰的本地内存中进行，不能直接从主内存中读取</li>
<li>JMM通过控制主内存与每个线程的本地内存之间的交互，来提供内存可⻅性保证</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/07/09/l37JpxCsfb6w2Xz.png" alt="运行时内存划分"><img src="https://s2.loli.net/2022/07/09/GtbUDB7WcNO4I96.png" alt="JMM" style="zoom:80%;" /></p>
<h1 id="重排序-amp-happens-before"><a href="#重排序-amp-happens-before" class="headerlink" title="重排序 &amp; happens-before"></a>重排序 &amp; happens-before</h1><h2 id="重排序："><a href="#重排序：" class="headerlink" title="重排序："></a>重排序：</h2><ul>
<li>定义：计算机在执⾏程序时，为了提⾼性能，编译器和处理器常常会对指令做重排</li>
<li>分类：<ul>
<li>编译器优化重排<ul>
<li>编译器在不改变单线程程序语义的前提下，可以重新安排语句的执⾏顺序</li>
</ul>
</li>
<li>指令并⾏重排<ul>
<li>现代处理器采⽤了指令级并⾏技术来将多条指令重叠执⾏（前提：不存在数据依<br>  赖性）</li>
</ul>
</li>
<li>内存系统重排<ul>
<li>因为三级缓存的存在，导致内存与缓存的数据同步存在时间差</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="顺序一致性模型"><a href="#顺序一致性模型" class="headerlink" title="顺序一致性模型"></a>顺序一致性模型</h2><ul>
<li><p>数据竞争：在⼀个线程中写⼀个变量，在另⼀个线程读同⼀个变量，并且写和读没有通过同步来排序。</p>
</li>
<li><p>Java内存模型（JMM）对于正确同步多线程程序的内存⼀致性做了以下保证</p>
<blockquote>
<p>如果程序是正确同步的，程序的执⾏将具有顺序⼀致性。</p>
<p>即程序的执⾏结果和该程序在顺序⼀致性模型中执⾏的结果相同。</p>
<p>这⾥的同步包括了使⽤  volatile  、  final  、  synchronized  等关键字来实现多线程下的同步</p>
</blockquote>
</li>
<li><p>顺序⼀致性内存模型是⼀个理想化的理论参考模型</p>
<ul>
<li>⼀个线程中的所有操作必须按照程序的顺序（即Java代码的顺序）来执⾏</li>
<li>每个操作必须是原⼦性的，且⽴刻对所有线程可⻅</li>
<li>实际上，JMM没有这样的保证（见上一条）</li>
</ul>
</li>
<li><p>JMM的顺序⼀致性效果</p>
<ul>
<li>同步程序中<ul>
<li>但是JMM中，临界区内（同步块或同步⽅法中）的代码可以发⽣重排序</li>
<li>因为锁的特性，线程B⽆法观察到线程A在临界区的重排序。</li>
</ul>
</li>
<li>非同步程序中<ul>
<li>JMM<strong>只提供最小安全性</strong>：线程读取到的值，要么是之前某个线程写⼊的值，要么是默认值，不会⽆中⽣有</li>
<li>为了实现这个安全性，JVM在堆上分配对象时，⾸先会对内存空间清零，然后才会在上⾯分配对象（这两个操作是同步的）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><ul>
<li><p>JMM提供了happens-before规则（JSR-133规范），满⾜了程序员的需求——<strong>简单易懂，并且提供了足够强的内存可见性保证。</strong></p>
<ul>
<li><p>happens-before关系本质上和as-if-serial语义是<a target="_blank" rel="noopener" href="http://t.csdn.cn/mHfOn">⼀回事</a></p>
</li>
<li><p>如果操作A happens-before操作B，那么操作A在内存上所做的操作对操作B都是可见的，不管它们在不在⼀个线程</p>
</li>
</ul>
</li>
<li><p>有以下天然的happens-before关系</p>
<ul>
<li>程序顺序规则：⼀个线程中的每⼀个操作，happens-before于该线程中的任意后续操作。</li>
<li>监视器锁规则：对⼀个锁的解锁，happens-before于随后对这个锁的加锁。</li>
<li>volatile变量规则：对⼀个volatile域的写，happens-before于任意后续对这个volatile域的读。</li>
<li>传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</li>
<li>start规则：如果线程A执⾏操作ThreadB.start()启动线程B，那么A线程的ThreadB.start（）操作happens-before于线程B中的任意操作、</li>
<li>join规则：如果线程A执⾏操作ThreadB.join（）并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li>
</ul>
</li>
</ul>
<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><ul>
<li>保证变量的<strong>内存可见性</strong>（指线程之间的可见性，当⼀个线程修改了共享变量时，另⼀个线<br>  程可以读取到这个修改后的值）</li>
<li>禁⽌volatile变量与普通变量重排序</li>
<li>一个例子</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileExample</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">		a = <span class="number">1</span>; <span class="comment">// step 1</span></span><br><span class="line">		flag = <span class="literal">true</span>; <span class="comment">// step 2</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (flag) &#123; <span class="comment">// step 3</span></span><br><span class="line">			System.out.println(a); <span class="comment">// step 4</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 在这段代码⾥，我们使⽤  volatile  关键字修饰了⼀个  boolean  类型的变量  flag  。</p>
<p>所谓内存可⻅性，指的是当⼀个线程对  volatile  修饰的变量进⾏写操作（⽐如step 2）时，JMM会⽴即把该线程对应的本地内存中的共享变量的值刷新到主内存；</p>
<p>当⼀个线程对  volatile  修饰的变量进⾏读操作（⽐如step 3）时，JMM会把⽴即该线程对应的本地内存置为⽆效，从主内存中读取共享变量的值。</p>
</blockquote>
<ul>
<li><p>用途</p>
<ul>
<li><p>在保证内存可⻅性这⼀点上，volatile有着与锁相同的内存语义，所以可以作为⼀个“轻量级”的锁来使⽤。</p>
</li>
<li><p>例如在单例模式中</p>
</li>
<li><p>&#96;&#96;&#96;java<br>  public class Singleton {<br>  private static Singleton instance; &#x2F;&#x2F; 不使⽤volatile关键字<br>  &#x2F;&#x2F; 双重锁检验<br>  public static Singleton getInstance() {<br>      if (instance &#x3D;&#x3D; null) { &#x2F;&#x2F; 第7⾏<br>          synchronized (Singleton.class) {<br>              if (instance &#x3D;&#x3D; null) {<br>                  instance &#x3D; new Singleton(); &#x2F;&#x2F; 第10⾏<br>              }<br>          }<br>      }<br>      return instance;<br>  }<br>  }</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># synchronized &amp; 锁</span><br><span class="line"></span><br><span class="line">## Synchronized关键字</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">// 关键字在实例⽅法上，锁为当前实例</span><br><span class="line">public synchronized void instanceLock() &#123;</span><br><span class="line">	// code</span><br><span class="line">&#125;</span><br><span class="line">// 关键字在静态⽅法上，锁为当前Class对象</span><br><span class="line">public static synchronized void classLock() &#123;</span><br><span class="line">	// code</span><br><span class="line">&#125;</span><br><span class="line">// 关键字在代码块上，锁为括号⾥⾯的对象</span><br><span class="line">public void blockLock() &#123;</span><br><span class="line">	Object o = new Object();</span><br><span class="line">	synchronized (o) &#123;</span><br><span class="line">	// code</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<blockquote>
<p>总结：</p>
<ol>
<li>修饰实例方法，作用于当前实例，进入同步代码前需要先获取实例的锁</li>
<li>修饰静态方法，作用于类的Class对象，进入修饰的静态方法前需要先获取类的Class对象的锁</li>
<li>修饰代码块，需要指定加锁对象(记做lockobj)，在进入同步代码块前需要先获取lockobj的锁</li>
</ol>
</blockquote>
<blockquote>
<p> Java类只有⼀个Class对象（可以有多个实例对象，多个实例共享这个Class对象），⽽Class对象也是特殊的Java对象。</p>
</blockquote>
<blockquote>
<p>所谓“临界区”，指的是某⼀块代码区域，它同⼀时刻只能由⼀个线程执⾏。</p>
</blockquote>
<blockquote>
<p>synchronized可以把任意一个非NULL的对象当作锁。</p>
<ol>
<li>作用于方法时，锁住的是对象的实例(this)；</li>
<li>当作用于静态方法时，锁住的是Class实例，又因为Class的相关数据存储在永久带PermGen（jdk1.8则是metaspace），永久带是全局共享的，因此静态方法锁相当于类的一个全局锁，会锁所有调用该方法的线程；</li>
<li>synchronized作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。</li>
</ol>
</blockquote>
<h2 id="锁–状态"><a href="#锁–状态" class="headerlink" title="锁–状态"></a>锁–状态</h2><p>⼀个对象其实有四种锁状态，它们级别由低到⾼依次是：</p>
<ol>
<li>⽆锁状态 — 略</li>
<li>偏向锁状态</li>
<li>轻量级锁状态</li>
<li>重量级锁状态</li>
</ol>
<p>注：可能会发生锁降级，但条件苛刻，不做细讲</p>
<h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h3><ul>
<li><p>每个Java对象都有对象头。</p>
<ul>
<li><p>如果是非数组类型，则⽤2个字宽来存储对象头</p>
</li>
<li><p>如果是数组，则会⽤3个字宽来存储对象头。</p>
</li>
</ul>
</li>
<li><p>在32位处理器中，⼀个字宽是32位；在64位虚拟机中，⼀个字宽是64位。</p>
</li>
<li><p>对象头内容：其中<strong>锁的状态判断主要是读取Mark Word的内容（表二）</strong></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>对象头内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Mark Word</td>
<td>存储对象的hashCode或锁信息等</td>
</tr>
<tr>
<td>Class Metadata Address</td>
<td>存储到对象类型数据的指针</td>
</tr>
<tr>
<td>Array length</td>
<td>数组的长度（如果是数组）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>锁状态</th>
<th>61bit</th>
<th>1bit–偏向锁判断位</th>
<th>2bit–锁标志位</th>
</tr>
</thead>
<tbody><tr>
<td>无锁</td>
<td></td>
<td>0</td>
<td>01</td>
</tr>
<tr>
<td>偏向锁</td>
<td>线程ID</td>
<td>1</td>
<td>01</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>指向栈中锁记录的指针</td>
<td>×</td>
<td>00</td>
</tr>
<tr>
<td>重量级锁</td>
<td>指向互斥量（重量级锁）的指针</td>
<td>×</td>
<td>10</td>
</tr>
<tr>
<td>GC标记</td>
<td></td>
<td>×</td>
<td>11</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>锁状态</th>
<th>上锁条件</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>锁总是由同⼀线程多次获得</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>多个线程在不同时段获取同⼀把锁，即不存在锁竞争的情况</td>
</tr>
<tr>
<td>重量级锁</td>
<td>多个线程同时请求某个对象锁时</td>
</tr>
</tbody></table>
<h3 id="锁状态升级流程"><a href="#锁状态升级流程" class="headerlink" title="锁状态升级流程"></a>锁状态升级流程</h3><blockquote>
<p> 第⼀步，检查MarkWord⾥⾯是不是放的⾃⼰的ThreadId ,如果是，表示当前线程是处于 “偏向锁”。</p>
<p>第⼆步，如果MarkWord不是⾃⼰的ThreadId，锁升级，这时候，⽤CAS来执⾏切换，新的线程根据MarkWord⾥⾯现有的ThreadId，通知之前线程暂停，之前线程将Markword的内容置为空。</p>
<p>第三步，两个线程都把锁对象的HashCode复制到⾃⼰新建的⽤于存储锁的记录空间，接着开始通过CAS操作， 把锁对象的MarKword的内容修改为⾃⼰新建的记录空间的地址的⽅式竞争MarkWord。</p>
<p>第四步，第三步中成功执⾏CAS的获得资源，失败的则进⼊⾃旋 。</p>
<p>第五步，⾃旋的线程在⾃旋过程中，成功获得资源(即之前获的资源的线程执⾏完成并释放了共享资源)，则整个状态依然处于 轻量级锁的状态，如果⾃旋失败 。</p>
<p>第六步，进⼊重量级锁的状态，这个时候，⾃旋的线程进⾏阻塞，等待之前线程执⾏完成并唤醒⾃⼰。</p>
</blockquote>
<h3 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h3><table>
<thead>
<tr>
<th>类型</th>
<th>概念</th>
</tr>
</thead>
<tbody><tr>
<td>悲观锁</td>
<td>总是认为每次访问共享资源时会发⽣冲突，所以必须对每次数据操作加上锁，以保证临界区的程序同⼀时间只能有⼀个线程在执行<br><strong>写多读少操作</strong></td>
</tr>
<tr>
<td>乐观锁</td>
<td>总是假设对共享资源的访问没有冲突，线程可以不停地执⾏，⽆需加锁也⽆需等待<br>发生线程冲突时，使用⼀种称为CAS的技术来保证线程执⾏的安全性<br><strong>读多写少操作</strong></td>
</tr>
<tr>
<td>…</td>
<td>公平\非公平锁  可重入锁  独享锁\共享锁  互斥锁\读写锁</td>
</tr>
</tbody></table>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><strong>死锁产生条件（缺一不可）</strong></p>
<ol>
<li>互斥条件：一个资源每次只能被一个线程使用</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获取资源不释放</li>
<li>不剥夺条件：进程已获得资源，在未使用完之前，不能强行剥夺</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源</li>
</ol>
<p><strong>死锁的预防</strong></p>
<ol>
<li>资源一次性分配：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）</li>
<li>只要有一个资源得不到分配，也不给这个进程分配其他的资源：（破坏请保持条件）</li>
<li>可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）</li>
<li>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件</li>
</ol>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><ul>
<li>创建&#x2F;销毁线程需要消耗系统资源，线程池可以<strong>复用</strong>已创建的线程</li>
<li>控制并发的<strong>数量</strong></li>
<li>可以对线程做统⼀管理</li>
</ul>
<h2 id="ThreadPoolExecutor基础-amp-原理"><a href="#ThreadPoolExecutor基础-amp-原理" class="headerlink" title="ThreadPoolExecutor基础&amp;原理"></a>ThreadPoolExecutor基础&amp;原理</h2><p>线程池顶层接口是  Executor 接口，  ThreadPoolExecutor  是这个接口的实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 五个参数的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, //核心线程数最⼤值</span></span><br><span class="line"><span class="params">						<span class="type">int</span> maximumPoolSize, //线程总数最⼤值</span></span><br><span class="line"><span class="params">						<span class="type">long</span> keepAliveTime, //⾮核⼼线程闲置超时时⻓</span></span><br><span class="line"><span class="params">						TimeUnit unit,  	//keepAliveTime的单位</span></span><br><span class="line"><span class="params">						BlockingQueue&lt;Runnable&gt; workQueue)</span> <span class="comment">//阻塞队列</span></span><br><span class="line"><span class="comment">// 六个参数的构造函数-1</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">						<span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">						<span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">						TimeUnit unit,</span></span><br><span class="line"><span class="params">						BlockingQueue&lt;Runnable&gt; workQueue, </span></span><br><span class="line"><span class="params">						ThreadFactory threadFactory)</span><span class="comment">//创建线程的⼯⼚&#123;⽤于批量创建线程&#125;</span></span><br><span class="line"><span class="comment">// 六个参数的构造函数-2</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">						<span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">						<span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">						TimeUnit unit,</span></span><br><span class="line"><span class="params">						BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">						RejectedExecutionHandler handler)</span><span class="comment">//拒绝处理策略</span></span><br><span class="line"><span class="comment">// 七个参数的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">						<span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">						<span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">						TimeUnit unit,</span></span><br><span class="line"><span class="params">						BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">						ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">						RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure>

<p>其中有五个必须参数：</p>
<ul>
<li><p>int corePoolSize：该线程池中核心线程数最⼤值</p>
<blockquote>
<p>核⼼线程：线程池中有两类线程，核心线程和⾮核心线程。核⼼线程默认情况下会⼀直存在于线程池中，即使这个核心线程什么都不⼲（铁饭碗），⽽非核心线程如果⻓时间的闲置，就会被销毁（临时⼯）</p>
</blockquote>
</li>
<li><p>int maximumPoolSize：该线程池中线程总数最⼤值</p>
<blockquote>
<p>等于核心线程数量 + 非核心线程数量</p>
</blockquote>
</li>
<li><p>long keepAliveTime：非核心线程闲置超时时⻓</p>
<blockquote>
<p>如果设置allowCoreThreadTimeOut(true)，则会也作⽤于核⼼线程</p>
</blockquote>
</li>
<li><p>TimeUnit unit：keepAliveTime的单位</p>
<blockquote>
<p>枚举类型: NANOSECONDS(微毫秒)   MICROSECONDS(微秒) MILLISECONDS(毫秒) SECONDS  MINUTES  HOURS  DAYS</p>
</blockquote>
</li>
<li><p>BlockingQueue workQueue：阻塞队列，维护着等待执⾏的Runnable任务对象。</p>
<ul>
<li><strong>LinkedBlockingQueue</strong> 链式阻塞队列，底层数据结构是链表，有默认也可指定</li>
<li><strong>ArrayBlockingQueue</strong> 数组阻塞队列，底层数据结构是数组，大小要指定</li>
<li><strong>SynchronousQueue</strong> 同步队列，内部容量为0，每个put操作必须等待⼀个take操作</li>
<li><strong>DelayQueue</strong> 延迟队列，任务只有当其指定的延迟时间到了才能够从队列中获取</li>
</ul>
</li>
</ul>
<p>以及两个非必须参数：</p>
<ul>
<li><p><strong>ThreadFactory threadFactory</strong>：⽤于批量创建线程，统⼀在创建线程时设置⼀些参数</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">	<span class="comment">// 省略属性</span></span><br><span class="line">	<span class="comment">// 构造函数</span></span><br><span class="line">	DefaultThreadFactory() &#123;</span><br><span class="line">		<span class="type">SecurityManager</span> <span class="variable">s</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">		group = (s != <span class="literal">null</span>) ? s.getThreadGroup() :</span><br><span class="line">		Thread.currentThread().getThreadGroup();</span><br><span class="line">		namePrefix = <span class="string">&quot;pool-&quot;</span> +</span><br><span class="line">		poolNumber.getAndIncrement() +</span><br><span class="line">		<span class="string">&quot;-thread-&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>RejectedExecutionHandler handler</strong>: 线程数量⼤于最⼤线程数就会采⽤拒绝处理策略(四种)</p>
<ol>
<li><strong>ThreadPoolExecutor.AbortPolicy</strong>：默认的，丢弃任务并抛出RejectedExecutionException异常</li>
<li><strong>ThreadPoolExecutor.DiscardPolicy</strong>：丢弃新来的任务，但是不抛出异常</li>
<li><strong>ThreadPoolExecutor.DiscardOldestPolic</strong>y：丢弃队列头部（最旧的）的任务，然后重新尝试执行程序（如果再次失败，重复此过程）</li>
<li><strong>ThreadPoolExecutor.CallerRunsPolicy</strong>：由调⽤线程处理该任务</li>
</ol>
</li>
</ul>
<h2 id="ThreadPoolExecutor状态"><a href="#ThreadPoolExecutor状态" class="headerlink" title="ThreadPoolExecutor状态"></a>ThreadPoolExecutor状态</h2><p>​		线程池本身有⼀个调度线程，这个线程就是⽤于管理布控整个线程池⾥的各种任务和事务，例如创建线程、销毁线程、任务队列管理、线程队列管理等等</p>
<p>​		故线程池也有⾃⼰的状态。  ThreadPoolExecutor  类中定义了⼀个  volatile int  变量runState来表示线程池的状态 ，分别为RUNNING、SHURDOWN、STOP、TIDYING 、TERMINATED</p>
<ul>
<li><p>线程池创建后处于RUNNING状态</p>
</li>
<li><p>调⽤<code>shutdown()</code>⽅法后处于SHUTDOWN状态，线程池不能接受新的任务，清除⼀些空闲worker,会等待阻塞队列的任务完成</p>
</li>
<li><p>调⽤<code>shutdownNow()</code>⽅法后处于STOP状态，线程池不能接受新的任务，中断所有线程，阻塞队列中没有被执⾏的任务全部丢弃。此时，poolsize&#x3D;0,阻塞队列的size也为0</p>
</li>
<li><p>当所有的任务已终⽌，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。接着会执行<code>terminated()</code>函数</p>
<blockquote>
<p>控制状态的属性叫ctl，它是⼀个AtomicInteger类型的变量</p>
</blockquote>
</li>
<li><p>线程池处在TIDYING状态时，执⾏完terminated()⽅法之后，就会由 TIDYING-&gt; TERMINATED， 线程池被设置为TERMINATED状态</p>
</li>
</ul>
<h2 id="任务处理流程"><a href="#任务处理流程" class="headerlink" title="任务处理流程"></a>任务处理流程</h2><ol>
<li>线程总数量 &lt; corePoolSize，⽆论线程是否空闲，都会新建⼀个核⼼线程执⾏任务（让核⼼线程数量快速达到corePoolSize，在核⼼线程数量 &lt; corePoolSize时）。<strong>注意，这⼀步需要获得全局锁</strong>。</li>
<li>线程总数量 &gt;&#x3D; corePoolSize时，新来的线程任务会进⼊任务队列中等待，然后空闲的核⼼线程会依次去缓存队列中取任务来执⾏（体现了<strong>线程复用</strong>）。</li>
<li>当缓存队列满了，说明这个时候任务已经多到爆棚，需要⼀些“临时⼯”来执⾏这些任务了。于是会创建⾮核⼼线程去执⾏这个任务。<strong>注意，这⼀步需要获得全局锁</strong>。</li>
<li>缓存队列满了， 且总线程数达到了maximumPoolSize，则会采取上⾯提到的拒绝策略进⾏处理。</li>
</ol>
<h2 id="常用的线程池（四种）"><a href="#常用的线程池（四种）" class="headerlink" title="常用的线程池（四种）"></a>常用的线程池（四种）</h2><p> Executors  类中提供的⼏个<strong>静态方法</strong>来创建线程池</p>
<ol>
<li><p><strong>newCachedThreadPool</strong></p>
<ul>
<li><pre><code class="java">  public static ExecutorService newCachedThreadPool() &#123;
      return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                    60L, TimeUnit.SECONDS,
                                    new SynchronousQueue&lt;Runnable&gt;());
  &#125;
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    - 运行流程：</span><br><span class="line"></span><br><span class="line">        1. 提交任务进线程池。</span><br><span class="line"></span><br><span class="line">        2. 因为corePoolSize为0的关系，不创建核⼼线程，线程池最⼤为Integer.MAX_VALUE。</span><br><span class="line">        3. 尝试将任务添加到SynchronousQueue队列。</span><br><span class="line">        4. 如果SynchronousQueue⼊列成功，等待被当前运⾏的线程空闲后拉取执⾏。如果当前没有空闲线程，那么就创建⼀个⾮核⼼线程，然后从SynchronousQueue拉取任务并在当前线程执⾏。</span><br><span class="line">        5. 如果SynchronousQueue已有任务在等待，⼊列操作将会阻塞。</span><br><span class="line"></span><br><span class="line">    - 作用：</span><br><span class="line"></span><br><span class="line">        - 当需要执⾏很多**短时间的任务**时，CacheThreadPool的线程复⽤率⽐较⾼， 会显著的提⾼性能。⽽且线程60s后会回收，意味着即使没有任务进来，CacheThreadPool并**不会占用很多资源**</span><br><span class="line"></span><br><span class="line">2. **newFixedThreadPool**</span><br><span class="line"></span><br><span class="line">    - ```java</span><br><span class="line">        public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">        		return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">        									  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">        									  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>运行流程：</p>
<ol>
<li>核⼼线程数量和总线程数量相等，都是传⼊的参数nThreads，所以只能创建核⼼线程，不能创建⾮核⼼线程</li>
<li>因为LinkedBlockingQueue的默认⼤⼩是Integer.MAX_VALUE，故如果核⼼线程空闲，则交给核⼼线程处理；如果核⼼线程不空闲，则⼊列等待，直到核⼼线程空闲</li>
</ol>
</li>
<li><p>与CachedThreadPool的区别</p>
<ul>
<li>FixedThreadPool只会创建核⼼线程，但CachedThreadPool只会创建非核心线程</li>
<li>FixedThreadPool线程会⼀直阻塞在LinkedBlockingQueue.take() ，线程不会被回收，但CachedThreadPool会在60S后回收</li>
<li>没有任务的情况下，FixedThreadPool占⽤资源更多</li>
<li>都⼏乎不会触发拒绝策略，但是原理不同。FixedThreadPool是因为阻塞队列可以很⼤，而CachedThreadPool是因为线程池很⼤</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>newSingleThreadExecutor</strong></p>
<ul>
<li><p>&#96;&#96;&#96;java<br>  public static ExecutorService newSingleThreadExecutor() {<br>      return new FinalizableDelegatedExecutorService<br>              (new ThreadPoolExecutor(1, 1,<br>               0L, TimeUnit.MILLISECONDS,<br>               new LinkedBlockingQueue<Runnable>()));<br>  }</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    - 运行流程：</span><br><span class="line"></span><br><span class="line">        1. 有且仅有⼀个核⼼线程</span><br><span class="line"></span><br><span class="line">        2. 使用了LinkedBlockingQueue（容量很⼤），所以，不会创建非核心线程</span><br><span class="line"></span><br><span class="line">        3. 如果这个唯⼀的线程不空闲，那么新来的任务会存储在任务队列⾥等待执⾏</span><br><span class="line"></span><br><span class="line">4. **newScheduledThreadPool**</span><br><span class="line"></span><br><span class="line">    - ```java</span><br><span class="line">        public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</span><br><span class="line">            return new ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //ScheduledThreadPoolExecutor():</span><br><span class="line">        public ScheduledThreadPoolExecutor(int corePoolSize) &#123;</span><br><span class="line">            super(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">                  DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">                  new DelayedWorkQueue());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行流程</p>
<ul>
<li>创建⼀个定⻓线程池，⽀持定时及周期性任务执⾏</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><p><strong>由来：</strong></p>
<p>​		我们假设⼀种场景，⽣产者⼀直⽣产资源，消费者⼀直消费资源，资源存储在⼀个缓冲池中，⽣产者将⽣产的资源存进缓冲池中，消费者从缓冲池中拿到资源进⾏消费，这就是<strong>生产者-消费者模式</strong></p>
<p><strong>实现&amp;问题：</strong></p>
<p>​		因为需要让<strong>多个线程操作共享变量</strong>（即资源），所以很容易引发线程安全问题，造成<strong>重复消费和死锁</strong>，尤其是⽣产者和消费者存在多个的情况。另外，当缓冲池空了，我们需要阻塞消费者，唤醒⽣产者；当缓冲池满了，我们需要阻塞⽣产者，唤醒消费者，这些个<strong>等待-唤醒逻辑都需要自己实现</strong></p>
<p><strong>解决：</strong></p>
<p>​		BlockingQueue是Java util.concurrent包下重要的数据结构，区别于普通的队列，BlockingQueue提供了<strong>线程安全的队列访问⽅式</strong>，并发包下很多⾼级同步类的实现都是基于BlockingQueue实现的</p>
<p>​		即：BlockingQueue就是存放元素的容器</p>
<p><strong>注意：</strong></p>
<p>​		生产者的生产数据的速度绝对不能快于消费者消费数据的速度，否则时间⼀⻓，会最终耗尽所有的可⽤堆内存空间</p>
<h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>一直阻塞</th>
<th>超时退出</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e, time, unit)</td>
</tr>
<tr>
<td>移除</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time, unit)</td>
</tr>
<tr>
<td>检查</td>
<td>element()</td>
<td>peek()</td>
<td>-</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>抛出异常：当阻塞队列满时候，再往队列⾥插⼊元素，会抛出IllegalStateException(“Queue full”)异常。当队列为空时，从队列⾥获取元素时会NoSuchElementException异常 。</li>
<li>返回特殊值：如果试图的操作⽆法⽴即执⾏，返回⼀个特殊值，通常是true &#x2F;false。</li>
<li>⼀直阻塞：如果试图的操作⽆法⽴即执⾏，则⼀直阻塞或者响应中断。</li>
<li>超时退出：如果试图的操作⽆法⽴即执⾏，该⽅法调⽤将会发⽣阻塞，直到能够执⾏，但等待时间不会超过给定值。返回⼀个特定值以告知该操作是否成功，通常是 true &#x2F; false。(unit—&gt;时间的单位)</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li><p>避免null值传入</p>
</li>
<li><p>可以访问阻塞队列中的任意元素</p>
</li>
<li><p>调⽤remove(o)可以将队列之中的特定对象移除，但并不高效，尽量避免使⽤</p>
</li>
</ul>
<h2 id="BlockingQueue的实现类"><a href="#BlockingQueue的实现类" class="headerlink" title="BlockingQueue的实现类"></a>BlockingQueue的实现类</h2><p>父类为<code>Queue&lt;E&gt;</code></p>
<ol>
<li><p>ArrayBlockingQueue</p>
<ul>
<li><p>底层数组，初始化大小后不能改变，默认非公平锁</p>
</li>
<li><p>&#96;&#96;&#96;java<br>  &#x2F;&#x2F;fair表示控制对象的内部锁是否采⽤公平锁<br>  public ArrayBlockingQueue(int capacity, boolean fair)</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. LinkedBlockingQueue</span><br><span class="line"></span><br><span class="line">    - 有界链表，有默认大小（Integer.MAX_VALUE），可以初始化大小，先进先出的原则</span><br><span class="line"></span><br><span class="line">3. DelayQueue</span><br><span class="line"></span><br><span class="line">    - 无界队列无界阻塞队列</span><br><span class="line">    - 添加进该队列的元素**必须实现**Delayed接口（指定延迟时间），而且只有在延迟期满后才能从中提取元素。</span><br><span class="line">    - 此队列不允许使用null元素</span><br><span class="line"></span><br><span class="line">4. PriorityBlockingQueue</span><br><span class="line"></span><br><span class="line">    - 是一个无界队列，它没有限制，在内存允许的情况下可以无限添加元素</span><br><span class="line">    - 它又是具有优先级的队列，是通过构造函数传入的对象来判断，传入的对象必须实现comparable接口</span><br><span class="line"></span><br><span class="line">5. SynchronousQueue</span><br><span class="line"></span><br><span class="line">    - **没有任何内部容量**，甚⾄连⼀个队列的容量都没有。并且每个put 必须等待⼀个 take</span><br><span class="line">    - 需要区别容量为1的ArrayBlockingQueue、LinkedBlockingQueue</span><br><span class="line"></span><br><span class="line">6. 一个生产者消费者模式的实例</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class Test &#123;</span><br><span class="line">    private int queueSize = 10;</span><br><span class="line">    private ArrayBlockingQueue&lt;Integer&gt; queue = new ArrayBlockingQueue&lt;Integer&gt;(queueSize);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        Test test = new Test();</span><br><span class="line">        Producer producer = test.new Producer();</span><br><span class="line">        Consumer consumer = test.new Consumer();</span><br><span class="line"></span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Consumer extends Thread&#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            consume();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void consume() &#123;</span><br><span class="line">            while(true)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    queue.take();</span><br><span class="line">                    System.out.println(&quot;从队列取走一个元素，队列剩余&quot;+queue.size()+&quot;个元素&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Producer extends Thread&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            produce();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void produce() &#123;</span><br><span class="line">            while(true)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    queue.put(1);</span><br><span class="line">                    System.out.println(&quot;向队列取中插入一个元素，队列剩余空间：&quot;+(queueSize-queue.size()));</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h1 id="锁–接口和类"><a href="#锁–接口和类" class="headerlink" title="锁–接口和类"></a>锁–接口和类</h1><p>JDK中关于并发的类大多都在<code>java.util.concurrent</code>（以下简称juc）包下。而juc.locks包是提供了一些并发锁的工具类的。</p>
<p>问题引入：</p>
<ul>
<li><p>如果临界区是只读操作，其实可以多线程一起执行，但使用synchronized的话，<strong>同一时间只能有一个线程执行</strong>。</p>
</li>
<li><p>synchronized无法知道线程有没有成功获取到锁</p>
</li>
<li><p>使用synchronized，如果临界区因为IO或者sleep方法等原因阻塞了，而当前线程又没有释放锁，就会导致<strong>所有线程等待</strong>。</p>
</li>
</ul>
<p>锁分类</p>
<pre><code>1. 重入锁
    - 支持重新进入的锁，也就是说这个锁支持一个**线程对资源重复加锁**。
    - synchronized关键字就是使用的重入锁。

2. 公平锁
    - 如果对一个锁来说，先对锁获取请求的线程一定会先被满足，后对锁获取请求的线程后被满足，那这个锁就是公平的。但是非公平锁可能会发生线程饥饿（有一些线程长时间得不到锁）的情况。
    - ReentrantLock支持非公平锁和公平锁两种

3. 排它锁
    - 这些锁在同一时刻只允许一个线程进行访问。
    - synchronized用的锁和ReentrantLock，其实都是“排它锁”。

4. 读写锁
    - 可以在同一时刻允许多个**读**线程访问
    - ReentrantReadWriteLock类作为读写锁的默认实现，内部维护了两个锁：一个读锁，一个写锁。
</code></pre>
<h2 id="抽象类AQS-x2F-AQLS-x2F-AOS"><a href="#抽象类AQS-x2F-AQLS-x2F-AOS" class="headerlink" title="抽象类AQS&#x2F;AQLS&#x2F;AOS"></a>抽象类AQS&#x2F;AQLS&#x2F;AOS</h2><p>​		<strong>AQS</strong>（AbstractQueuedSynchronizer）在JDK 1.5 发布的，提供了一个“队列同步器”的基本功能实现。而AQS里面的“资源”是用一个<code>int</code>类型的数据来表示的，有时候我们的业务需求资源的数量超出了<code>int</code>的范围。</p>
<p>​		所以在JDK 1.6 中，多了一个<strong>AQLS</strong>（AbstractQueuedLongSynchronizer）。它的代码跟AQS几乎一样，只是把资源的类型变成了<code>long</code>类型</p>
<p>​		AQS和AQLS都继承了一个类叫<strong>AOS</strong>（AbstractOwnableSynchronizer）。这个类也是在JDK 1.6 中出现的。这个类只有几行简单的代码。它是用于表示锁与持有者之间的关系（独占模式）。</p>
<h2 id="接口Condition-x2F-Lock-x2F-ReadWriteLock"><a href="#接口Condition-x2F-Lock-x2F-ReadWriteLock" class="headerlink" title="接口Condition&#x2F;Lock&#x2F;ReadWriteLock"></a>接口Condition&#x2F;Lock&#x2F;ReadWriteLock</h2><p>​		juc.locks包下共有三个接口：<code>Condition</code>、<code>Lock</code>、<code>ReadWriteLock</code>。</p>
<p>​		其中，Lock和ReadWriteLock从名字就可以看得出来，分别是锁和读写锁的意思。</p>
<p>​		Lock接口里面有一些获取锁和释放锁的方法声明，而ReadWriteLock里面只有两个方法，分别返回“读锁”和“写锁”</p>
<p>​		Lock接口中有一个方法是可以获得一个<code>Condition</code>。每个对象都可以用继承自<code>Object</code>的<strong>wait&#x2F;notify</strong>方法来实现<strong>等待&#x2F;通知机制</strong>。而Condition接口也提供了类似Object监视器的方法，通过与<strong>Lock</strong>配合来实现等待&#x2F;通知模式</p>
<h2 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h2><ol>
<li><p>ReentrantLock</p>
<ul>
<li>ReentrantLock是一个非抽象类，它是Lock接口的JDK默认实现，实现了锁的基本功能</li>
</ul>
</li>
<li><p>ReentrantReadWriteLock</p>
<ul>
<li>这个类也是一个非抽象类，它是ReadWriteLock接口的JDK默认实现。它与ReentrantLock的功能类似，同样是可重入的，支持非公平锁和公平锁。不同的是，它还支持”读写锁“。</li>
</ul>
</li>
<li><p>StampedLock</p>
<ul>
<li>核心思想：在读的时候如果发生了写，应该通过重试的方式来获取新的值，而不应该阻塞写操作。这种模式也就是典型的无锁编程思想，和CAS自旋的思想一样。</li>
</ul>
</li>
</ol>

    </div>

    
    
    
        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java%E9%AB%98%E5%B9%B6%E5%8F%91/" rel="tag"># Java高并发</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/78ed23a3/" rel="prev" title="博客建立">
      <i class="fa fa-chevron-left"></i> 博客建立
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/4592b2fd/" rel="next" title="Shell">
      Shell <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%A0%E4%B8%AA%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">几个概念</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%A5%E9%97%A8%E7%B1%BB-amp-%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.</span> <span class="nav-text">入门类&amp;接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Runnable-amp-Thread%E2%80%94%E6%B2%A1%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">2.1.</span> <span class="nav-text">Runnable&amp;Thread—没有返回值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%BC%E4%B8%8A%EF%BC%9A%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.1.1.</span> <span class="nav-text">综上：写出一个简单的线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">2.1.2.</span> <span class="nav-text">常用方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Callable-amp-Future-amp-FutureTask-%E2%80%94-%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">2.2.</span> <span class="nav-text">Callable &amp; Future &amp; FutureTask — 有返回值</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%84-amp-%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">3.</span> <span class="nav-text">线程组 &amp; 线程优先级</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%8A%E5%85%B6%E8%BD%AC%E6%8D%A2"><span class="nav-number">4.</span> <span class="nav-text">线程状态及其转换</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8A%B6%E6%80%81"><span class="nav-number">4.1.</span> <span class="nav-text">状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2"><span class="nav-number">4.2.</span> <span class="nav-text">转换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="nav-number">5.</span> <span class="nav-text">线程之间的通信</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80"><span class="nav-number">6.</span> <span class="nav-text">内存模型基础</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E6%8E%92%E5%BA%8F-amp-happens-before"><span class="nav-number">7.</span> <span class="nav-text">重排序 &amp; happens-before</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E6%8E%92%E5%BA%8F%EF%BC%9A"><span class="nav-number">7.1.</span> <span class="nav-text">重排序：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B"><span class="nav-number">7.2.</span> <span class="nav-text">顺序一致性模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#happens-before"><span class="nav-number">7.3.</span> <span class="nav-text">happens-before</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#volatile"><span class="nav-number">8.</span> <span class="nav-text">volatile</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81%E2%80%93%E7%8A%B6%E6%80%81"><span class="nav-number">8.1.</span> <span class="nav-text">锁–状态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="nav-number">8.1.1.</span> <span class="nav-text">Java对象头</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E7%8A%B6%E6%80%81%E5%8D%87%E7%BA%A7%E6%B5%81%E7%A8%8B"><span class="nav-number">8.1.2.</span> <span class="nav-text">锁状态升级流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E6%9C%BA%E5%88%B6"><span class="nav-number">8.1.3.</span> <span class="nav-text">锁机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">8.1.4.</span> <span class="nav-text">死锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">9.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadPoolExecutor%E5%9F%BA%E7%A1%80-amp-%E5%8E%9F%E7%90%86"><span class="nav-number">9.1.</span> <span class="nav-text">ThreadPoolExecutor基础&amp;原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadPoolExecutor%E7%8A%B6%E6%80%81"><span class="nav-number">9.2.</span> <span class="nav-text">ThreadPoolExecutor状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="nav-number">9.3.</span> <span class="nav-text">任务处理流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88%E5%9B%9B%E7%A7%8D%EF%BC%89"><span class="nav-number">9.4.</span> <span class="nav-text">常用的线程池（四种）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="nav-number">10.</span> <span class="nav-text">阻塞队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="nav-number">10.1.</span> <span class="nav-text">操作方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BlockingQueue%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-number">10.2.</span> <span class="nav-text">BlockingQueue的实现类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%94%81%E2%80%93%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB"><span class="nav-number">11.</span> <span class="nav-text">锁–接口和类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BBAQS-x2F-AQLS-x2F-AOS"><span class="nav-number">11.1.</span> <span class="nav-text">抽象类AQS&#x2F;AQLS&#x2F;AOS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3Condition-x2F-Lock-x2F-ReadWriteLock"><span class="nav-number">11.2.</span> <span class="nav-text">接口Condition&#x2F;Lock&#x2F;ReadWriteLock</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-number">11.3.</span> <span class="nav-text">实现类</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="modiShuriken"
      src="/images/lin.png">
  <p class="site-author-name" itemprop="name">modiShuriken</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:lcl1559935374@163.com" title="E-Mail → mailto:lcl1559935374@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">modiShuriken</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div> -->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
